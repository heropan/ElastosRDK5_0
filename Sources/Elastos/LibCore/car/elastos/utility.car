
module
{
    //======================================================
    // Elastos.Utility
    //======================================================
    merge("utility/Exceptions.car");
    //merge("utility/IObjectEnumerator.car");
    //merge("utility/IObjectContainer.car");
    merge("utility/IRandom.car");
    merge("utility/IBitSet.car");
    merge("utility/IDate.car");
    merge("utility/ICalendar.car");
    merge("utility/IIterable.car");
    merge("utility/ICollection.car");
    merge("utility/IList.car");
    merge("utility/ILocale.car");
    merge("utility/IMap.car");
    merge("utility/IHashMap.car");
    merge("utility/IHashSet.car");
    merge("utility/IHashTable.car");
    merge("utility/IIdentityHashMap.car");
    merge("utility/ILinkedHashMap.car");
    merge("utility/ILinkedHashSet.car");
    merge("utility/ILinkedList.car");
    merge("utility/IDictionary.car");
    merge("utility/IProperties.car");
    merge("utility/IEnumeration.car");
    merge("utility/IGregorianCalendar.car");
    merge("utility/IIterator.car");
    merge("utility/IListIterator.car");
    merge("utility/IQueue.car");
    merge("utility/IDeque.car");
    merge("utility/IRandomAccess.car");
    merge("utility/ITimeZone.car");
    merge("utility/ISimpleTimeZone.car");
    merge("utility/ITimerTask.car");
    merge("utility/ITimer.car");
    merge("utility/ICurrency.car");
    merge("utility/IUUID.car");
    merge("utility/ITimeZoneGetter.car");
    merge("utility/IArrayList.car");
    merge("utility/IFormattableFlags.car");
    merge("utility/IFormatter.car");
    merge("utility/IFormattable.car");
    merge("utility/IArrayDeque.car");
    merge("utility/IEventListener.car");
    merge("utility/IEventListenerProxy.car");
    merge("utility/IEventObject.car");
    merge("utility/IResourceBundle.car");
    merge("utility/IListResourceBundle.car");
    merge("utility/ISortedMap.car");
    merge("utility/INavigableMap.car");
    merge("utility/ISet.car");
    merge("utility/ISortedSet.car");
    merge("utility/INavigableSet.car");
    merge("utility/IObserver.car");
    merge("utility/IObservable.car");
    merge("utility/IPriorityQueue.car");
    merge("utility/IPropertyResourceBundle.car");
    merge("utility/IScanner.car");
    merge("utility/IServiceLoader.car");
    merge("utility/IVector.car");
    merge("utility/IStack.car");
    merge("utility/IStringTokenizer.car");
    merge("utility/IUnsafeArrayList.car");
    merge("utility/ICollections.car");
    merge("utility/IEnumMap.car");

    //======================================================
    // Elastos.Utility.Regex
    //======================================================
    merge("utility/regex/IMatchResult.car");
    merge("utility/regex/IMatcher.car");
    merge("utility/regex/ISplitter.car");
    merge("utility/regex/IPattern.car");

    //======================================================
    // Elastos.Utility.Logging
    //======================================================
    merge("utility/logging/ILevel.car");
    merge("utility/logging/IErrorManager.car");
    merge("utility/logging/IFilter.car");
    merge("utility/logging/ILogFormatter.car");
    merge("utility/logging/ILogHandler.car");
    merge("utility/logging/ILogger.car");
    merge("utility/logging/ILoggingMXBean.car");
    merge("utility/logging/ILogManager.car");
    merge("utility/logging/ILogRecord.car");
    merge("utility/logging/IStreamHandler.car");
    merge("utility/logging/IConsoleHandler.car");
    merge("utility/logging/IMemoryHandler.car");
    merge("utility/logging/ISimpleFormatter.car");
    merge("utility/logging/ISocketHandler.car");
    merge("utility/logging/IXMLFormatter.car");

    //======================================================
    // Elastos.Utility.Prefs
    //======================================================
    merge("utility/prefs/INodeChangeEvent.car");
    merge("utility/prefs/INodeChangeListener.car");
    merge("utility/prefs/IPreferenceChangeEvent.car");
    merge("utility/prefs/IPreferenceChangeListener.car");
    merge("utility/prefs/IPreferences.car");
    merge("utility/prefs/IPreferencesFactory.car");
    merge("utility/prefs/IXMLParser.car");
    merge("utility/prefs/IAbstractPreferences.car");
    merge("utility/prefs/IFilePreferencesFactoryImpl.car");
    merge("utility/prefs/IFilePreferencesImpl.car");

    merge("utility/spi/ILocaleServiceProvider.car");
    merge("utility/spi/ICurrencyNameProvider.car");
    merge("utility/spi/ILocaleNameProvider.car");
    merge("utility/spi/ITimeZoneNameProvider.car");

    //======================================================
    // Elastos.Utility.Concurrent
    //======================================================
    merge("utility/concurrent/atomic/IAtomicBoolean.car");
    merge("utility/concurrent/atomic/IAtomicInteger32.car");
    merge("utility/concurrent/atomic/IAtomicInteger32Array.car");
    merge("utility/concurrent/atomic/IAtomicInteger32FieldUpdater.car");
    merge("utility/concurrent/atomic/IAtomicInteger64.car");
    merge("utility/concurrent/atomic/IAtomicInteger64Array.car");
    merge("utility/concurrent/atomic/IAtomicInteger64FieldUpdater.car");
    merge("utility/concurrent/atomic/IAtomicMarkableReference.car");
    merge("utility/concurrent/atomic/IAtomicReference.car");
    merge("utility/concurrent/atomic/IAtomicReferenceArray.car");
    merge("utility/concurrent/atomic/IAtomicReferenceFieldUpdater.car");
    merge("utility/concurrent/atomic/IAtomicStampedReference.car");
    merge("utility/concurrent/atomic/IFences.car");

    merge("utility/concurrent/locks/ILockSupport.car");
    merge("utility/concurrent/locks/IAbstractQueuedInteger64Synchronizer.car");
    merge("utility/concurrent/locks/IAbstractQueuedSynchronizer.car");
    merge("utility/concurrent/locks/ICondition.car");
    merge("utility/concurrent/locks/ILock.car");
    merge("utility/concurrent/locks/IReadWriteLock.car");
    merge("utility/concurrent/locks/IReentrantLock.car");
    merge("utility/concurrent/locks/IReentrantReadWriteLock.car");

    merge("utility/concurrent/Exceptions.car");
    merge("utility/concurrent/IBlockingQueue.car");
    merge("utility/concurrent/ICallable.car");
    merge("utility/concurrent/ICompletionService.car");
    merge("utility/concurrent/ICountDownLatch.car");
    merge("utility/concurrent/IExecutor.car");
    merge("utility/concurrent/IExecutors.car");
    merge("utility/concurrent/IExecutorService.car");
    merge("utility/concurrent/IAbstractExecutorService.car");
    merge("utility/concurrent/IFuture.car");
    merge("utility/concurrent/IRejectedExecutionHandler.car");
    merge("utility/concurrent/IRunnableFuture.car");
    merge("utility/concurrent/IThreadFactory.car");
    merge("utility/concurrent/IThreadPoolExecutor.car");
    merge("utility/concurrent/ITimeUnit.car");
    merge("utility/concurrent/IArrayBlockingQueue.car");
    merge("utility/concurrent/IBlockingDeque.car");
    merge("utility/concurrent/IConcurrentLinkedQueue.car");
    merge("utility/concurrent/ICopyOnWriteArrayList.car");
    merge("utility/concurrent/ICyclicBarrier.car");
    merge("utility/concurrent/IDelayed.car");
    merge("utility/concurrent/IDelayQueue.car");
    merge("utility/concurrent/IExchanger.car");
    merge("utility/concurrent/IForkJoinPool.car");
    merge("utility/concurrent/IForkJoinWorkerThread.car");
    merge("utility/concurrent/IForkJoinTask.car");
    merge("utility/concurrent/IPhaser.car");
    merge("utility/concurrent/IRunnableScheduledFuture.car");
    merge("utility/concurrent/ISemaphore.car");
    merge("utility/concurrent/ISynchronousQueue.car");
    merge("utility/concurrent/IThreadLocalRandom.car");
    merge("utility/concurrent/ITransferQueue.car");
    merge("utility/concurrent/IConcurrentMap.car");
    merge("utility/concurrent/IConcurrentHashMap.car");

    //======================================================
    // Elastos.Utility.Zip
    //======================================================
    merge("utility/zip/Errors.car");
    merge("utility/zip/Exceptions.car");
    merge("utility/zip/IZipConstants.car");
    merge("utility/zip/IChecksum.car");
    merge("utility/zip/IAdler32.car");
    merge("utility/zip/ICRC32.car");
    merge("utility/zip/IInflater.car");
    merge("utility/zip/IDeflater.car");
    merge("utility/zip/IZipEntry.car");
    merge("utility/zip/IInflaterInputStream.car");
    merge("utility/zip/IInflaterOutputStream.car");
    merge("utility/zip/IDeflaterInputStream.car");
    merge("utility/zip/IDeflaterOutputStream.car");
    merge("utility/zip/IZipInputStream.car");
    merge("utility/zip/IZipOutputStream.car");
    merge("utility/zip/ICheckedInputStream.car");
    merge("utility/zip/ICheckedOutputStream.car");
    merge("utility/zip/IGZIPInputStream.car");
    merge("utility/zip/IGZIPOutputStream.car");
    merge("utility/zip/IZipFile.car");


    //======================================================
    // Elastos.Utility.Jar
    //======================================================
    merge("utility/jar/IAttributes.car");
    merge("utility/jar/IJarEntry.car");
    merge("utility/jar/IManifest.car");
    merge("utility/jar/IJarFile.car");
    merge("utility/jar/IJarInputStream.Car");
    merge("utility/jar/IJarOutputStream.car");
    merge("utility/jar/IPack200.car");


    interface Elastos.Core.IComparable;
    interface Elastos.Core.ICloneable;
    interface Elastos.Core.IAppendable;
    interface Elastos.IO.ISerializable;
    interface Elastos.IO.IFilterInputStream;
    interface Elastos.IO.IFilterOutputStream;
    interface Elastos.IO.ICloseable;
    interface Elastos.IO.IReader;
    interface Elastos.IO.IReadable;
    interface Elastos.IO.IPrintStream;
    interface Elastos.IO.IFlushable;
    interface Elastos.IO.Channels.IReadableByteChannel;
    interface Elastos.IO.Charset.ICharset;
    interface Elastos.Utility.ICollection;
    interface Elastos.Utility.ISet;
    interface Elastos.Utility.IDeque;
    interface Elastos.Utility.IQueue;
    interface Elastos.Utility.IIterable;
    interface Elastos.Utility.IRandomAccess;
    interface Elastos.Utility.Zip.IZipEntry;


    namespace Elastos {
    namespace Utility {

        class CRandom {
            constructor();

            constructor(
                [in] Int64 seed);

            interface IRandom;
            interface ISerializable;
        }

        class CStringTokenizer {
            /**
             * Constructs a new {@code StringTokenizer} for the parameter string using
             * whitespace as the delimiter. The {@code returnDelimiters} flag is set to
             * {@code false}.
             *
             * @param string
             *            the string to be tokenized.
             */
            constructor(
                [in] String string);

            /**
             * Constructs a new {@code StringTokenizer} for the parameter string using
             * the specified delimiters. The {@code returnDelimiters} flag is set to
             * {@code false}. If {@code delimiters} is {@code null}, this constructor
             * doesn't throw an {@code Exception}, but later calls to some methods might
             * throw a {@code NullPointerException}.
             *
             * @param string
             *            the string to be tokenized.
             * @param delimiters
             *            the delimiters to use.
             */
            constructor(
                [in] String string,
                [in] String delimiters);

            /**
             * Constructs a new {@code StringTokenizer} for the parameter string using
             * the specified delimiters, returning the delimiters as tokens if the
             * parameter {@code returnDelimiters} is {@code true}. If {@code delimiters}
             * is null this constructor doesn't throw an {@code Exception}, but later
             * calls to some methods might throw a {@code NullPointerException}.
             *
             * @param string
             *            the string to be tokenized.
             * @param delimiters
             *            the delimiters to use.
             * @param returnDelimiters
             *            {@code true} to return each delimiter as a token.
             */
            constructor(
                [in] String string,
                [in] String delimiters,
                [in] Boolean returnDelimiters);

            interface IStringTokenizer;
            interface IEnumeration;
        }

        class CArrayDeque {
            constructor();

            constructor(
                [in] Int32 numElements);

            constructor(
                [in] ICollection* c);

            interface IArrayDeque;
            interface ICollection;
            interface IIterable;
            interface IDeque;
            interface ICloneable;
            interface ISerializable;
        }

        class CArrayList {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] ICollection* c);

            interface IArrayList;
            interface ICloneable;
            interface ISerializable;
            interface IRandomAccess;
        }

        [deprecated]
        class CBitSet {
            constructor();

            constructor(
                [in] Int32 bitCount);

            constructor(
                [in] ArrayOf<Int64>* array);

            interface IBitSet;
            interface ISerializable;
            interface ICloneable;
        }

        singleton class CBitSetHelper {

            interface IBitSetHelper;
        }

        class CEnumMap {
            constructor();

            constructor(
                [in] InterfaceID keyType);

            constructor(
                [in] IEnumMap* enummap);

            constructor(
                [in] IMap* map);

            interface IEnumMap;
            interface ISerializable;
            interface ICloneable;
            interface IMap;
        }

        class CHashMap {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor);

            constructor(
                [in] IMap* map);

            interface IHashMap;
            interface IMap;
            interface ICloneable;
            interface ISerializable;
        }

        class CHashSet {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor);

            constructor(
                [in] ICollection* collection);

            constructor(
                [in] IMap* backingMap);

            interface IHashSet;
            interface ISet;
            interface ICollection;
            interface IIterable;
            interface ICloneable;
            interface ISerializable;
        }

        class CHashTable {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor);

            constructor(
                [in] IMap* backingMap);

            interface IHashTable;
            interface IDictionary;
            interface IMap;
            interface ICloneable;
            interface ISerializable;
        }

        class CIdentityHashMap {
            constructor();

            constructor(
                [in] Int32 maxSize);

            constructor(
                [in] IMap* Map);

            interface IIdentityHashMap;
            interface IMap;
            interface ISerializable;
            interface ICloneable;
        }

        class CLinkedHashMap {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor,
                [in] Boolean accessOrder);

            constructor(
                [in] IMap* Map);

            interface ILinkedHashMap;
            interface IMap;
            interface ISerializable;
            interface ICloneable;
        }

        class CLinkedHashSet {
            constructor();

            constructor(
                [in] Int32 capacity);

            constructor(
                [in] Int32 capacity,
                [in] Float loadFactor);

            constructor(
                [in] ICollection* collection);

            interface ILinkedHashSet;
            interface IHashSet;
            interface ISet;
            interface ICollection;
            interface ISerializable;
            interface ICloneable;
        }

        class CLinkedList {
            constructor();

            constructor(
                [in] ICollection* collection);

            interface ILinkedList;
            interface IList;
            interface ICollection;
            interface IIterable;
            interface IDeque;
            interface IQueue;
            interface ICloneable;
            interface ISerializable;
        }

        singleton class CCalendarHelper {
            interface ICalendarHelper;
        }

        singleton class CCurrencyHelper {
            interface ICurrencyHelper;
        }

        singleton class CDateHelper {
            interface IDateHelper;
        }

        class CGregorianCalendar {
            /**
             * Constructs a new {@code GregorianCalendar} initialized to the current date and
             * time with the default {@code Locale} and {@code TimeZone}.
             */
            constructor();

            /**
             * Constructs a new {@code GregorianCalendar} initialized to midnight in the default
             * {@code TimeZone} and {@code Locale} on the specified date.
             *
             * @param year
             *            the year.
             * @param month
             *            the month.
             * @param day
             *            the day of the month.
             */
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day);

            /**
             * Constructs a new {@code GregorianCalendar} initialized to the specified date and
             * time in the default {@code TimeZone} and {@code Locale}.
             *
             * @param year
             *            the year.
             * @param month
             *            the month.
             * @param day
             *            the day of the month.
             * @param hour
             *            the hour.
             * @param minute
             *            the minute.
             */
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day,
                [in] Int32 hour,
                [in] Int32 minute);

            /**
             * Constructs a new {@code GregorianCalendar} initialized to the specified date and
             * time in the default {@code TimeZone} and {@code Locale}.
             *
             * @param year
             *            the year.
             * @param month
             *            the month.
             * @param day
             *            the day of the month.
             * @param hour
             *            the hour.
             * @param minute
             *            the minute.
             * @param second
             *            the second.
             */
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day,
                [in] Int32 hour,
                [in] Int32 minute,
                [in] Int32 second);

            constructor(
                [in] Int64 milliseconds);

            /**
             * Constructs a new {@code GregorianCalendar} initialized to the current date and
             * time and using the specified {@code Locale} and the default {@code TimeZone}.
             *
             * @param locale
             *            the {@code Locale}.
             */
            constructor(
                [in] ILocale* locale);

            /**
             * Constructs a new {@code GregorianCalendar} initialized to the current date and
             * time and using the specified {@code TimeZone} and the default {@code Locale}.
             *
             * @param timezone
             *            the {@code TimeZone}.
             */
            constructor(
                [in] ITimeZone* timeZone);

            /**
             * Constructs a new {@code GregorianCalendar} initialized to the current date and
             * time and using the specified {@code TimeZone} and {@code Locale}.
             *
             * @param timezone
             *            the {@code TimeZone}.
             * @param locale
             *            the {@code Locale}.
             */
            constructor(
                [in] ITimeZone* timeZone,
                [in] ILocale* locale);

            constructor(
                [in] Boolean ignored);

            interface IGregorianCalendar;
            interface ICalendar;
            interface ISerializable;
            interface ICloneable;
            interface IComparable;
        }

        class CTimer {
            constructor(
                [in] String name,
                [in] Boolean isDaemon);

            constructor(
                [in] String name);

            constructor(
                [in] Boolean isDaemon);

            constructor();

            interface ITimer;
        }

        class CUUID {
            /**
             * <p>
             * Constructs an instance with the specified bits.
             *
             * @param mostSigBits
             *            The 64 most significant bits of the UUID.
             * @param leastSigBits
             *            The 64 least significant bits of the UUID.
             */
            constructor(
                [in] Int64 mostSigBits,
                [in] Int64 leastSigBits);

            interface IUUID;
            interface IComparable;
            interface ISerializable;
        }

        singleton class CUUIDHelper {
            interface IUUIDHelper;
        }

        singleton class CTimeZoneGetterHelper {
           interface ITimeZoneGetterHelper;
        }

        singleton class CTimeZoneHelper {
            interface ITimeZoneHelper;
        }

        class CLocale {
            /**
             * There's a circular dependency between toLowerCase/toUpperCase and
             * Locale.US. Work around this by avoiding these methods when constructing
             * the built-in locales.
             *
             * @param unused required for this constructor to have a unique signature
             */
            constructor(
                [in] Boolean unused,
                [in] String lowerCaseLanguageCode,
                [in] String upperCaseCountryCode);

            constructor();

            /**
             * Constructs a new {@code Locale} using the specified language.
             */
            constructor(
                [in] String language);

            /**
             * Constructs a new {@code Locale} using the specified language and country codes.
             */
            constructor(
               [in] String language,
               [in] String country);

            /**
             * Constructs a new {@code Locale} using the specified language, country,
             * and variant codes.
             */
            constructor(
                [in] String language,
                [in] String country,
                [in] String variant);

            interface ILocale;
            interface ICloneable;
            interface ISerializable;
        }

        singleton class CLocaleHelper {
            interface ILocaleHelper;
        }

        class CLocaleBuilder {
            constructor();

            interface ILocaleBuilder;
        }

        class CDate {

            constructor();

            //@Deprecated
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day);

            //@Deprecated
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day,
                [in] Int32 hour,
                [in] Int32 minute);

            //@Deprecated
            constructor(
                [in] Int32 year,
                [in] Int32 month,
                [in] Int32 day,
                [in] Int32 hour,
                [in] Int32 minute,
                [in] Int32 second);

            constructor(
                [in] Int64 milliseconds);

            //@Deprecated
            constructor(
                [in] String string);

            interface IDate;
            interface ISerializable;
            interface ICloneable;
            interface IComparable;
        }

        class CProperties {
            constructor();

            constructor(
                [in] IProperties * properties);

            interface IProperties;
            interface IMap;
            interface ICloneable;
            interface ISerializable;
        }

        class CPropertyResourceBundle {
            constructor();

            /**
             * Constructs a new instance of {@code PropertyResourceBundle} and loads the
             * properties file from the specified {@code InputStream}.
             *
             * @param stream
             *            the {@code InputStream}.
             * @throws IOException
             *             if an error occurs during a read operation on the
             *             {@code InputStream}.
             */
            constructor(
                [in] IInputStream* stream);

            /**
             * Constructs a new resource bundle with properties read from {@code reader}.
             *
             * @param reader the {@code Reader}
             * @throws IOException
             * @since 1.6
             */
            constructor(
                [in] IReader* reader);

            interface IPropertyResourceBundle;
        }

        class CFormatter {
            /**
             * Constructs a {@code Formatter}.
             *
             * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
             * {@link #out()} and whose content can be obtained by calling {@code toString}.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             */
            constructor();

            /**
             * Constructs a {@code Formatter} whose output will be written to the
             * specified {@code Appendable}.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param a
             *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
             *            then a {@code StringBuilder} will be used.
             */
            constructor(
                [in] IAppendable* a);

            /**
             * Constructs a {@code Formatter} with the specified {@code Locale}.
             *
             * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
             * {@link #out()} and whose content can be obtained by calling {@code toString}.
             *
             * @param l
             *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
             *            then no localization will be used.
             */
            constructor(
                [in] ILocale* l);

            /**
             * Constructs a {@code Formatter} with the specified {@code Locale}
             * and whose output will be written to the
             * specified {@code Appendable}.
             *
             * @param a
             *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
             *            then a {@code StringBuilder} will be used.
             * @param l
             *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
             *            then no localization will be used.
             */
            constructor(
                [in] IAppendable* a,
                [in] ILocale* l);

            /**
             * Constructs a {@code Formatter} whose output is written to the specified file.
             *
             * <p>The charset of the {@code Formatter} is the default charset.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param fileName
             *            the filename of the file that is used as the output
             *            destination for the {@code Formatter}. The file will be truncated to
             *            zero size if the file exists, or else a new file will be
             *            created. The output of the {@code Formatter} is buffered.
             * @throws FileNotFoundException
             *             if the filename does not denote a normal and writable file,
             *             or if a new file cannot be created, or if any error arises when
             *             opening or creating the file.
             */
            constructor(
                [in] String fileName);

            /**
             * Constructs a {@code Formatter} whose output is written to the specified file.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param fileName
             *            the filename of the file that is used as the output
             *            destination for the {@code Formatter}. The file will be truncated to
             *            zero size if the file exists, or else a new file will be
             *            created. The output of the {@code Formatter} is buffered.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @throws FileNotFoundException
             *             if the filename does not denote a normal and writable file,
             *             or if a new file cannot be created, or if any error arises when
             *             opening or creating the file.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.
             */
            constructor(
                [in] String fileName,
                [in] String csn);

            /**
             * Constructs a {@code Formatter} with the given {@code Locale} and charset,
             * and whose output is written to the specified file.
             *
             * @param fileName
             *            the filename of the file that is used as the output
             *            destination for the {@code Formatter}. The file will be truncated to
             *            zero size if the file exists, or else a new file will be
             *            created. The output of the {@code Formatter} is buffered.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @param l
             *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
             *            then no localization will be used.
             * @throws FileNotFoundException
             *             if the filename does not denote a normal and writable file,
             *             or if a new file cannot be created, or if any error arises when
             *             opening or creating the file.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.
             */
            constructor(
                [in] String fileName,
                [in] String csn,
                [in] ILocale* l);

            /**
             * Constructs a {@code Formatter} whose output is written to the specified {@code File}.
             *
             * The charset of the {@code Formatter} is the default charset.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param file
             *            the {@code File} that is used as the output destination for the
             *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
             *            exists, or else a new {@code File} will be created. The output of the
             *            {@code Formatter} is buffered.
             * @throws FileNotFoundException
             *             if the {@code File} is not a normal and writable {@code File}, or if a
             *             new {@code File} cannot be created, or if any error rises when opening or
             *             creating the {@code File}.
             */
            constructor(
                [in] IFile* file);

            /*
             * Constructs a {@code Formatter} with the given charset,
             * and whose output is written to the specified {@code File}.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param file
             *            the {@code File} that is used as the output destination for the
             *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
             *            exists, or else a new {@code File} will be created. The output of the
             *            {@code Formatter} is buffered.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @throws FileNotFoundException
             *             if the {@code File} is not a normal and writable {@code File}, or if a
             *             new {@code File} cannot be created, or if any error rises when opening or
             *             creating the {@code File}.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.

            constructor(
                [in] IFile* file,
                [in] String csn);

            /**
             * Constructs a {@code Formatter} with the given {@code Locale} and charset,
             * and whose output is written to the specified {@code File}.
             *
             * @param file
             *            the {@code File} that is used as the output destination for the
             *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
             *            exists, or else a new {@code File} will be created. The output of the
             *            {@code Formatter} is buffered.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @param l
             *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
             *            then no localization will be used.
             * @throws FileNotFoundException
             *             if the {@code File} is not a normal and writable {@code File}, or if a
             *             new {@code File} cannot be created, or if any error rises when opening or
             *             creating the {@code File}.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.
             */
            constructor(
                [in] IFile* file,
                [in] String csn,
                [in] ILocale* l);

            /**
             * Constructs a {@code Formatter} whose output is written to the specified {@code OutputStream}.
             *
             * <p>The charset of the {@code Formatter} is the default charset.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param os
             *            the stream to be used as the destination of the {@code Formatter}.
             */
            constructor(
                [in] IOutputStream* os);

            /**
             * Constructs a {@code Formatter} with the given charset,
             * and whose output is written to the specified {@code OutputStream}.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param os
             *            the stream to be used as the destination of the {@code Formatter}.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.
             */
            constructor(
                [in] IOutputStream* os,
                [in] String csn);

            /**
             * Constructs a {@code Formatter} with the given {@code Locale} and charset,
             * and whose output is written to the specified {@code OutputStream}.
             *
             * @param os
             *            the stream to be used as the destination of the {@code Formatter}.
             * @param csn
             *            the name of the charset for the {@code Formatter}.
             * @param l
             *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
             *            then no localization will be used.
             * @throws UnsupportedEncodingException
             *             if the charset with the specified name is not supported.
             */
            constructor(
                [in] IOutputStream* os,
                [in] String csn,
                [in] ILocale* l);

            /**
             * Constructs a {@code Formatter} whose output is written to the specified {@code PrintStream}.
             *
             * <p>The charset of the {@code Formatter} is the default charset.
             *
             * <p>The {@code Locale} used is the user's default locale.
             * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
             *
             * @param ps
             *            the {@code PrintStream} used as destination of the {@code Formatter}. If
             *            {@code ps} is {@code null}, then a {@code NullPointerException} will
             *            be raised.
             */
            constructor(
                [in] IPrintStream* ps);

            interface IFormatter;
            interface ICloseable;
            interface IFlushable;
        }

        class CScanner {
            /**
             * Creates a {@code Scanner} with the specified {@code File} as input. The default charset
             * is applied when reading the file.
             *
             * @param src
             *            the file to be scanned.
             * @throws FileNotFoundException
             *             if the specified file does not exist.
             */
            constructor(
                [in] IFile* filesrc);

            /**
             * Creates a {@code Scanner} with the specified {@code File} as input. The specified charset
             * is applied when reading the file.
             *
             * @param src
             *            the file to be scanned.
             * @param charsetName
             *            the name of the encoding type of the file.
             * @throws FileNotFoundException
             *             if the specified file does not exist.
             * @throws IllegalArgumentException
             *             if the specified coding does not exist.
             */
            constructor(
                [in] IFile* filesrc,
                [in] String charsetName);

            /**
             * Creates a {@code Scanner} on the specified string.
             *
             * @param src
             *            the string to be scanned.
             */
            constructor(
                [in] String strsrc);

            /**
             * Creates a {@code Scanner} on the specified {@code InputStream}. The default charset is
             * applied when decoding the input.
             *
             * @param src
             *            the {@code InputStream} to be scanned.
             */
            constructor(
                [in] IInputStream* inputsrc);

            /**
             * Creates a {@code Scanner} on the specified {@code InputStream}. The specified charset is
             * applied when decoding the input.
             *
             * @param src
             *            the {@code InputStream} to be scanned.
             * @param charsetName
             *            the encoding type of the {@code InputStream}.
             * @throws IllegalArgumentException
             *             if the specified character set is not found.
             */
            constructor(
                [in] IInputStream* inputsrc,
                [in] String charsetName);

            /**
             * Creates a {@code Scanner} with the specified {@code Readable} as input.
             *
             * @param src
             *            the {@code Readable} to be scanned.
             */
            constructor(
                [in] IReadable* readsrc);

            /**
             * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
             * input. The default charset is applied when decoding the input.
             *
             * @param src
             *            the {@code ReadableByteChannel} to be scanned.
             */
            constructor(
                [in] IReadableByteChannel* rbcsrc);

            /**
             * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
             * input. The specified charset is applied when decoding the input.
             *
             * @param src
             *            the {@code ReadableByteChannel} to be scanned.
             * @param charsetName
             *            the encoding type of the content.
             * @throws IllegalArgumentException
             *             if the specified character set is not found.
             */
            constructor(
                [in] IReadableByteChannel* rbcsrc,
                [in] String charsetName);

            interface IScanner;
        }

        class CSimpleTimeZone {
            /**
             * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT
             * and time zone ID. Timezone IDs can be obtained from
             * {@code TimeZone.getAvailableIDs}. Normally you should use {@code TimeZone.getDefault} to
             * construct a {@code TimeZone}.
             *
             * @param offset
             *            the given base time zone offset to GMT.
             * @param name
             *            the time zone ID which is obtained from
             *            {@code TimeZone.getAvailableIDs}.
             */
            constructor(
                [in] Int32 offset,
                [in] String name);

            /**
             * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
             * time zone ID, and times to start and end the daylight savings time. Timezone IDs can
             * be obtained from {@code TimeZone.getAvailableIDs}. Normally you should use
             * {@code TimeZone.getDefault} to create a {@code TimeZone}. For a time zone that does not
             * use daylight saving time, do not use this constructor; instead you should
             * use {@code SimpleTimeZone(rawOffset, ID)}.
             * <p>
             * By default, this constructor specifies day-of-week-in-month rules. That
             * is, if the {@code startDay} is 1, and the {@code startDayOfWeek} is {@code SUNDAY}, then this
             * indicates the first Sunday in the {@code startMonth}. A {@code startDay} of -1 likewise
             * indicates the last Sunday. However, by using negative or zero values for
             * certain parameters, other types of rules can be specified.
             * <p>
             * Day of month: To specify an exact day of the month, such as March 1, set
             * {@code startDayOfWeek} to zero.
             * <p>
             * Day of week after day of month: To specify the first day of the week
             * occurring on or after an exact day of the month, make the day of the week
             * negative. For example, if {@code startDay} is 5 and {@code startDayOfWeek} is {@code -MONDAY},
             * this indicates the first Monday on or after the 5th day of the
             * {@code startMonth}.
             * <p>
             * Day of week before day of month: To specify the last day of the week
             * occurring on or before an exact day of the month, make the day of the
             * week and the day of the month negative. For example, if {@code startDay} is {@code -21}
             * and {@code startDayOfWeek} is {@code -WEDNESDAY}, this indicates the last Wednesday on or
             * before the 21st of the {@code startMonth}.
             * <p>
             * The above examples refer to the {@code startMonth}, {@code startDay}, and {@code startDayOfWeek};
             * the same applies for the {@code endMonth}, {@code endDay}, and {@code endDayOfWeek}.
             * <p>
             * The daylight savings time difference is set to the default value: one hour.
             *
             * @param offset
             *            the given base time zone offset to GMT.
             * @param name
             *            the time zone ID which is obtained from
             *            {@code TimeZone.getAvailableIDs}.
             * @param startMonth
             *            the daylight savings starting month. The month indexing is 0-based. eg, 0
             *            for January.
             * @param startDay
             *            the daylight savings starting day-of-week-in-month. Please see
             *            the member description for an example.
             * @param startDayOfWeek
             *            the daylight savings starting day-of-week. Please see the
             *            member description for an example.
             * @param startTime
             *            the daylight savings starting time in local wall time, which
             *            is standard time in this case. Please see the member
             *            description for an example.
             * @param endMonth
             *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
             *            January.
             * @param endDay
             *            the daylight savings ending day-of-week-in-month. Please see
             *            the member description for an example.
             * @param endDayOfWeek
             *            the daylight savings ending day-of-week. Please see the member
             *            description for an example.
             * @param endTime
             *            the daylight savings ending time in local wall time, which is
             *            daylight time in this case. Please see the member description
             *            for an example.
             * @throws IllegalArgumentException
             *             if the month, day, dayOfWeek, or time parameters are out of
             *             range for the start or end rule.
             */
            constructor(
                [in] Int32 offset,
                [in] String name,
                [in] Int32 startMonth,
                [in] Int32 startDay,
                [in] Int32 startDayOfWeek,
                [in] Int32 startTime,
                [in] Int32 endMonth,
                [in] Int32 endDay,
                [in] Int32 endDayOfWeek,
                [in] Int32 endTime);

            /**
             * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
             * time zone ID, times to start and end the daylight savings time, and
             * the daylight savings time difference in milliseconds.
             *
             * @param offset
             *            the given base time zone offset to GMT.
             * @param name
             *            the time zone ID which is obtained from
             *            {@code TimeZone.getAvailableIDs}.
             * @param startMonth
             *            the daylight savings starting month. Month is 0-based. eg, 0
             *            for January.
             * @param startDay
             *            the daylight savings starting day-of-week-in-month. Please see
             *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param startDayOfWeek
             *            the daylight savings starting day-of-week. Please see the
             *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param startTime
             *            The daylight savings starting time in local wall time, which
             *            is standard time in this case. Please see the description of
             *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param endMonth
             *            the daylight savings ending month. Month is 0-based. eg, 0 for
             *            January.
             * @param endDay
             *            the daylight savings ending day-of-week-in-month. Please see
             *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param endDayOfWeek
             *            the daylight savings ending day-of-week. Please see the description of
             *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param endTime
             *            the daylight savings ending time in local wall time, which is
             *            daylight time in this case. Please see the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)}
             *            for an example.
             * @param daylightSavings
             *            the daylight savings time difference in milliseconds.
             * @throws IllegalArgumentException
             *                if the month, day, dayOfWeek, or time parameters are out of
             *                range for the start or end rule.
             */
            constructor(
                [in] Int32 offset,
                [in] String name,
                [in] Int32 startMonth,
                [in] Int32 startDay,
                [in] Int32 startDayOfWeek,
                [in] Int32 startTime,
                [in] Int32 endMonth,
                [in] Int32 endDay,
                [in] Int32 endDayOfWeek,
                [in] Int32 endTime,
                [in] Int32 daylightSavings);

            /**
             * Construct a {@code SimpleTimeZone} with the given base time zone offset from GMT,
             * time zone ID, times to start and end the daylight savings time including a
             * mode specifier, the daylight savings time difference in milliseconds.
             * The mode specifies either {@link #WALL_TIME}, {@link #STANDARD_TIME}, or
             * {@link #UTC_TIME}.
             *
             * @param offset
             *            the given base time zone offset to GMT.
             * @param name
             *            the time zone ID which is obtained from
             *            {@code TimeZone.getAvailableIDs}.
             * @param startMonth
             *            the daylight savings starting month. The month indexing is 0-based. eg, 0
             *            for January.
             * @param startDay
             *            the daylight savings starting day-of-week-in-month. Please see
             *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param startDayOfWeek
             *            the daylight savings starting day-of-week. Please see the
             *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param startTime
             *            the time of day in milliseconds on which daylight savings
             *            time starts, based on the {@code startTimeMode}.
             * @param startTimeMode
             *            the mode (UTC, standard, or wall time) of the start time
             *            value.
             * @param endDay
             *            the day of the week on which daylight savings time ends.
             * @param endMonth
             *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
             *            January.
             * @param endDayOfWeek
             *            the daylight savings ending day-of-week. Please see the description of
             *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
             * @param endTime
             *            the time of day in milliseconds on which daylight savings
             *            time ends, based on the {@code endTimeMode}.
             * @param endTimeMode
             *            the mode (UTC, standard, or wall time) of the end time value.
             * @param daylightSavings
             *            the daylight savings time difference in milliseconds.
             * @throws IllegalArgumentException
             *             if the month, day, dayOfWeek, or time parameters are out of
             *             range for the start or end rule.
             */
            constructor(
                [in] Int32 offset,
                [in] String name,
                [in] Int32 startMonth,
                [in] Int32 startDay,
                [in] Int32 startDayOfWeek,
                [in] Int32 startTime,
                [in] Int32 startTimeMode,
                [in] Int32 endMonth,
                [in] Int32 endDay,
                [in] Int32 endDayOfWeek,
                [in] Int32 endTime,
                [in] Int32 endTimeMode,
                [in] Int32 daylightSavings);

            interface ISimpleTimeZone;
            interface ICloneable;
            interface ISerializable;
        }

        class CObservable {
            /**
             * Constructs a new {@code Observable} object.
             */
            constructor();

            interface IObservable;
        }

    } // namespace Utility
    } // namespace Elastos

    namespace Elastos {
    namespace Utility {
    namespace Concurrent {

    // class CCountDownLatch {
    //     /**
    //      * Constructs a {@code CountDownLatch} initialized with the given count.
    //      *
    //      * @param count the number of times {@link #countDown} must be invoked
    //      *        before threads can pass through {@link #await}
    //      * @throws IllegalArgumentException if {@code count} is negative
    //      */
    //     constructor(
    //         [in] Int32 count);

    //     interface ICountDownLatch;
    // }

    // class CExecutorCompletionService {
    //     constructor(
    //         [in] IExecutor* executor);

    //     constructor(
    //         [in] IExecutor* executor,
    //         [in] IBlockingQueue* completionQueue);

    //     interface ICompletionService;
    // }

    // singleton class CExecutors {
    //     interface IExecutors;
    // }

    // class CFutureTask {
    //     constructor(
    //         [in] ICallable* callable);

    //     constructor(
    //         [in] IRunnable* runnable,
    //         [in] IInterface* result);

    //     interface IRunnableFuture;
    //     interface IFuture;
    //     interface IRunnable;
    // }

    // class CLinkedBlockingQueue {
    //     constructor();

    //     constructor(
    //         [in] Int32 capacity);

    //     constructor(
    //         [in] ICollection* c);

    //     interface IBlockingQueue;
    //     interface IQueue;
    //     interface ICollection;
    //     interface IIterable;
    //     interface ISerializable;
    // }

    // class CThreadPoolExecutor {
    //     /**
    //      * Creates a new {@code ThreadPoolExecutor} with the given initial
    //      * parameters and default thread factory and rejected execution handler.
    //      * It may be more convenient to use one of the {@link Executors} factory
    //      * methods instead of this general purpose constructor.
    //      *
    //      * @param corePoolSize the number of threads to keep in the pool, even
    //      *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
    //      * @param maximumPoolSize the maximum number of threads to allow in the
    //      *        pool
    //      * @param keepAliveTime when the number of threads is greater than
    //      *        the core, this is the maximum time that excess idle threads
    //      *        will wait for new tasks before terminating.
    //      * @param unit the time unit for the {@code keepAliveTime} argument
    //      * @param workQueue the queue to use for holding tasks before they are
    //      *        executed.  This queue will hold only the {@code Runnable}
    //      *        tasks submitted by the {@code execute} method.
    //      * @throws IllegalArgumentException if one of the following holds:<br>
    //      *         {@code corePoolSize < 0}<br>
    //      *         {@code keepAliveTime < 0}<br>
    //      *         {@code maximumPoolSize <= 0}<br>
    //      *         {@code maximumPoolSize < corePoolSize}
    //      * @throws NullPointerException if {@code workQueue} is null
    //      */
    //     constructor(
    //         [in] Int32 corePoolSize,
    //         [in] Int32 maximumPoolSize,
    //         [in] Int64 keepAliveTime,
    //         [in] ITimeUnit* unit,
    //         [in] IBlockingQueue* workQueue);

    //     /**
    //      * Creates a new {@code ThreadPoolExecutor} with the given initial
    //      * parameters and default rejected execution handler.
    //      *
    //      * @param corePoolSize the number of threads to keep in the pool, even
    //      *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
    //      * @param maximumPoolSize the maximum number of threads to allow in the
    //      *        pool
    //      * @param keepAliveTime when the number of threads is greater than
    //      *        the core, this is the maximum time that excess idle threads
    //      *        will wait for new tasks before terminating.
    //      * @param unit the time unit for the {@code keepAliveTime} argument
    //      * @param workQueue the queue to use for holding tasks before they are
    //      *        executed.  This queue will hold only the {@code Runnable}
    //      *        tasks submitted by the {@code execute} method.
    //      * @param threadFactory the factory to use when the executor
    //      *        creates a new thread
    //      * @throws IllegalArgumentException if one of the following holds:<br>
    //      *         {@code corePoolSize < 0}<br>
    //      *         {@code keepAliveTime < 0}<br>
    //      *         {@code maximumPoolSize <= 0}<br>
    //      *         {@code maximumPoolSize < corePoolSize}
    //      * @throws NullPointerException if {@code workQueue}
    //      *         or {@code threadFactory} is null
    //      */
    //     constructor(
    //         [in] Int32 corePoolSize,
    //         [in] Int32 maximumPoolSize,
    //         [in] Int64 keepAliveTime,
    //         [in] ITimeUnit* unit,
    //         [in] IBlockingQueue* workQueue,
    //         [in] IThreadFactory* threadFactory);

    //     /**
    //      * Creates a new {@code ThreadPoolExecutor} with the given initial
    //      * parameters and default thread factory.
    //      *
    //      * @param corePoolSize the number of threads to keep in the pool, even
    //      *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
    //      * @param maximumPoolSize the maximum number of threads to allow in the
    //      *        pool
    //      * @param keepAliveTime when the number of threads is greater than
    //      *        the core, this is the maximum time that excess idle threads
    //      *        will wait for new tasks before terminating.
    //      * @param unit the time unit for the {@code keepAliveTime} argument
    //      * @param workQueue the queue to use for holding tasks before they are
    //      *        executed.  This queue will hold only the {@code Runnable}
    //      *        tasks submitted by the {@code execute} method.
    //      * @param handler the handler to use when execution is blocked
    //      *        because the thread bounds and queue capacities are reached
    //      * @throws IllegalArgumentException if one of the following holds:<br>
    //      *         {@code corePoolSize < 0}<br>
    //      *         {@code keepAliveTime < 0}<br>
    //      *         {@code maximumPoolSize <= 0}<br>
    //      *         {@code maximumPoolSize < corePoolSize}
    //      * @throws NullPointerException if {@code workQueue}
    //      *         or {@code handler} is null
    //      */
    //     constructor(
    //         [in] Int32 corePoolSize,
    //         [in] Int32 maximumPoolSize,
    //         [in] Int64 keepAliveTime,
    //         [in] ITimeUnit* unit,
    //         [in] IBlockingQueue* workQueue,
    //         [in] IRejectedExecutionHandler* handler);

    //     /**
    //      * Creates a new {@code ThreadPoolExecutor} with the given initial
    //      * parameters.
    //      *
    //      * @param corePoolSize the number of threads to keep in the pool, even
    //      *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
    //      * @param maximumPoolSize the maximum number of threads to allow in the
    //      *        pool
    //      * @param keepAliveTime when the number of threads is greater than
    //      *        the core, this is the maximum time that excess idle threads
    //      *        will wait for new tasks before terminating.
    //      * @param unit the time unit for the {@code keepAliveTime} argument
    //      * @param workQueue the queue to use for holding tasks before they are
    //      *        executed.  This queue will hold only the {@code Runnable}
    //      *        tasks submitted by the {@code execute} method.
    //      * @param threadFactory the factory to use when the executor
    //      *        creates a new thread
    //      * @param handler the handler to use when execution is blocked
    //      *        because the thread bounds and queue capacities are reached
    //      * @throws IllegalArgumentException if one of the following holds:<br>
    //      *         {@code corePoolSize < 0}<br>
    //      *         {@code keepAliveTime < 0}<br>
    //      *         {@code maximumPoolSize <= 0}<br>
    //      *         {@code maximumPoolSize < corePoolSize}
    //      * @throws NullPointerException if {@code workQueue}
    //      *         or {@code threadFactory} or {@code handler} is null
    //      */
    //     constructor(
    //         [in] Int32 corePoolSize,
    //         [in] Int32 maximumPoolSize,
    //         [in] Int64 keepAliveTime,
    //         [in] ITimeUnit* unit,
    //         [in] IBlockingQueue* workQueue,
    //         [in] IThreadFactory* threadFactory,
    //         [in] IRejectedExecutionHandler* handler);

    //     interface IThreadPoolExecutor;
    //     interface IAbstractExecutorService;
    //     interface IExecutorService;
    //     interface IExecutor;
    // }

    singleton class CTimeUnitHelper {
        interface ITimeUnitHelper;
    }

    // class CArrayBlockingQueue {
    //     /**
    //      * Creates an {@code ArrayBlockingQueue} with the given (fixed)
    //      * capacity and default access policy.
    //      *
    //      * @param capacity the capacity of this queue
    //      * @throws IllegalArgumentException if {@code capacity < 1}
    //      */
    //     constructor(
    //         [in] Int32 capacity);

    //     /**
    //      * Creates an {@code ArrayBlockingQueue} with the given (fixed)
    //      * capacity and the specified access policy.
    //      *
    //      * @param capacity the capacity of this queue
    //      * @param fair if {@code true} then queue accesses for threads blocked
    //      *        on insertion or removal, are processed in FIFO order;
    //      *        if {@code false} the access order is unspecified.
    //      * @throws IllegalArgumentException if {@code capacity < 1}
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Boolean fair);

    //     /**
    //      * Creates an {@code ArrayBlockingQueue} with the given (fixed)
    //      * capacity, the specified access policy and initially containing the
    //      * elements of the given collection,
    //      * added in traversal order of the collection's iterator.
    //      *
    //      * @param capacity the capacity of this queue
    //      * @param fair if {@code true} then queue accesses for threads blocked
    //      *        on insertion or removal, are processed in FIFO order;
    //      *        if {@code false} the access order is unspecified.
    //      * @param c the collection of elements to initially contain
    //      * @throws IllegalArgumentException if {@code capacity} is less than
    //      *         {@code c.size()}, or less than 1.
    //      * @throws NullPointerException if the specified collection or any
    //      *         of its elements are null
    //      */
    //     constructor(
    //         [in] Int32 capacity,
    //         [in] Boolean fair,
    //         [in] ICollection* c);

    //     interface IBlockingQueue;
    //     interface IQueue;
    //     interface ICollection;
    //     interface IIterable;
    //     interface ISerializable;
    // }

    class CConcurrentLinkedDeque {
        constructor();

        constructor(
            [in] ICollection* c);

        interface IDeque;
        interface IQueue;
        interface ICollection;
        interface IIterable;
        interface ISerializable;
    }

    class CConcurrentLinkedQueue {
        constructor();

        constructor(
            [in] ICollection* c);

        interface IQueue;
        interface ICollection;
        interface IIterable;
        interface ISerializable;
    }

    // class CConcurrentSkipListMap {
    //     constructor();

    //     constructor(
    //         [in] IComparator* comparator);

    //     constructor(
    //         [in] IMap* map);

    //     constructor(
    //         [in] ISortedMap* sortedMap);

    //     interface INavigableMap;
    //     interface ISortedMap;
    //     interface IMap;
    //     interface IConcurrentMap;
    //     interface ISerializable;
    //     interface ICloneable;
    // }

    // class CConcurrentSkipListSet {
    //     constructor();

    //     constructor(
    //         [in] IComparator* comparator);

    //     constructor(
    //         [in] ICollection* c);

    //     constructor(
    //         [in] ISortedSet* s);

    //     constructor(
    //         [in] INavigableMap* m);

    //     interface INavigableSet;
    //     interface ISortedSet;
    //     interface ISet;
    //     interface ICollection;
    //     interface IIterable;
    //     interface ISerializable;
    //     interface ICloneable;
    // }

    class CDelayQueue {
        constructor();

        constructor(
            [in] ICollection* c);

        interface IBlockingQueue;
        interface IQueue;
        interface ICollection;
        interface IIterable;
    }

    // class CExchanger {
    //     constructor();

    //     interface IExchanger;
    // }

    // class CForkJoinWorkerThread {
    //     constructor(
    //         [in] IForkJoinPool* pool);

    //     interface IForkJoinWorkerThread;
    //     interface IThread;
    //     interface ISynchronize;
    // }

    // class CForkJoinPool {
    //     constructor();

    //     constructor(
    //         [in] Int32 parallelism);

    //     constructor(
    //         [in] Int32 parallelism,
    //         [in] IForkJoinPoolForkJoinWorkerThreadFactory* factory,
    //         [in] IThreadUncaughtExceptionHandler* handler,
    //         [in] Boolean asyncMode);

    //     interface IForkJoinPool;
    //     interface IAbstractExecutorService;
    //     interface IExecutorService;
    //     interface IExecutor;
    // }

    // singleton class CForkJoinTaskHelper {
    //     interface IForkJoinTaskHelper;
    // }

    class CLinkedBlockingDeque {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] ICollection* c);

        interface IBlockingDeque;
        interface IBlockingQueue;
        interface IQueue;
        interface ICollection;
        interface IIterable;
        interface ISerializable;
    }

    // class CLinkedTransferQueue {
    //     constructor();

    //     constructor(
    //         [in] ICollection* c);

    //     interface ITransferQueue;
    //     interface IBlockingQueue;
    //     interface IQueue;
    //     interface ICollection;
    //     interface IIterable;
    //     interface ISerializable;
    // }

    // class CPhaser {
    //     constructor();

    //     constructor(
    //         [in] Int32 parties);

    //     constructor(
    //         [in] IPhaser* parent);

    //     constructor(
    //         [in] IPhaser* parent,
    //         [in] Int32 parties);

    //     interface IPhaser;
    // }

    [deprecated]
    class CCopyOnWriteArrayList {
        /**
         * Creates an empty instance.
         */
        constructor();

        /**
         * Creates a new instance containing the elements of {@code collection}.
         */
        constructor(
            [in] ICollection* collection);

        /**
         * Creates a new instance containing the elements of {@code array}.
         */
        constructor(
            [in] ArrayOf<IInterface*>* array);

        interface ICopyOnWriteArrayList;
        interface ICollection;
        interface IIterable;
        interface IRandomAccess;
        interface ICloneable;
        interface ISerializable;
    }

    singleton class CCopyOnWriteArrayListHelper {
        interface ICopyOnWriteArrayListHelper;
    }

    class CCopyOnWriteArraySet {
        /**
         * Creates an empty set.
         */
        constructor();

        /**
         * Creates a set containing all of the elements of the specified
         * collection.
         *
         * @param c the collection of elements to initially contain
         * @throws NullPointerException if the specified collection is null
         */
        constructor(
            [in] ICollection* c);

        interface ISet;
        interface ISerializable;
    }

    // class CConcurrentHashMap {
    //     /**
    //      * Creates a new, empty map with the specified initial
    //      * capacity, load factor and concurrency level.
    //      *
    //      * @param initialCapacity the initial capacity. The implementation
    //      * performs internal sizing to accommodate this many elements.
    //      * @param loadFactor  the load factor threshold, used to control resizing.
    //      * Resizing may be performed when the average number of elements per
    //      * bin exceeds this threshold.
    //      * @param concurrencyLevel the estimated number of concurrently
    //      * updating threads. The implementation performs internal sizing
    //      * to try to accommodate this many threads.
    //      * @throws IllegalArgumentException if the initial capacity is
    //      * negative or the load factor or concurrencyLevel are
    //      * nonpositive.
    //      */
    //     // @SuppressWarnings("unchecked")
    //     constructor(
    //         [in] Int32 initialCapacity,
    //         [in] Float loadFactor,
    //         [in] Int32 concurrencyLevel);

    //     /**
    //      * Creates a new, empty map with the specified initial capacity
    //      * and load factor and with the default concurrencyLevel (16).
    //      *
    //      * @param initialCapacity The implementation performs internal
    //      * sizing to accommodate this many elements.
    //      * @param loadFactor  the load factor threshold, used to control resizing.
    //      * Resizing may be performed when the average number of elements per
    //      * bin exceeds this threshold.
    //      * @throws IllegalArgumentException if the initial capacity of
    //      * elements is negative or the load factor is nonpositive
    //      *
    //      * @since 1.6
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity,
    //         [in] Float loadFactor);

    //     /**
    //      * Creates a new, empty map with the specified initial capacity,
    //      * and with default load factor (0.75) and concurrencyLevel (16).
    //      *
    //      * @param initialCapacity the initial capacity. The implementation
    //      * performs internal sizing to accommodate this many elements.
    //      * @throws IllegalArgumentException if the initial capacity of
    //      * elements is negative.
    //      */
    //     constructor(
    //         [in] Int32 initialCapacity);

    //     /**
    //      * Creates a new, empty map with a default initial capacity (16),
    //      * load factor (0.75) and concurrencyLevel (16).
    //      */
    //     constructor();

    //     /**
    //      * Creates a new map with the same mappings as the given map.
    //      * The map is created with a capacity of 1.5 times the number
    //      * of mappings in the given map or 16 (whichever is greater),
    //      * and a default load factor (0.75) and concurrencyLevel (16).
    //      *
    //      * @param m the map
    //      */
    //     constructor(
    //         [in] IMap* m);

    //     interface IConcurrentHashMap;
    //     interface IConcurrentMap;
    //     interface IMap;
    //     interface ISerializable;
    // }

    // namespace Atomic {

    // class CAtomicBoolean {
    //     /**
    //      * Creates a new AtomicInteger with the given initial value.
    //      *
    //      * @param initialValue the initial value
    //      */
    //     constructor(
    //         [in] Boolean initialValue);

    //     /**
    //      * Creates a new AtomicInteger with initial value {@code FALSE}.
    //      */
    //     constructor();

    //     interface IAtomicBoolean;
    //     interface ISerializable;
    // }

    // class CAtomicInteger32 {
    //     /**
    //      * Creates a new AtomicInteger with the given initial value.
    //      *
    //      * @param initialValue the initial value
    //      */
    //     constructor(
    //         [in] Int32 initialValue);

    //     /**
    //      * Creates a new AtomicInteger with initial value {@code 0}.
    //      */
    //     constructor();

    //     interface IAtomicInteger32;
    //     interface ISerializable;
    // }

    // class CAtomicInteger32Array {
    //     /**
    //      * Creates a new AtomicInteger with the given initial value.
    //      *
    //      * @param initialValue the initial value
    //      */
    //     constructor(
    //         [in] Int32 length);

    //     /**
    //      * Creates a new AtomicInteger with initial value {@code 0}.
    //      */
    //     constructor(
    //         [in] ArrayOf<Int32> other);

    //     interface IAtomicInteger32Array;
    //     interface ISerializable;
    // }

    // class CAtomicInteger64 {
    //     /**
    //      * Creates a new AtomicInteger with the given initial value.
    //      *
    //      * @param initialValue the initial value
    //      */
    //     constructor(
    //         [in] Int64 initialValue);

    //     /**
    //      * Creates a new AtomicInteger with initial value {@code 0}.
    //      */
    //     constructor();

    //     interface IAtomicInteger64;
    //     interface ISerializable;
    // }

    // class CAtomicInteger64Array {
    //     constructor(
    //         [in] Int32 length);

    //     constructor(
    //         [in] ArrayOf<Int64> other);

    //     interface IAtomicInteger64Array;
    //     interface ISerializable;
    // }

    // class CAtomicMarkableReference {
    //     constructor(
    //         [in] IInterface* initialRef,
    //         [in] Boolean initialMark);

    //     interface IAtomicMarkableReference;
    // }

    // class CAtomicReference {
    //     constructor(
    //         [in] IInterface* initialValue);

    //     constructor();

    //     interface IAtomicReference;
    //     interface ISerializable;
    // }

    // class CAtomicReferenceArray {
    //     constructor(
    //         [in] Int32 length);

    //     constructor(
    //         [in] ArrayOf<IInterface*> array);

    //     interface IAtomicReferenceArray;
    //     interface ISerializable;
    // }

    // class CAtomicStampedReference {
    //     constructor(
    //         [in] IInterface* initialRef,
    //         [in] Int32 initialStamp);

    //     interface IAtomicStampedReference;
    // }

    // singleton class CFencesHelper {
    //     interface IFencesHelper;
    // }

    // } // namespace Atomic

    // namespace Locks {

    // singleton class CLockSupport {
    //     interface ILockSupport;
    // }

    // class CReentrantLock {
    //     constructor();

    //     constructor(
    //         [in] Boolean fair);

    //     interface IReentrantLock;
    //     interface ILock;
    //     interface ISerializable;
    // }

    // class CReentrantReadWriteLock {
    //     constructor();

    //     constructor(
    //         [in] Boolean fair);

    //     interface IReentrantReadWriteLock;
    //     interface IReadWriteLock;
    //     interface ISerializable;
    // }

    // } // namespace Locks

    // class CSemaphore {
    //     constructor(
    //         [in] Int32 permits);

    //     constructor(
    //         [in] Int32 permits,
    //         [in] Boolean fair);

    //     interface ISemaphore;
    //     interface ISerializable;
    // }

    } // namespace Concurrent
    } // namespace Utility
    } // namespace Elastos


    // interface Elastos.Core.ICloneable;
    // interface Elastos.Utility.IMap;
    // interface Elastos.Utility.Zip.IZipEntry;
    // interface Elastos.IO.IFile;
    // interface Elastos.IO.IFlushable;
    // interface Elastos.IO.IOutputStream;
    // interface Elastos.IO.IInputStream;

    // namespace Elastos {
    // namespace Utility {
    // namespace Jar {

    //     class CName {
    //         constructor(
    //             [in] String name);

    //         constructor(
    //             [in] String name,
    //             [in] Boolean validateName);

    //         interface IName;
    //     }
    //     [deprecated]
    //     class CAttributes {
    //         constructor();

    //         constructor(
    //             [in] IAttributes* attributes);

    //         constructor(
    //             [in] Int32 size);

    //         interface IAttributes;
    //         interface ICloneable;
    //         interface IMap;
    //     }

    //     class CJarEntry {
    //         constructor(
    //             [in] String name);

    //         constructor(
    //             [in] IZipEntry* zipEntry);

    //         constructor(
    //             [in] IJarEntry* jarEntry);

    //         interface IJarEntry;
    //         interface IZipEntry;
    //     }

    //     [deprecated]
    //     class CJarFile {
    //         constructor(
    //             [in] IFile* file);

    //         constructor(
    //             [in] IFile* file,
    //             [in] Boolean verify);

    //         constructor(
    //             [in] IFile* file,
    //             [in] Boolean verify,
    //             [in] Int32 mode);

    //         constructor(
    //             [in] String filename);

    //         constructor(
    //             [in] String filename,
    //             [in] Boolean verify);

    //         interface IJarFile;
    //         interface IZipFile;
    //         interface IZipConstants;
    //     }

    //     [deprecated]
    //     class CJarInputStream {
    //         constructor(
    //             [in] IInputStream* stream,
    //             [in] Boolean verify);

    //         constructor(
    //             [in] IInputStream* stream);

    //         interface IJarInputStream;
    //         interface IZipInputStream;
    //         interface IInflaterInputStream;
    //         interface IFilterInputStream;
    //         interface IInputStream;
    //         interface ICloseable;
    //     }

    //     class CJarOutputStream {
    //         constructor(
    //             [in] IOutputStream* os,
    //             [in] IManifest* manifest);

    //         constructor(
    //             [in] IOutputStream* os);

    //         interface IJarOutputStream;
    //         interface IZipOutputStream;
    //         interface IDeflaterOutputStream;
    //         interface IFilterOutputStream;
    //         interface IOutputStream;
    //         interface ICloseable;
    //         interface IFlushable;
    //     }

    //     class CManifest {
    //         constructor();

    //         constructor(
    //             [in] IInputStream* is);

    //         constructor(
    //             [in] IManifest* mani);

    //         interface IManifest;
    //         interface ICloneable;
    //     }

    //     singleton class CPack200Helper {
    //         interface IPack200Helper;
    //     }

    // } // namespace Jar
    // } // namespace Utility
    // } // namespace Elastos


    namespace Elastos {
    namespace Utility {
    namespace Regex {

    /**
     * The result of applying a {@code Pattern} to a given input. See {@link Pattern} for
     * example uses.
     */
    class CMatcher {
        /**
         * Creates a matcher for a given combination of pattern and input. Both
         * elements can be changed later on.
         *
         * @param pattern
         *            the pattern to use.
         * @param input
         *            the input to use.
         */
        constructor(
            [in] IPattern* pattern,
            [in] Elastos.Core.ICharSequence* inputSeq);

        interface IMatcher;
        interface IMatchResult;
    }

    singleton class CMatcherHelper {
        interface IMatcherHelper;
    }

    singleton class CSplitter {
        interface ISplitter;
    }

    singleton class CPatternHelper {
        interface IPatternHelper;
    }

    } // namespace Regex
    } // namesapce Utility
    } // namespace Elastos


    // interface Elastos.IO.IOutputStream;
    // interface Elastos.IO.IFile;
    interface Elastos.IO.IFlushable;

    namespace Elastos {
    namespace Utility {
    namespace Zip {

    /**
     * The Adler-32 class is used to compute the {@code Adler32} checksum from a set
     * of data. Compared to {@link CRC32} it trades reliability for speed.
     * Refer to RFC 1950 for the specification.
     */
    class CAdler32 {
        interface IAdler32;
        interface IChecksum;
    }

    /**
     * The CRC32 class is used to compute a CRC32 checksum from data provided as
     * input value.
     */
    class CCRC32 {
        interface ICRC32;
        interface IChecksum;
    }

    /**
     * This class decompresses data that was compressed using the <i>DEFLATE</i>
     * algorithm (see <a href="http://www.gzip.org/algorithm.txt">specification</a>).
     *
     * <p>It is usually more convenient to use {@link InflaterInputStream}.
     *
     * <p>To decompress an in-memory {@code byte[]} to another in-memory {@code byte[]} manually:
     * <pre>
     *     byte[] compressedBytes = ...
     *     int decompressedByteCount = ... // From your format's metadata.
     *     Inflater inflater = new Inflater();
     *     inflater.setInput(compressedBytes, 0, compressedBytes.length);
     *     byte[] decompressedBytes = new byte[decompressedByteCount];
     *     if (inflater.inflate(decompressedBytes) != decompressedByteCount) {
     *         throw new AssertionError();
     *     }
     *     inflater.end();
     * </pre>
     * <p>In situations where you don't have all the input in one array (or have so much
     * input that you want to feed it to the inflater in chunks), it's possible to call
     * {@link #setInput} repeatedly, but you're much better off using {@link InflaterInputStream}
     * to handle all this for you.
     *
     * <p>If you don't know how big the decompressed data will be, you can call {@link #inflate}
     * repeatedly on a temporary buffer, copying the bytes to a {@link java.io.ByteArrayOutputStream},
     * but this is probably another sign you'd be better off using {@link InflaterInputStream}.
     */
    class CInflater {
        /**
         * This constructor creates an inflater that expects a header from the input
         * stream. Use {@code Inflater(boolean)} if the input comes without a ZLIB
         * header.
         */
        constructor();

        /**
         * This constructor allows to create an inflater that expects no header from
         * the input stream.
         *
         * @param noHeader
         *            {@code true} indicates that no ZLIB header comes with the
         *            input.
         */
        constructor(
            [in] Boolean noHeader);

        interface IInflater;
    }

    /**
     * This class compresses data using the <i>DEFLATE</i> algorithm (see <a
     * href="http://www.gzip.org/algorithm.txt">specification</a>).
     *
     * <p>It is usually more convenient to use {@link DeflaterOutputStream}.
     *
     * <p>To compress an in-memory {@code byte[]} to another in-memory {@code byte[]} manually:
     * <pre>
     *     byte[] originalBytes = ...
     *
     *     Deflater deflater = new Deflater();
     *     deflater.setInput(originalBytes);
     *     deflater.finish();
     *
     *     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     *     byte[] buf = new byte[8192];
     *     while (!deflater.finished()) {
     *         int byteCount = deflater.deflate(buf);
     *         baos.write(buf, 0, byteCount);
     *     }
     *     deflater.end();
     *
     *     byte[] compressedBytes = baos.toByteArray();
     * </pre>
     * <p>In situations where you don't have all the input in one array (or have so much
     * input that you want to feed it to the deflater in chunks), it's possible to call
     * {@link #setInput setInput} repeatedly, but you're much better off using
     * {@link DeflaterOutputStream} to handle all this for you. {@link DeflaterOutputStream} also helps
     * minimize memory requirements&nbsp;&mdash; the sample code above is very expensive.
     */
    class CDeflater {
        /**
         * Constructs a new {@code Deflater} instance using the default compression
         * level. The strategy can be specified with {@link #setStrategy}. A
         * header is added to the output by default; use {@link
         * #Deflater(int, boolean)} if you need to omit the header.
         */
        constructor();

        /**
         * Constructs a new {@code Deflater} instance using compression
         * level {@code level}. The strategy can be specified with {@link #setStrategy}.
         * A header is added to the output by default; use
         * {@link #Deflater(int, boolean)} if you need to omit the header.
         *
         * @param level
         *            the compression level in the range between 0 and 9.
         */
        constructor(
            [in] Int32 level);

        /**
         * Constructs a new {@code Deflater} instance with a specific compression
         * level. If {@code noHeader} is true, no ZLIB header is added to the
         * output. In a ZIP archive every entry (compressed file) comes with such a
         * header. The strategy can be specified using {@link #setStrategy}.
         *
         * @param level
         *            the compression level in the range between 0 and 9.
         * @param noHeader
         *            {@code true} indicates that no ZLIB header should be written.
         */
        constructor(
            [in] Int32 level,
            [in] Boolean noHeader);

        interface IDeflater;
    }

    /**
     * This class provides an implementation of {@code FilterInputStream} that
     * decompresses data that was compressed using the <i>DEFLATE</i> algorithm
     * (see <a href="http://www.gzip.org/algorithm.txt">specification</a>).
     * Basically it wraps the {@code Inflater} class and takes care of the
     * buffering.
     *
     * @see Inflater
     * @see DeflaterOutputStream
     */
    class CInflaterInputStream {
        /**
         * This is the most basic constructor. You only need to pass the {@code
         * InputStream} from which the compressed data is to be read from. Default
         * settings for the {@code Inflater} and internal buffer are be used. In
         * particular the Inflater expects a ZLIB header from the input stream.
         *
         * @param is
         *            the {@code InputStream} to read data from.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * This constructor lets you pass a specifically initialized Inflater,
         * for example one that expects no ZLIB header.
         *
         * @param is
         *            the {@code InputStream} to read data from.
         * @param inflater
         *            the specific {@code Inflater} for uncompressing data.
         */
        constructor(
            [in] IInputStream* is,
            [in] IInflater* inflater);

        /**
         * This constructor lets you specify both the {@code Inflater} as well as
         * the internal buffer size to be used.
         *
         * @param is
         *            the {@code InputStream} to read data from.
         * @param inflater
         *            the specific {@code Inflater} for uncompressing data.
         * @param bsize
         *            the size to be used for the internal buffer.
         */
        constructor(
            [in] IInputStream* is,
            [in] IInflater* inflater,
            [in] Int32 bsize);

        interface IInflaterInputStream;
        interface IFilterInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    /**
     * An {@code OutputStream} filter to decompress data. Callers write
     * compressed data in the "deflate" format, and uncompressed data is
     * written to the underlying stream.
     * @since 1.6
     */
    class CInflaterOutputStream {
        /**
         * Constructs an {@code InflaterOutputStream} with a new {@code Inflater} and an
         * implementation-defined default internal buffer size. {@code out} is a destination
         * for uncompressed data, and compressed data will be written to this stream.
         *
         * @param out the destination {@code OutputStream}
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs an {@code InflaterOutputStream} with the given {@code Inflater} and an
         * implementation-defined default internal buffer size. {@code out} is a destination
         * for uncompressed data, and compressed data will be written to this stream.
         *
         * @param out the destination {@code OutputStream}
         * @param inf the {@code Inflater} to be used for decompression

        constructor(
            [in] IOutputStream* os,
            [in] IInflater* inf);

        /**
         * Constructs an {@code InflaterOutputStream} with the given {@code Inflater} and
         * given internal buffer size. {@code out} is a destination
         * for uncompressed data, and compressed data will be written to this stream.
         *
         * @param out the destination {@code OutputStream}
         * @param inf the {@code Inflater} to be used for decompression
         * @param bufferSize the length in bytes of the internal buffer
         */
        constructor(
            [in] IOutputStream* os,
            [in] IInflater* inf,
            [in] Int32 bufferSize);

        interface IInflaterOutputStream;
        interface IFilterOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    /**
     * An {@code InputStream} filter to compress data. Callers read
     * compressed data in the "deflate" format from the uncompressed
     * underlying stream.
     * @since 1.6
     */
    class CDeflaterInputStream {
        /**
         * Constructs a {@code DeflaterInputStream} with a new {@code Deflater} and an
         * implementation-defined default internal buffer size. {@code in} is a source of
         * uncompressed data, and this stream will be a source of compressed data.
         *
         * @param in the source {@code InputStream}
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Constructs a {@code DeflaterInputStream} with the given {@code Deflater} and an
         * implementation-defined default internal buffer size. {@code in} is a source of
         * uncompressed data, and this stream will be a source of compressed data.
         *
         * @param in the source {@code InputStream}
         * @param deflater the {@code Deflater} to be used for compression
         */
        constructor(
            [in] IInputStream* is,
            [in] IDeflater* deflater);

        /**
         * Constructs a {@code DeflaterInputStream} with the given {@code Deflater} and
         * given internal buffer size. {@code in} is a source of
         * uncompressed data, and this stream will be a source of compressed data.
         *
         * @param in the source {@code InputStream}
         * @param deflater the {@code Deflater} to be used for compression
         * @param bufferSize the length in bytes of the internal buffer
         */
        constructor(
            [in] IInputStream* is,
            [in] IDeflater* deflater,
            [in] Int32 bufferSize);

        interface IDeflaterInputStream;
        interface IFilterInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    /**
     * This class provides an implementation of {@code FilterOutputStream} that
     * compresses data using the <i>DEFLATE</i> algorithm. Basically it wraps the
     * {@code Deflater} class and takes care of the buffering.
     *
     * @see Deflater
     */
    class CDeflaterOutputStream {
        /**
         * This is the most basic constructor. You only need to pass the {@code
         * OutputStream} to which the compressed data shall be written to. The
         * default settings for the {@code Deflater} and internal buffer are used.
         * In particular the {@code Deflater} produces a ZLIB header in the output
         * stream.
         *
         * @param os
         *            is the OutputStream where to write the compressed data to.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * This constructor lets you pass the {@code Deflater} specifying the
         * compression algorithm.
         *
         * @param os
         *            is the {@code OutputStream} where to write the compressed data
         *            to.
         * @param def
         *            is the specific {@code Deflater} that is used to compress
         *            data.
         */
        constructor(
            [in] IOutputStream* os,
            [in] IDeflater* def);

        /**
         * This constructor lets you specify both the compression algorithm as well
         * as the internal buffer size to be used.
         *
         * @param os
         *            is the {@code OutputStream} where to write the compressed data
         *            to.
         * @param def
         *            is the specific {@code Deflater} that will be used to compress
         *            data.
         * @param bsize
         *            is the size to be used for the internal buffer.
         */
        constructor(
            [in] IOutputStream* os,
            [in] IDeflater* def,
            [in] Int32 bsize);

        interface IDeflaterOutputStream;
        interface IFilterOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    /**
     * The {@code CheckedInputStream} class is used to maintain a checksum at the
     * same time as the data, on which the checksum is computed, is read from a
     * stream. The purpose of this checksum is to establish data integrity,
     * comparing the computed checksum against a published checksum value.
     */
    class CCheckedInputStream {
        /**
         * Constructs a new {@code CheckedInputStream} on {@code InputStream}
         * {@code is}. The checksum will be calculated using the algorithm
         * implemented by {@code csum}.
         *
         * <p><strong>Warning:</strong> passing a null source creates an invalid
         * {@code CheckedInputStream}. All operations on such a stream will fail.
         *
         * @param is
         *            the input stream to calculate checksum from.
         * @param csum
         *            an entity implementing the checksum algorithm.
         */
        constructor(
            [in] IInputStream* is,
            [in] IChecksum* csum);

        interface ICheckedInputStream;
        interface IFilterInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    /**
     * The {@code CheckedOutputStream} class is used to maintain a running checksum
     * of all data written to a stream. The purpose of this checksum is to establish
     * data integrity, by publishing the checksum to other parties wanting to read
     * the non corrupted data.
     */
    class CCheckedOutputStream {
        /**
         * Constructs a new {@code CheckedOutputStream} on {@code OutputStream}
         * {@code os}. The checksum is calculated using the algorithm implemented
         * by {@code csum}.
         *
         * @param os
         *            the output stream to calculate checksum for.
         * @param cs
         *            an entity implementing the checksum algorithm.
         */
        constructor(
            [in] IOutputStream* os,
            [in] IChecksum* cs);

        interface ICheckedOutputStream;
        interface IFilterOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    /**
     * The {@code GZIPInputStream} class is used to read data stored in the GZIP
     * format, reading and decompressing GZIP data from the underlying stream into
     * its buffer.
     *
     * <h3>Example</h3>
     * <p>Using {@code GZIPInputStream} is easier than {@link ZipInputStream}
     * because GZIP is only for compression, and is not a container for multiple files.
     * This code decompresses the data from a GZIP stream, similar to the {@code gunzip(1)} utility.
     * <pre>
     * InputStream is = ...
     * GZIPInputStream zis = new GZIPInputStream(new BufferedInputStream(is));
     * try {
     *     Reading from 'zis' gets you the uncompressed bytes...
     *     processStream(zis);
     * } finally {
     *     zis.close();
     * }
     * </pre>
     */
    class CGZIPInputStream {
        /**
         * Construct a {@code GZIPInputStream} to read from GZIP data from the
         * underlying stream.
         *
         * @param is
         *            the {@code InputStream} to read data from.
         * @throws IOException
         *             if an {@code IOException} occurs.
         */
        constructor(
            [in] IInputStream* is);

        /**
         * Construct a {@code GZIPInputStream} to read from GZIP data from the
         * underlying stream. Set the internal buffer size to {@code size}.
         *
         * @param is
         *            the {@code InputStream} to read data from.
         * @param size
         *            the internal read buffer size.
         * @throws IOException
         *             if an {@code IOException} occurs.
         */
        constructor(
            [in] IInputStream* is,
            [in] Int32 size);

        interface IGZIPInputStream;
        interface IInflaterInputStream;
        interface IFilterInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    /**
     * The {@code GZIPOutputStream} class is used to write data to a stream in the
     * GZIP storage format.
     *
     * <h3>Example</h3>
     * <p>Using {@code GZIPOutputStream} is a little easier than {@link ZipOutputStream}
     * because GZIP is only for compression, and is not a container for multiple files.
     * This code creates a GZIP stream, similar to the {@code gzip(1)} utility.
     * <pre>
     * OutputStream os = ...
     * byte[] bytes = ...
     * GZIPOutputStream zos = new GZIPOutputStream(new BufferedOutputStream(os));
     * try {
     *     zos.write(bytes);
     * } finally {
     *     zos.close();
     * }
     * </pre>
     */
    class CGZIPOutputStream {
        /**
         * Constructs a new {@code GZIPOutputStream} to write data in GZIP format to
         * the given stream.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a new {@code GZIPOutputStream} to write data in GZIP format to
         * the given stream with the given flushing behavior (see {@link DeflaterOutputStream#flush}).
         * @since 1.7
         */
        constructor(
            [in] IOutputStream* os,
            [in] Boolean syncFlush);

        /**
         * Constructs a new {@code GZIPOutputStream} to write data in GZIP format to
         * the given stream with the given internal buffer size.
         */
        constructor(
            [in] IOutputStream* os,
            [in] Int32 size);

        /**
         * Constructs a new {@code GZIPOutputStream} to write data in GZIP format to
         * the given stream with the given internal buffer size and
         * flushing behavior (see {@link DeflaterOutputStream#flush}).
         * @since 1.7
         */
        constructor(
            [in] IOutputStream* os,
            [in] Boolean syncFlush,
            [in] Int32 size);

        interface IGZIPOutputStream;
        interface IDeflaterOutputStream;
        interface IFilterOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    /**
     * This class provides an implementation of {@code FilterInputStream} that
     * decompresses data from an {@code InputStream} containing a ZIP archive.
     *
     * <p>A ZIP archive is a collection of (possibly) compressed files.
     * When reading from a {@code ZipInputStream}, you retrieve the
     * entry's metadata with {@code getNextEntry} before you can read the userdata.
     *
     * <p>Although {@code InflaterInputStream} can only read compressed ZIP archive
     * entries, this class can read non-compressed entries as well.
     *
     * <p>Use {@code ZipFile} if you can access the archive as a file directly,
     * especially if you want random access to entries, rather than needing to
     * iterate over all entries.
     *
     * <h3>Example</h3>
     * <p>Using {@code ZipInputStream} is a little more complicated than {@link GZIPInputStream}
     * because ZIP archives are containers that can contain multiple files. This code pulls all the
     * files out of a ZIP archive, similar to the {@code unzip(1)} utility.
     * <pre>
     * InputStream is = ...
     * ZipInputStream zis = new ZipInputStream(new BufferedInputStream(is));
     * try {
     *     ZipEntry ze;
     *     while ((ze = zis.getNextEntry()) != null) {
     *         ByteArrayOutputStream baos = new ByteArrayOutputStream();
     *         byte[] buffer = new byte[1024];
     *         int count;
     *         while ((count = zis.read(buffer)) != -1) {
     *             baos.write(buffer, 0, count);
     *         }
     *         String filename = ze.getName();
     *         byte[] bytes = baos.toByteArray();
     *         do something with 'filename' and 'bytes'...
     *     }
     * } finally {
     *     zis.close();
     * }
     * </pre>
     *
     * @see ZipEntry
     * @see ZipFile
     */
    class CZipInputStream {
        /**
         * Constructs a new {@code ZipInputStream} from the specified input stream.
         *
         * @param stream
         *            the input stream to representing a ZIP archive.
         */
        constructor(
            [in] IInputStream* stream);

        interface IZipInputStream;
        interface IInflaterInputStream;
        interface IFilterInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    /**
     * This class provides an implementation of {@code FilterOutputStream} that
     * compresses data entries into a <i>ZIP-archive</i> output stream.
     * <p>
     * {@code ZipOutputStream} is used to write {@code ZipEntries} to the underlying
     * stream. Output from {@code ZipOutputStream} conforms to the {@code ZipFile}
     * file format.
     * <p>
     * While {@code DeflaterOutputStream} can write a compressed <i>ZIP-archive</i>
     * entry, this extension can write uncompressed entries as well. In this case
     * special rules apply, for this purpose refer to the <a
     * href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">file format
     * specification</a>.
     *
     * <h3>Example</h3>
     * <p>Using {@code ZipOutputStream} is a little more complicated than {@link GZIPOutputStream}
     * because ZIP archives are containers that can contain multiple files. This code creates a ZIP
     * archive containing several files, similar to the {@code zip(1)} utility.
     * <pre>
     * OutputStream os = ...
     * ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(os));
     * try {
     *     for (int i = 0; i < fileCount; ++i) {
     *         String filename = ...
     *         byte[] bytes = ...
     *         ZipEntry entry = new ZipEntry(filename);
     *         zos.putNextEntry(entry);
     *         zos.write(bytes);
     *         zos.closeEntry();
     *     }
     * } finally {
     *     zos.close();
     * }
     * </pre>
     *
     * @see ZipEntry
     * @see ZipFile
     */
    class CZipOutputStream {
        /**
         * Constructs a new {@code ZipOutputStream} with the specified output
         * stream.
         *
         * @param os
         *            the {@code OutputStream} to write the data to.
         */
        constructor(
            [in] IOutputStream* os);

        interface IZipOutputStream;
        interface IDeflaterOutputStream;
        interface IFilterOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    /**
     * An instance of {@code ZipEntry} represents an entry within a <i>ZIP-archive</i>.
     * An entry has attributes such as name (= path) or the size of its data. While
     * an entry identifies data stored in an archive, it does not hold the data
     * itself. For example when reading a <i>ZIP-file</i> you will first retrieve
     * all its entries in a collection and then read the data for a specific entry
     * through an input stream.
     *
     * @see ZipFile
     * @see ZipOutputStream
     */
    [deprecated]
    class CZipEntry {
        /**
         * Constructs a new {@code ZipEntry} with the specified name.
         *
         * @param name
         *            the name of the ZIP entry.
         * @throws IllegalArgumentException
         *             if the name length is outside the range (> 0xFFFF).
         */
        constructor(
            [in] String name);

        /**
         * Constructs a new {@code ZipEntry} using the values obtained from {@code
         * ze}.
         *
         * @param ze
         *            the {@code ZipEntry} from which to obtain values.
         */
        constructor(
            [in] IZipEntry* ze);

        /*
         * Internal constructor.  Creates a new ZipEntry by reading the
         * Central Directory Entry from "in", which must be positioned at
         * the CDE signature.
         *
         * On exit, "in" will be positioned at the start of the next entry.
         */
        constructor(
            [in] ArrayOf<Byte>* hdrBuf,
            [in] IInputStream* is,
            [in] ICharset* defaultCharset);

        interface IZipEntry;
        interface ICloneable;
    }

    /**
     * This class provides random read access to a <i>ZIP-archive</i> file.
     * <p>
     * While {@code ZipInputStream} provides stream based read access to a
     * <i>ZIP-archive</i>, this class implements more efficient (file based) access
     * and makes use of the <i>central directory</i> within a <i>ZIP-archive</i>.
     * <p>
     * Use {@code ZipOutputStream} if you want to create an archive.
     * <p>
     * A temporary ZIP file can be marked for automatic deletion upon closing it.
     *
     * @see ZipEntry
     * @see ZipOutputStream
     */
    class CZipFile {
        /**
         * Constructs a new {@code ZipFile} with the specified file.
         *
         * @param file
         *            the file to read from.
         * @throws ZipException
         *             if a ZIP error occurs.
         * @throws IOException
         *             if an {@code IOException} occurs.
         */
        constructor(
            [in] IFile* file);

        /**
         * Opens a file as <i>ZIP-archive</i>. "mode" must be {@code OPEN_READ} or
         * {@code OPEN_DELETE} . The latter sets the "delete on exit" flag through a
         * file.
         *
         * @param file
         *            the ZIP file to read.
         * @param mode
         *            the mode of the file open operation.
         * @throws IOException
         *             if an {@code IOException} occurs.
         */
        constructor(
            [in] IFile* file,
            [in] Int32 mode);

        /**
         * Opens a ZIP archived file.
         *
         * @param name
         *            the name of the ZIP file.
         * @throws IOException
         *             if an IOException occurs.
         */
        constructor(
            [in] String name);

        interface IZipFile;
        interface IZipConstants;
    }

    } // namespace Zip
    } // namesapce Utility
    } // namespace Elastos


}