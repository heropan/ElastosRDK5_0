
module
{
    using interface Elastos.IO.IInputStream;
    using interface Elastos.IO.IOutputStream;
    using interface Elastos.Utility.IList;
    using interface Elastos.Utility.IArrayList;

    interface Elastos.Droid.Accounts.IAccount;
    interface Elastos.Droid.Content.IContentValues;
    interface Elastos.Droid.Content.IIContentProvider;
    interface Elastos.Droid.Content.IIContentService;
    interface Elastos.Droid.Content.ISyncAdapterType;
    interface Elastos.Droid.Content.ISyncInfo;
    interface Elastos.Droid.Content.ISyncStatusInfo;
    interface Elastos.Droid.Content.ISyncStatusObserver;
    interface Elastos.Droid.Content.ISyncRequest;
    interface Elastos.Droid.Content.Res.IAssetFileDescriptor;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Database.IContentObserver;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.ICancellationSignal;
    interface Elastos.Droid.Os.IParcelFileDescriptor;

    namespace Elastos {
    namespace Droid {
    namespace Content {

    /**
     * A resource identified by the Resources that contains it, and a resource id.
     *
     * @sa Resources
     * @hide
     */
    interface IContentResolverOpenResourceIdResult {
        GetResources(
            [out] IResources** resources);

        SetResources(
            [in] IResources* resources);

        GetResourceId(
            [out] Int32* id);

        SetResourceId(
            [in] Int32 id);
    }

    [deprecated]
    interface IContentResolver {
        /**
         * @deprecated instead use
         * #requestSync(android.accounts.Account, String, android.os.Bundle)
         */
        const String SYNC_EXTRAS_ACCOUNT = "account";

        const String SYNC_EXTRAS_EXPEDITED = "expedited";

        /**
         * @deprecated instead use
         * {@sa #SYNC_EXTRAS_MANUAL}
         */
        const String SYNC_EXTRAS_FORCE = "force";

        /**
         * If this extra is set to true then the sync settings (like getSyncAutomatically())
         * are ignored by the sync scheduler.
         */
        const String SYNC_EXTRAS_IGNORE_SETTINGS = "ignore_settings";

        /**
         * If this extra is set to true then any backoffs for the initial attempt (e.g. due to retries)
         * are ignored by the sync scheduler. If this request fails and gets rescheduled then the
         * retries will still honor the backoff.
         */
        const String SYNC_EXTRAS_IGNORE_BACKOFF = "ignore_backoff";

        /**
         * If this extra is set to true then the request will not be retried if it fails.
         */
        const String SYNC_EXTRAS_DO_NOT_RETRY = "do_not_retry";

        /**
         * Setting this extra is the equivalent of setting both {@sa #SYNC_EXTRAS_IGNORE_SETTINGS}
         * and {@sa #SYNC_EXTRAS_IGNORE_BACKOFF}
         */
        const String SYNC_EXTRAS_MANUAL = "force";

        const String SYNC_EXTRAS_UPLOAD = "upload";

        const String SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS = "deletions_override";

        const String SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS = "discard_deletions";

        /* Extensions to API. TODO: Not clear if we will keep these as public flags. */
        /** {@hide} User-specified flag for expected upload size. */
        const String SYNC_EXTRAS_EXPECTED_UPLOAD = "expected_upload";

        /** {@hide} User-specified flag for expected download size. */
        const String SYNC_EXTRAS_EXPECTED_DOWNLOAD = "expected_download";

        /** {@hide} Priority of this sync with respect to other syncs scheduled for this application. */
        const String SYNC_EXTRAS_PRIORITY = "sync_priority";

        /** {@hide} Flag to allow sync to occur on metered network. */
        const String SYNC_EXTRAS_DISALLOW_METERED = "allow_metered";

        /**
         * Set by the SyncManager to request that the SyncAdapter initialize itself for
         * the given account/authority pair. One required initialization step is to
         * ensure that {@sa #setIsSyncable(android.accounts.Account, String, int)} has been
         * called with a >= 0 value. When this flag is set the SyncAdapter does not need to
         * do a full sync, though it is allowed to do so.
         */
        const String SYNC_EXTRAS_INITIALIZE = "initialize";

        const String SCHEME_CONTENT = "content";

        const String SCHEME_ANDROID_RESOURCE = "android.resource";

        const String SCHEME_FILE = "file";

        /**
         * An extra {@link Point} describing the optimal size for a requested image
         * resource, in pixels. If a provider has multiple sizes of the image, it
         * should return the image closest to this size.
         *
         * @see #openTypedAssetFileDescriptor(Uri, String, Bundle)
         * @see #openTypedAssetFileDescriptor(Uri, String, Bundle,
         *      CancellationSignal)
         */
        const String EXTRA_SIZE = "android.content.extra.SIZE";

        /**
         * This is the Android platform's base MIME type for a content: URI
         * containing a Cursor of a single item.  Applications should use this
         * as the base type along with their own sub-type of their content: URIs
         * that represent a particular item.  For example, hypothetical IMAP email
         * client may have a URI
         * <code>content://com.company.provider.imap/inbox/1</code> for a particular
         * message in the inbox, whose MIME type would be reported as
         * <code>CURSOR_ITEM_BASE_TYPE + "/vnd.company.imap-msg"</code>
         *
         * <p>Compare with {@sa #CURSOR_DIR_BASE_TYPE}.
         */
        const String CURSOR_ITEM_BASE_TYPE = "vnd.android.cursor.item";

        /**
         * This is the Android platform's base MIME type for a content: URI
         * containing a Cursor of zero or more items.  Applications should use this
         * as the base type along with their own sub-type of their content: URIs
         * that represent a directory of items.  For example, hypothetical IMAP email
         * client may have a URI
         * <code>content://com.company.provider.imap/inbox</code> for all of the
         * messages in its inbox, whose MIME type would be reported as
         * <code>CURSOR_DIR_BASE_TYPE + "/vnd.company.imap-msg"</code>
         *
         * <p>Note how the base MIME type varies between this and
         * {@sa #CURSOR_ITEM_BASE_TYPE} depending on whether there is
         * one single item or multiple items in the data set, while the sub-type
         * remains the same because in either case the data structure contained
         * in the cursor is the same.
         */
        const String CURSOR_DIR_BASE_TYPE = "vnd.android.cursor.dir";

        /** @hide */
        const Int32 SYNC_ERROR_SYNC_ALREADY_IN_PROGRESS = 1;

        /** @hide */
        const Int32 SYNC_ERROR_AUTHENTICATION = 2;

        /** @hide */
        const Int32 SYNC_ERROR_IO = 3;

        /** @hide */
        const Int32 SYNC_ERROR_PARSE = 4;

        /** @hide */
        const Int32 SYNC_ERROR_CONFLICT = 5;

        /** @hide */
        const Int32 SYNC_ERROR_TOO_MANY_DELETIONS = 6;

        /** @hide */
        const Int32 SYNC_ERROR_TOO_MANY_RETRIES = 7;

        /** @hide */
        const Int32 SYNC_ERROR_INTERNAL = 8;

        const Int32 SYNC_OBSERVER_TYPE_SETTINGS = 0x1;  // 1<<0

        const Int32 SYNC_OBSERVER_TYPE_PENDING = 0x2;   // 1<<1

        const Int32 SYNC_OBSERVER_TYPE_ACTIVE = 0x4;    // 1<<2

        /** @hide */
        const Int32 SYNC_OBSERVER_TYPE_STATUS = 0x8;    // 1<<3

        /** @hide */
        const Int32 SYNC_OBSERVER_TYPE_ALL = 0x7fffffff;

        /** @hide */
        const String CONTENT_SERVICE_NAME = "content";

        /** @hide */
        ReleaseProvider(
            [in] IIContentProvider* icp,
            [out] Boolean* isRelease);

        /** @hide */
        ReleaseUnstableProvider(
            [in] IIContentProvider* icp,
            [out] Boolean* isRelease);

        /** @hide */
        UnstableProviderDied(
            [in] IIContentProvider* icp);

        /**
         * Return the MIME type of the given content URL.
         *
         * @param url A Uri identifying content (either a list or specific type),
         * using the content:// scheme.
         * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
         */
        GetType(
            [in] IUri* uri,
            [out] String* type);

        /**
         * Query for the possible MIME types for the representations the given
         * content URL can be returned when opened as as stream with
         * {@sa #openTypedAssetFileDescriptor}.  Note that the types here are
         * not necessarily a superset of the type returned by {@sa #getType} --
         * many content providers can not return a raw stream for the structured
         * data that they contain.
         *
         * @param url A Uri identifying content (either a list or specific type),
         * using the content:// scheme.
         * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
         * such as *\/*, to query for all available MIME types that match the
         * pattern.
         * @return Returns an array of MIME type strings for all available
         * data streams that match the given mimeTypeFilter.  If there are none,
         * null is returned.
         */
        GetStreamTypes(
            [in] IUri* uri,
            [in] String mimeTypeFilter,
            [out, callee] ArrayOf<String>* streamTypes);

        /**
         * <p>
         * Query the given URI, returning a {@sa Cursor} over the result set.
         * </p>
         * <p>
         * For best performance, the caller should follow these guidelines:
         * <ul>
         * <li>Provide an explicit projection, to prevent
         * reading data from storage that aren't going to be used.</li>
         * <li>Use question mark parameter markers such as 'phone=?' instead of
         * explicit values in the {@code selection} parameter, so that queries
         * that differ only by those values will be recognized as the same
         * for caching purposes.</li>
         * </ul>
         * </p>
         *
         * @param uri The URI, using the content:// scheme, for the content to
         *         retrieve.
         * @param projection A list of which columns to return. Passing null will
         *         return all columns, which is inefficient.
         * @param selection A filter declaring which rows to return, formatted as an
         *         SQL WHERE clause (excluding the WHERE itself). Passing null will
         *         return all rows for the given URI.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in the order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
         *         clause (excluding the ORDER BY itself). Passing null will use the
         *         default sort order, which may be unordered.
         * @return A Cursor object, which is positioned before the first entry, or null
         * @see Cursor
         */
        Query(
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String sortOrder,
            [out] ICursor** cursor);

        /**
         * <p>
         * Query the given URI, returning a {@sa Cursor} over the result set.
         * </p>
         * <p>
         * For best performance, the caller should follow these guidelines:
         * <ul>
         * <li>Provide an explicit projection, to prevent
         * reading data from storage that aren't going to be used.</li>
         * <li>Use question mark parameter markers such as 'phone=?' instead of
         * explicit values in the {@code selection} parameter, so that queries
         * that differ only by those values will be recognized as the same
         * for caching purposes.</li>
         * </ul>
         * </p>
         *
         * @param uri The URI, using the content:// scheme, for the content to
         *         retrieve.
         * @param projection A list of which columns to return. Passing null will
         *         return all columns, which is inefficient.
         * @param selection A filter declaring which rows to return, formatted as an
         *         SQL WHERE clause (excluding the WHERE itself). Passing null will
         *         return all rows for the given URI.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in the order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
         *         clause (excluding the ORDER BY itself). Passing null will use the
         *         default sort order, which may be unordered.
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then {@sa OperationCanceledException} will be thrown
         * when the query is executed.
         * @return A Cursor object, which is positioned before the first entry, or null
         * @see Cursor
         */
        Query(
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String sortOrder,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Transform the given <var>url</var> to a canonical representation of
         * its referenced resource, which can be used across devices, persisted,
         * backed up and restored, etc.  The returned Uri is still a fully capable
         * Uri for use with its content provider, allowing you to do all of the
         * same content provider operations as with the original Uri --
         * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
         * only difference in behavior between the original and new Uris is that
         * the content provider may need to do some additional work at each call
         * using it to resolve it to the correct resource, especially if the
         * canonical Uri has been moved to a different environment.
         *
         * <p>If you are moving a canonical Uri between environments, you should
         * perform another call to {@link #canonicalize} with that original Uri to
         * re-canonicalize it for the current environment.  Alternatively, you may
         * want to use {@link #uncanonicalize} to transform it to a non-canonical
         * Uri that works only in the current environment but potentially more
         * efficiently than the canonical representation.</p>
         *
         * @param url The {@link Uri} that is to be transformed to a canonical
         * representation.  Like all resolver calls, the input can be either
         * a non-canonical or canonical Uri.
         *
         * @return Returns the official canonical representation of <var>url</var>,
         * or null if the content provider does not support a canonical representation
         * of the given Uri.  Many providers may not support canonicalization of some
         * or all of their Uris.
         *
         * @see #uncanonicalize
         */
        Canonicalize(
            [in] IUri* uri,
            [out] IUri** result);

        /**
         * Given a canonical Uri previously generated by {@link #canonicalize}, convert
         * it to its local non-canonical form.  This can be useful in some cases where
         * you know that you will only be using the Uri in the current environment and
         * want to avoid any possible overhead when using it with the content
         * provider or want to verify that the referenced data exists at all in the
         * new environment.
         *
         * @param url The canonical {@link Uri} that is to be convered back to its
         * non-canonical form.
         *
         * @return Returns the non-canonical representation of <var>url</var>.  This will
         * return null if data identified by the canonical Uri can not be found in
         * the current environment; callers must always check for null and deal with
         * that by appropriately falling back to an alternative.
         *
         * @see #canonicalize
         */
        Uncanonicalize(
            [in] IUri* uri,
            [out] IUri** result);

        /**
         * Open a stream on to the content associated with a content URI.  If there
         * is no data associated with the URI, FileNotFoundException is thrown.
         *
         * <h5>Accepts the following URI schemes:</h5>
         * <ul>
         * <li>content ({@sa #SCHEME_CONTENT})</li>
         * <li>android.resource ({@sa #SCHEME_ANDROID_RESOURCE})</li>
         * <li>file ({@sa #SCHEME_FILE})</li>
         * </ul>
         *
         * <p>See {@sa #openAssetFileDescriptor(Uri, String)} for more information
         * on these schemes.
         *
         * @param uri The desired URI.
         * @return InputStream
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException | if the provided URI could not be opened.
         * @see #openAssetFileDescriptor(Uri, String)
         */
        OpenInputStream(
            [in] IUri* uri,
            [out] IInputStream** inStream);

        /**
         * Synonym for {@sa #openOutputStream(Uri, String)
         * openOutputStream(uri, "w")}.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException | if the provided URI could not be opened.
         */
        OpenOutputStream(
            [in] IUri* uri,
            [out] IOutputStream** outStream);

        /**
         * Open a stream on to the content associated with a content URI.  If there
         * is no data associated with the URI, FileNotFoundException is thrown.
         *
         * <h5>Accepts the following URI schemes:</h5>
         * <ul>
         * <li>content ({@sa #SCHEME_CONTENT})</li>
         * <li>file ({@sa #SCHEME_FILE})</li>
         * </ul>
         *
         * <p>See {@sa #openAssetFileDescriptor(Uri, String)} for more information
         * on these schemes.
         *
         * @param uri The desired URI.
         * @param mode May be "w", "wa", "rw", or "rwt".
         * @return OutputStream
         * FileNotFoundException | if the provided URI could not be opened.
         * @see #openAssetFileDescriptor(Uri, String)
         */
        OpenOutputStream(
            [in] IUri* uri,
            [in] String mode,
            [out] IOutputStream** outStream);

        /**
         * Open a raw file descriptor to access data under a URI.  This
         * is like {@sa #openAssetFileDescriptor(Uri, String)}, but uses the
         * underlying {@sa ContentProvider#openFile}
         * ContentProvider.openFile()} method, so will <em>not</em> work with
         * providers that return sub-sections of files.  If at all possible,
         * you should use {@sa #openAssetFileDescriptor(Uri, String)}.  You
         * will receive a FileNotFoundException exception if the provider returns a
         * sub-section of a file.
         *
         * <h5>Accepts the following URI schemes:</h5>
         * <ul>
         * <li>content ({@sa #SCHEME_CONTENT})</li>
         * <li>file ({@sa #SCHEME_FILE})</li>
         * </ul>
         *
         * <p>See {@sa #openAssetFileDescriptor(Uri, String)} for more information
         * on these schemes.
         *
         * @param uri The desired URI to open.
         * @param mode The file mode to use, as per {@sa ContentProvider#openFile
         * ContentProvider.openFile}.
         * @return Returns a new ParcelFileDescriptor pointing to the file.  You
         * own this descriptor and are responsible for closing it when done.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException | if no
         * file exists under the URI or the mode is invalid.
         * @see #openAssetFileDescriptor(Uri, String)
         */
        OpenFileDescriptor(
            [in] IUri* uri,
            [in] String mode,
            [out] IParcelFileDescriptor** fileDescriptor);

        OpenFileDescriptor(
            [in] IUri* uri,
            [in] String mode,
            [in] ICancellationSignal* signal,
            [out] IParcelFileDescriptor** fileDescriptor);

        /**
         * Open a raw file descriptor to access data under a URI.  This
         * interacts with the underlying {@sa ContentProvider#openAssetFile}
         * method of the provider associated with the given URI, to retrieve any file stored there.
         *
         * <h5>Accepts the following URI schemes:</h5>
         * <ul>
         * <li>content ({@sa #SCHEME_CONTENT})</li>
         * <li>android.resource ({@sa #SCHEME_ANDROID_RESOURCE})</li>
         * <li>file ({@sa #SCHEME_FILE})</li>
         * </ul>
         * <h5>The android.resource ({@sa #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
         * <p>
         * A Uri object can be used to reference a resource in an APK file.  The
         * Uri should be one of the following formats:
         * <ul>
         * <li><code>android.resource://package_name/id_number</code><br/>
         * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
         * For example <code>com.example.myapp</code><br/>
         * <code>id_number</code> is the int form of the ID.<br/>
         * The easiest way to construct this form is
         * <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
         * </li>
         * <li><code>android.resource://package_name/type/name</code><br/>
         * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
         * For example <code>com.example.myapp</code><br/>
         * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
         * or <code>drawable</code>.
         * <code>name</code> is the string form of the resource name.  That is, whatever the file
         * name was in your res directory, without the type extension.
         * The easiest way to construct this form is
         * <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
         * </li>
         * </ul>
         *
         * <p>Note that if this function is called for read-only input (mode is "r")
         * on a content: URI, it will instead call {@sa #openTypedAssetFileDescriptor}
         * for you with a MIME type of "*\/*".  This allows such callers to benefit
         * from any built-in data conversion that a provider implements.
         *
         * @param uri The desired URI to open.
         * @param mode The file mode to use, as per {@sa ContentProvider#openAssetFile
         * ContentProvider.openAssetFile}.
         * @return Returns a new ParcelFileDescriptor pointing to the file.  You
         * own this descriptor and are responsible for closing it when done.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException | if no
         * file exists under the URI or the mode is invalid.
         */
        OpenAssetFileDescriptor(
            [in] IUri* uri,
            [in] String mode,
            [out] IAssetFileDescriptor** fileDescriptor);

        OpenAssetFileDescriptor(
            [in] IUri* uri,
            [in] String mode,
            [in] ICancellationSignal* signal,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * Open a raw file descriptor to access (potentially type transformed)
         * data from a "content:" URI.  This interacts with the underlying
         * {@sa ContentProvider#openTypedAssetFile} method of the provider
         * associated with the given URI, to retrieve retrieve any appropriate
         * data stream for the data stored there.
         *
         * <p>Unlike {@sa #openAssetFileDescriptor}, this function only works
         * with "content:" URIs, because content providers are the only facility
         * with an associated MIME type to ensure that the returned data stream
         * is of the desired type.
         *
         * <p>All text/* streams are encoded in UTF-8.
         *
         * @param uri The desired URI to open.
         * @param mimeType The desired MIME type of the returned data.  This can
         * be a pattern such as *\/*, which will allow the content provider to
         * select a type, though there is no way for you to determine what type
         * it is returning.
         * @param opts Additional provider-dependent options.
         * @return Returns a new ParcelFileDescriptor from which you can read the
         * data stream from the provider.  Note that this may be a pipe, meaning
         * you can't seek in it.  The only seek you should do is if the
         * AssetFileDescriptor contains an offset, to move to that offset before
         * reading.  You own this descriptor and are responsible for closing it when done.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * FileNotFoundException Throws FileNotFoundException if no
         * data of the desired type exists under the URI.
         */
        OpenTypedAssetFileDescriptor(
            [in] IUri* uri,
            [in] String mimeType,
            [in] IBundle* opts,
            [out] IAssetFileDescriptor** fileDescriptor);

        OpenTypedAssetFileDescriptor(
            [in] IUri* uri,
            [in] String mimeType,
            [in] IBundle* opts,
            [in] ICancellationSignal* signal,
            [out] IAssetFileDescriptor** fileDescriptor);

        /**
         * Resolves an android.resource URI to a {@sa Resources} and a resource id.
         *
         * @hide
         */
        GetResourceId(
            [in] IUri* uri,
            [out] IContentResolverOpenResourceIdResult** resourceIdResult);

        /**
         * Inserts a row into a table at the given URL.
         *
         * If the content provider supports transactions the insertion will be atomic.
         *
         * @param url The URL of the table to insert into.
         * @param values The initial values for the newly inserted row. The key is the column name for
         *               the field. Passing an empty ContentValues will create an empty row.
         * @return the URL of the newly created row.
         */
        Insert(
            [in] IUri* uri,
            [in] IContentValues* values,
            [out] IUri** insertedUri);

        /**
         * Applies each of the {@sa ContentProviderOperation} objects and returns an array
         * of their results. Passes through OperationApplicationException, which may be thrown
         * by the call to {@sa ContentProviderOperation#apply}.
         * If all the applications succeed then a {@sa ContentProviderResult} array with the
         * same number of elements as the operations will be returned. It is implementation-specific
         * how many, if any, operations will have been successfully applied if a call to
         * apply results in a {@sa OperationApplicationException}.
         * @param authority the authority of the ContentProvider to which this batch should be applied
         * @param operations the operations to apply
         * @return the results of the applications
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * OperationApplicationException thrown | if an application fails.
         * See {@sa ContentProviderOperation#apply} for more information.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * RemoteException thrown | if a RemoteException is encountered while attempting
         *   to communicate with a remote provider.
         */
        ApplyBatch(
            [in] String authority,
            [in] IArrayList* operations,
            [out, callee] ArrayOf<IContentProviderResult*>* providerResults);

        /**
         * Inserts multiple rows into a table at the given URL.
         *
         * This function make no guarantees about the atomicity of the insertions.
         *
         * @param url The URL of the table to insert into.
         * @param values The initial values for the newly inserted rows. The key is the column name for
         *               the field. Passing null will create an empty row.
         * @return the number of newly created rows.
         */
        BulkInsert(
            [in] IUri* uri,
            [in] ArrayOf<IContentValues*>* values,
            [out] Int32* number);

        /**
         * Deletes row(s) specified by a content URI.
         *
         * If the content provider supports transactions, the deletion will be atomic.
         *
         * @param url The URL of the row to delete.
         * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
                        (excluding the WHERE itself).
         * @return The number of rows deleted.
         */
        Delete(
            [in] IUri* uri,
            [in] String where,
            [in] ArrayOf<String>* selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Update row(s) in a content URI.
         *
         * If the content provider supports transactions the update will be atomic.
         *
         * @param uri The URI to modify.
         * @param values The new field values. The key is the column name for the field.
                         A null value will remove an existing field value.
         * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
                        (excluding the WHERE itself).
         * @return the number of rows updated.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if uri or values are null
         */
        Update(
            [in] IUri* uri,
            [in] IContentValues* values,
            [in] String where,
            [in] ArrayOf<String>* selectionArgs,
            [out] Int32* rowsAffected);

        /**
         * Call a provider-defined method.  This can be used to implement
         * read or write interfaces which are cheaper than using a Cursor and/or
         * do not fit into the traditional table model.
         *
         * @param method provider-defined method name to call.  Opaque to
         *   framework, but must be non-null.
         * @param arg provider-defined String argument.  May be null.
         * @param extras provider-defined Bundle argument.  May be null.
         * @return a result Bundle, possibly null.  Will be null if the ContentProvider
         *   does not implement call.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NullPointerException | if uri or method is null
         * IllegalArgumentException | if uri is not known
         */
        Call(
            [in] IUri* uri,
            [in] String method,
            [in] String arg,
            [in] IBundle* extras,
            [out] IBundle** bundle);

        /**
         * Returns the content provider for the given content URI.
         *
         * @param uri The URI to a content provider
         * @return The ContentProvider for the given URI, or null if no content provider is found.
         * @hide
         */
        AcquireProvider(
            [in] IUri* uri,
            [out] IIContentProvider** contentProvider);

        /**
         * Returns the content provider for the given content URI if the process
         * already has a reference on it.
         *
         * @param uri The URI to a content provider
         * @return The ContentProvider for the given URI, or null if no content provider is found.
         * @hide
         */
        AcquireExistingProvider(
            [in] IUri* uri,
            [out] IIContentProvider** contentProvider);

        /**
         * @hide
         */
        AcquireProvider(
            [in] String name,
            [out] IIContentProvider** contentProvider);

        /**
         * Returns the content provider for the given content URI.
         *
         * @param uri The URI to a content provider
         * @return The ContentProvider for the given URI, or null if no content provider is found.
         * @hide
         */
        AcquireUnstableProvider(
            [in] IUri* uri,
            [out] IIContentProvider** contentProvider);

        /**
         * @hide
         */
        AcquireUnstableProvider(
            [in] String name,
            [out] IIContentProvider** contentProvider);

        /**
         * Returns a {@sa ContentProviderClient} that is associated with the {@sa ContentProvider}
         * that services the content at uri, starting the provider if necessary. Returns
         * null if there is no provider associated wih the uri. The caller must indicate that they are
         * done with the provider by calling {@sa ContentProviderClient#release} which will allow
         * the system to release the provider it it determines that there is no other reason for
         * keeping it active.
         * @param uri specifies which provider should be acquired
         * @return a {@sa ContentProviderClient} that is associated with the {@sa ContentProvider}
         * that services the content at uri or null if there isn't one.
         */
        AcquireContentProviderClient(
            [in] IUri* uri,
            [out] IContentProviderClient** client);

        /**
         * Returns a {@sa ContentProviderClient} that is associated with the {@sa ContentProvider}
         * with the authority of name, starting the provider if necessary. Returns
         * null if there is no provider associated wih the uri. The caller must indicate that they are
         * done with the provider by calling {@sa ContentProviderClient#release} which will allow
         * the system to release the provider it it determines that there is no other reason for
         * keeping it active.
         * @param name specifies which provider should be acquired
         * @return a {@sa ContentProviderClient} that is associated with the {@sa ContentProvider}
         * with the authority of name or null if there isn't one.
         */
        AcquireContentProviderClient(
            [in] String name,
            [out] IContentProviderClient** client);

        /**
         * Like {@sa #acquireContentProviderClient(Uri)}, but for use when you do
         * not trust the stability of the target content provider.  This turns off
         * the mechanism in the platform clean up processes that are dependent on
         * a content provider if that content provider's process goes away.  Normally
         * you can safely assume that once you have acquired a provider, you can freely
         * use it as needed and it won't disappear, even if your process is in the
         * background.  If using this method, you need to take care to deal with any
         * failures when communicating with the provider, and be sure to close it
         * so that it can be re-opened later.  In particular, catching a
         * {@sa android.os.DeadObjectException} from the calls there will let you
         * know that the content provider has gone away; at that point the current
         * ContentProviderClient object is invalid, and you should release it.  You
         * can acquire a new one if you would like to try to restart the provider
         * and perform new operations on it.
         */
        AcquireUnstableContentProviderClient(
            [in] IUri* uri,
            [out] IContentProviderClient** client);

        /**
         * Like {@sa #acquireContentProviderClient(String)}, but for use when you do
         * not trust the stability of the target content provider.  This turns off
         * the mechanism in the platform clean up processes that are dependent on
         * a content provider if that content provider's process goes away.  Normally
         * you can safely assume that once you have acquired a provider, you can freely
         * use it as needed and it won't disappear, even if your process is in the
         * background.  If using this method, you need to take care to deal with any
         * failures when communicating with the provider, and be sure to close it
         * so that it can be re-opened later.  In particular, catching a
         * {@sa android.os.DeadObjectException} from the calls there will let you
         * know that the content provider has gone away; at that point the current
         * ContentProviderClient object is invalid, and you should release it.  You
         * can acquire a new one if you would like to try to restart the provider
         * and perform new operations on it.
         */
        AcquireUnstableContentProviderClient(
            [in] String name,
            [out] IContentProviderClient** client);

        /**
         * Register an observer class that gets callbacks when data identified by a
         * given content URI changes.
         *
         * @param uri The URI to watch for changes. This can be a specific row URI, or a base URI
         * for a whole class of content.
         * @param notifyForDescendents If <code>true</code> changes to URIs beginning with <code>uri</code>
         * will also cause notifications to be sent. If <code>false</code> only changes to the exact URI
         * specified by <em>uri</em> will cause notifications to be sent. If true, than any URI values
         * at or below the specified URI will also trigger a match.
         * @param observer The object that receives callbacks when changes occur.
         * @see #unregisterContentObserver
         */
        RegisterContentObserver(
            [in] IUri* uri,
            [in] Boolean notifyForDescendents,
            [in] IContentObserver* observer);

        /** @hide - designated user version */
        RegisterContentObserver(
            [in] IUri* uri,
            [in] Boolean notifyForDescendents,
            [in] IContentObserver* observer,
            [in] Int32 userHandle);

        /**
         * Unregisters a change observer.
         *
         * @param observer The previously registered observer that is no longer needed.
         * @see #registerContentObserver
         */
        UnregisterContentObserver(
            [in] IContentObserver* observer);

        /**
         * Notify registered observers that a row was updated and attempt to sync changes
         * to the network.
         * To register, call {@sa #registerContentObserver(android.net.Uri , boolean, android.database.ContentObserver) registerContentObserver()}.
         * By default, CursorAdapter objects will get this notification.
         *
         * @param uri The uri of the content that was changed.
         * @param observer The observer that originated the change, may be <code>null</null>.
         * The observer that originated the change will only receive the notification if it
         * has requested to receive self-change notifications by implementing
         * {@sa ContentObserver#deliverSelfNotifications()} to return true.
         */
        NotifyChange(
            [in] IUri* uri,
            [in] IContentObserver* observer);

        /**
         * Notify registered observers that a row was updated.
         * To register, call {@sa #registerContentObserver(android.net.Uri , boolean, android.database.ContentObserver) registerContentObserver()}.
         * By default, CursorAdapter objects will get this notification.
         * If syncToNetwork is true, this will attempt to schedule a local sync using the sync
         * adapter that's registered for the authority of the provided uri. No account will be
         * passed to the sync adapter, so all matching accounts will be synchronized.
         *
         * @param uri The uri of the content that was changed.
         * @param observer The observer that originated the change, may be <code>null</null>.
         * The observer that originated the change will only receive the notification if it
         * has requested to receive self-change notifications by implementing
         * {@sa ContentObserver#deliverSelfNotifications()} to return true.
         * @param syncToNetwork If true, attempt to sync the change to the network.
         * @see #requestSync(android.accounts.Account, String, android.os.Bundle)
         */
        NotifyChange(
            [in] IUri* uri,
            [in] IContentObserver* observer,
            [in] Boolean syncToNetwork);

        /**
         * Notify registered observers within the designated user(s) that a row was updated.
         *
         * @hide
         */
        NotifyChange(
            [in] IUri* uri,
            [in] IContentObserver* observer,
            [in] Boolean syncToNetwork,
            [in] Int32 userHandle);

        /**
         * Take a persistable URI permission grant that has been offered. Once
         * taken, the permission grant will be remembered across device reboots.
         * Only URI permissions granted with
         * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
         * the grant has already been persisted, taking it again will touch
         * {@link UriPermission#getPersistedTime()}.
         *
         * @see #getPersistedUriPermissions()
         */
        TakePersistableUriPermission(
            [in] IUri* uri,
            [in] Int32 mode);

        /**
         * Relinquish a persisted URI permission grant. The URI must have been
         * previously made persistent with
         * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
         * grants to the calling package will remain intact.
         *
         * @see #getPersistedUriPermissions()
         */
        ReleasePersistableUriPermission(
            [in] IUri* uri,
            [in] Int32 mode);

        /**
         * Return list of all URI permission grants that have been persisted by the
         * calling app. That is, the returned permissions have been granted
         * <em>to</em> the calling app. Only persistable grants taken with
         * {@link #takePersistableUriPermission(Uri, int)} are returned.
         *
         * @see #takePersistableUriPermission(Uri, int)
         * @see #releasePersistableUriPermission(Uri, int)
         */
        GetPersistedUriPermissions(
            [out] IList** permissions);

        /**
         * Return list of all persisted URI permission grants that are hosted by the
         * calling app. That is, the returned permissions have been granted
         * <em>from</em> the calling app. Only grants taken with
         * {@link #takePersistableUriPermission(Uri, int)} are returned.
         */
        GetOutgoingPersistedUriPermissions(
            [out] IList** permissions);

        /**
         * Start an asynchronous sync operation. If you want to monitor the progress
         * of the sync you may register a SyncObserver. Only values of the following
         * types may be used in the extras bundle:
         * <ul>
         * <li>Integer</li>
         * <li>Long</li>
         * <li>Boolean</li>
         * <li>Float</li>
         * <li>Double</li>
         * <li>String</li>
         * </ul>
         *
         * @param uri the uri of the provider to sync or null to sync all providers.
         * @param extras any extras to pass to the SyncAdapter.
         * @deprecated instead use
         * {@sa #requestSync(android.accounts.Account, String, android.os.Bundle)}
         */
        StartSync(
            [in] IUri* uri,
            [in] IBundle* extras);

        /**
         * Cancel any active or pending syncs that match the Uri. If the uri is null then
         * all syncs will be canceled.
         *
         * @param uri the uri of the provider to sync or null to sync all providers.
         * @deprecated instead use {@sa #cancelSync(android.accounts.Account, String)}
         */
        CancelSync(
            [in] IUri* uri);
    }

    interface IContentResolverHelper{
        /**
         * Start an asynchronous sync operation. If you want to monitor the progress
         * of the sync you may register a SyncObserver. Only values of the following
         * types may be used in the extras bundle:
         * <ul>
         * <li>Integer</li>
         * <li>Long</li>
         * <li>Boolean</li>
         * <li>Float</li>
         * <li>Double</li>
         * <li>String</li>
         * </ul>
         *
         * @param account which account should be synced
         * @param authority which authority should be synced
         * @param extras any extras to pass to the SyncAdapter.
         */
        RequestSync(
            [in] IAccount* account,
            [in] String authority,
            [in] IBundle* extras);

        /**
         * Register a sync with the SyncManager. These requests are built using the
         * {@link SyncRequest.Builder}.
         */
        RequestSync(
            [in] ISyncRequest* request);

        /**
         * Check that only values of the following types are in the Bundle:
         * <ul>
         * <li>Integer</li>
         * <li>Long</li>
         * <li>Boolean</li>
         * <li>Float</li>
         * <li>Double</li>
         * <li>String</li>
         * <li>Account</li>
         * <li>null</li>
         * </ul>
         * @param extras the Bundle to check
         */
        ValidateSyncExtrasBundle(
            [in] IBundle* extras);

        /**
         * Cancel any active or pending syncs that match account and authority. The account and
         * authority can each independently be set to null, which means that syncs with any account
         * or authority, respectively, will match.
         *
         * @param account filters the syncs that match by this account
         * @param authority filters the syncs that match by this authority
         */
        CancelSync(
            [in] IAccount* account,
            [in] String authority);

        /**
         * Get information about the SyncAdapters that are known to the system.
         * @return an array of SyncAdapters that have registered with the system
         */
        GetSyncAdapterTypes(
            [out, callee] ArrayOf<ISyncAdapterType*>* types);

        /**
         * Check if the provider should be synced when a network tickle is received
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_SETTINGS}.
         *
         * @param account the account whose setting we are querying
         * @param authority the provider whose setting we are querying
         * @return true if the provider should be synced when a network tickle is received
         */
        GetSyncAutomatically(
            [in] IAccount* account,
            [in] String authority,
            [out] Boolean* isSynced);

        /**
         * Set whether or not the provider is synced when it receives a network tickle.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         *
         * @param account the account whose setting we are querying
         * @param authority the provider whose behavior is being controlled
         * @param sync true if the provider should be synced when tickles are received for it
         */
        SetSyncAutomatically(
            [in] IAccount* account,
            [in] String authority,
            [in] Boolean sync);

        /**
         * Specifies that a sync should be requested with the specified the account, authority,
         * and extras at the given frequency. If there is already another periodic sync scheduled
         * with the account, authority and extras then a new periodic sync won't be added, instead
         * the frequency of the previous one will be updated.
         * <p>
         * These periodic syncs honor the "syncAutomatically" and "masterSyncAutomatically" settings.
         * Although these sync are scheduled at the specified frequency, it may take longer for it to
         * actually be started if other syncs are ahead of it in the sync operation queue. This means
         * that the actual start time may drift.
         * <p>
         * Periodic syncs are not allowed to have any of {@sa #SYNC_EXTRAS_DO_NOT_RETRY},
         * {@sa #SYNC_EXTRAS_IGNORE_BACKOFF}, {@sa #SYNC_EXTRAS_IGNORE_SETTINGS},
         * {@sa #SYNC_EXTRAS_INITIALIZE}, {@sa #SYNC_EXTRAS_FORCE},
         * {@sa #SYNC_EXTRAS_EXPEDITED}, {@sa #SYNC_EXTRAS_MANUAL} set to true.
         * If any are supplied then an {@sa IllegalArgumentException} will be thrown.
         *
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         *
         * @param account the account to specify in the sync
         * @param authority the provider to specify in the sync request
         * @param extras extra parameters to go along with the sync request
         * @param pollFrequency how frequently the sync should be performed, in seconds.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if an illegal extra was set or if any of the parameters
         * are null.
         */
        AddPeriodicSync(
            [in] IAccount* account,
            [in] String authority,
            [in] IBundle* extras,
            [in] Int64 pollFrequency);

        /**
         * Remove a periodic sync. Has no affect if account, authority and extras don't match
         * an existing periodic sync.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         *
         * @param account the account of the periodic sync to remove
         * @param authority the provider of the periodic sync to remove
         * @param extras the extras of the periodic sync to remove
         */
        RemovePeriodicSync(
            [in] IAccount* account,
            [in] String authority,
            [in] IBundle* extras);

        /**
         * Remove the specified sync. This will cancel any pending or active syncs. If the request is
         * for a periodic sync, this call will remove any future occurrences.
         * <p>
         *     If a periodic sync is specified, the caller must hold the permission
         *     {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         *</p>
         * It is possible to cancel a sync using a SyncRequest object that is not the same object
         * with which you requested the sync. Do so by building a SyncRequest with the same
         * adapter, frequency, <b>and</b> extras bundle.
         *
         * @param request SyncRequest object containing information about sync to cancel.
         */
        CancelSync(
            [in] ISyncRequest* request);

        /**
         * Get the list of information about the periodic syncs for the given account and authority.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_SETTINGS}.
         *
         * @param account the account whose periodic syncs we are querying
         * @param authority the provider whose periodic syncs we are querying
         * @return a list of PeriodicSync objects. This list may be empty but will never be null.
         */
        GetPeriodicSyncs(
            [in] IAccount* account,
            [in] String authority,
            [out] IList** periodicSyncs);

        /**
         * Check if this account/provider is syncable.
         * <p>This method requires the caller to hold the permission
         * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
         * @return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
         */
        GetIsSyncable(
            [in] IAccount* account,
            [in] String authority,
            [out] Int32* isSyncable);

        /**
         * Set whether this account/provider is syncable.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         * @param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
         */
        SetIsSyncable(
            [in] IAccount* account,
            [in] String authority,
            [in] Int32 syncable);

        /**
         * Gets the master auto-sync setting that applies to all the providers and accounts.
         * If this is false then the per-provider auto-sync setting is ignored.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_SETTINGS}.
         *
         * @return the master auto-sync setting that applies to all the providers and accounts
         */
        GetMasterSyncAutomatically(
            [out] Boolean* result);

        /**
         * Sets the master auto-sync setting that applies to all the providers and accounts.
         * If this is false then the per-provider auto-sync setting is ignored.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#WRITE_SYNC_SETTINGS}.
         *
         * @param sync the master auto-sync setting that applies to all the providers and accounts
         */
        SetMasterSyncAutomatically(
            [in] Boolean sync);

        /**
         * Returns true if there is currently a sync operation for the given
         * account or authority in the pending list, or actively being processed.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_STATS}.
         * @param account the account whose setting we are querying
         * @param authority the provider whose behavior is being queried
         * @return true if a sync is active for the given account or authority.
         */
        IsSyncActive(
            [in] IAccount* account,
            [in] String authority,
            [out] Boolean* isSyncActive);

        /**
         * If a sync is active returns the information about it, otherwise returns null.
         * <p>
         * This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_STATS}.
         * <p>
         * @return the SyncInfo for the currently active sync or null if one is not active.
         * @deprecated
         * Since multiple concurrent syncs are now supported you should use
         * {@sa #getCurrentSyncs()} to get the accurate list of current syncs.
         * This method returns the first item from the list of current syncs
         * or null if there are none.
         */
        GetCurrentSync(
            [out] ISyncInfo** syncInfo);

        /**
         * Returns a list with information about all the active syncs. This list will be empty
         * if there are no active syncs.
         * <p>
         * This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_STATS}.
         * <p>
         * @return a List of SyncInfo objects for the currently active syncs.
         */
        GetCurrentSyncs(
            [out] IList** syncInfoList);

        /**
         * Returns the status that matches the authority.
         * @param account the account whose setting we are querying
         * @param authority the provider whose behavior is being queried
         * @return the SyncStatusInfo for the authority, or null if none exists
         * @hide
         */
        GetSyncStatus(
            [in] IAccount* account,
            [in] String authority,
            [out] ISyncStatusInfo** syncStatusInfo);

        /**
         * Return true if the pending status is true of any matching authorities.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#READ_SYNC_STATS}.
         * @param account the account whose setting we are querying
         * @param authority the provider whose behavior is being queried
         * @return true if there is a pending sync with the matching account and authority
         */
        IsSyncPending(
            [in] IAccount* account,
            [in] String authority,
            [out] Boolean* isSyncPending);

        /**
         * Request notifications when the different aspects of the SyncManager change. The
         * different items that can be requested are:
         * <ul>
         * <li> {@sa #SYNC_OBSERVER_TYPE_PENDING}
         * <li> {@sa #SYNC_OBSERVER_TYPE_ACTIVE}
         * <li> {@sa #SYNC_OBSERVER_TYPE_SETTINGS}
         * </ul>
         * The caller can set one or more of the status types in the mask for any
         * given listener registration.
         * @param mask the status change types that will cause the callback to be invoked
         * @param callback observer to be invoked when the status changes
         * @return a handle that can be used to remove the listener at a later time
         */
        AddStatusChangeListener(
            [in] Int32 mask,
            [in] ISyncStatusObserver* observerCallback,
            [out] IInterface** item);

        /**
         * Remove a previously registered status change listener.
         * @param handle the handle that was returned by {@sa #addStatusChangeListener}
         */
        RemoveStatusChangeListener(
            [in] IInterface* handle);

        /** @hide */
        GetContentService(
            [out] IIContentService** contentService);

        /** @hide */
        SyncErrorToString(
            [in] Int32 error,
            [out] String* str);

        GetACTION_SYNC_CONN_STATUS_CHANGED(
            [out] IIntent** intent);
    }

    } // namespace Content
    } // namespace Droid
    } // namespace Elastos
}