module
{
    using interface Elastos.IO.IFile;
    using interface Elastos.Utility.ILocale;
    using interface Elastos.Utility.IMap;

    interface Elastos.Droid.Os.ICancellationSignal;
    interface Elastos.Droid.Content.IContentValues;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Database.Sqlite.ISQLiteQuery;
    interface Elastos.Droid.Database.IDatabaseErrorHandler;
    interface Elastos.Droid.Database.Sqlite.ISQLiteStatement;
    interface Elastos.Droid.Database.Sqlite.ISQLiteCursorDriver;
    interface Elastos.Droid.Database.Sqlite.ISQLiteTransactionListener;

    namespace Elastos {
    namespace Droid {
    namespace Database {
    namespace Sqlite {

    interface ISQLiteDatabase;

    /**
     * Used to allow returning sub-classes of {@link Cursor} when calling query.
     */
    interface ISQLiteDatabaseCursorFactory {
        /**
         * See {@link SQLiteCursor#SQLiteCursor(SQLiteCursorDriver, String, SQLiteQuery)}.
         */
        NewCursor(
            [in] ISQLiteDatabase* db,
            [in] ISQLiteCursorDriver* masterQuery,
            [in] String editTable,
            [in] ISQLiteQuery* query,
            [out] ICursor** result);
    }

    [deprecated]
    interface ICustomFunction {
        Callback(
            [in] ArrayOf<String>* args);
    }


    /**
     * Exposes methods to manage a SQLite database.
     *
     * <p>
     * SQLiteDatabase has methods to create, delete, execute SQL commands, and
     * perform other common database management tasks.
     * </p><p>
     * See the Notepad sample application in the SDK for an example of creating
     * and managing a database.
     * </p><p>
     * Database names must be unique within an application, not across all applications.
     * </p>
     *
     * <h3>Localized Collation - ORDER BY</h3>
     * <p>
     * In addition to SQLite's default <code>BINARY</code> collator, Android supplies
     * two more, <code>LOCALIZED</code>, which changes with the system's current locale,
     * and <code>UNICODE</code>, which is the Unicode Collation Algorithm and not tailored
     * to the current locale.
     * </p>
     *
     * @Involve
     * interface ICloseable
     * interface ISQLiteClosable
     */
    [deprecated]
    interface ISQLiteDatabase {
        /**
         * When a constraint violation occurs, an immediate ROLLBACK occurs,
         * thus ending the current transaction, and the command aborts with a
         * return code of SQLITE_CONSTRAINT. If no transaction is active
         * (other than the implied transaction that is created on every command)
         * then this algorithm works the same as ABORT.
         */
        const Int32 CONFLICT_ROLLBACK = 1;

        /**
         * When a constraint violation occurs,no ROLLBACK is executed
         * so changes from prior commands within the same transaction
         * are preserved. This is the default behavior.
         */
        const Int32 CONFLICT_ABORT = 2;

        /**
         * When a constraint violation occurs, the command aborts with a return
         * code SQLITE_CONSTRAINT. But any changes to the database that
         * the command made prior to encountering the constraint violation
         * are preserved and are not backed out.
         */
        const Int32 CONFLICT_FAIL = 3;

        /**
         * When a constraint violation occurs, the one row that contains
         * the constraint violation is not inserted or changed.
         * But the command continues executing normally. Other rows before and
         * after the row that contained the constraint violation continue to be
         * inserted or updated normally. No error is returned.
         */
        const Int32 CONFLICT_IGNORE = 4;

        /**
         * When a UNIQUE constraint violation occurs, the pre-existing rows that
         * are causing the constraint violation are removed prior to inserting
         * or updating the current row. Thus the insert or update always occurs.
         * The command continues executing normally. No error is returned.
         * If a NOT NULL constraint violation occurs, the NULL value is replaced
         * by the default value for that column. If the column has no default
         * value, then the ABORT algorithm is used. If a CHECK constraint
         * violation occurs then the IGNORE algorithm is used. When this conflict
         * resolution strategy deletes rows in order to satisfy a constraint,
         * it does not invoke delete triggers on those rows.
         * This behavior might change in a future release.
         */
        const Int32 CONFLICT_REPLACE = 5;

        /**
         * Use the following when no conflict action is specified.
         */
        const Int32 CONFLICT_NONE = 0;

        /**
         * Maximum Length Of A LIKE Or GLOB Pattern
         * The pattern matching algorithm used in the default LIKE and GLOB implementation
         * of SQLite can exhibit O(N^2) performance (where N is the number of characters in
         * the pattern) for certain pathological cases. To avoid denial-of-service attacks
         * the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes.
         * The default value of this limit is 50000. A modern workstation can evaluate
         * even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly.
         * The denial of service problem only comes into play when the pattern length gets
         * into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns
         * are at most a few dozen bytes in length, paranoid application developers may
         * want to reduce this parameter to something in the range of a few hundred
         * if they know that external users are able to generate arbitrary patterns.
         */
        const Int32 SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000;

        /**
         * Open flag: Flag for {@link #openDatabase} to open the database for reading and writing.
         * If the disk is full, this may fail even before you actually write anything.
         *
         * {@more} Note that the value of this flag is 0, so it is the default.
         */
        const Int32 OPEN_READWRITE = 0x00000000;          // update native code if changing

        /**
         * Open flag: Flag for {@link #openDatabase} to open the database for reading only.
         * This is the only reliable way to open a database if the disk may be full.
         */
        const Int32 OPEN_READONLY = 0x00000001;           // update native code if changing

        /**
         * Open flag: Flag for {@link #openDatabase} to open the database without support for
         * localized collators.
         *
         * {@more} This causes the collator <code>LOCALIZED</code> not to be created.
         * You must be consistent when using this flag to use the setting the database was
         * created with.  If this is set, {@link #setLocale} will do nothing.
         */
        const Int32 NO_LOCALIZED_COLLATORS = 0x00000010;  // update native code if changing

        /**
         * Open flag: Flag for {@link #openDatabase} to create the database file if it does not
         * already exist.
         */
        const Int32 CREATE_IF_NECESSARY = 0x10000000;     // update native code if changing

        /**
         * Open flag: Flag for {@link #openDatabase} to open the database file with
         * write-ahead logging enabled by default.  Using this flag is more efficient
         * than calling {@link #enableWriteAheadLogging}.
         *
         * Write-ahead logging cannot be used with read-only databases so the value of
         * this flag is ignored if the database is opened read-only.
         *
         * @see #enableWriteAheadLogging
         */
        const Int32 ENABLE_WRITE_AHEAD_LOGGING = 0x20000000;

        /**
         * Absolute max value that can be set by {@link #setMaxSqlCacheSize(int)}.
         *
         * Each prepared-statement is between 1K - 6K, depending on the complexity of the
         * SQL statement & schema.  A large SQL cache may use a significant amount of memory.
         */
        const Int32 MAX_SQL_CACHE_SIZE = 100;

        /**
         * Control whether or not the SQLiteDatabase is made thread-safe by using locks
         * around critical sections. This is pretty expensive, so if you know that your
         * DB will only be used by a single thread then you should set this to false.
         * The default is true.
         * @param lockingEnabled set to true to enable locks, false otherwise
         *
         * @deprecated This method now does nothing.  Do not use.
         */
        //@Deprecated
        SetLockingEnabled(
            [in] Boolean lockingEnabled);

        /**
         * Begins a transaction in EXCLUSIVE mode.
         * <p>
         * Transactions can be nested.
         * When the outer transaction is ended all of
         * the work done in that transaction and all of the nested transactions will be committed or
         * rolled back. The changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
         * </p>
         * <p>Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransaction();
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         */
        BeginTransaction();

        /**
         * Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
         * the outer transaction is ended all of the work done in that transaction
         * and all of the nested transactions will be committed or rolled back. The
         * changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they
         * will be committed.
         * <p>
         * Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransactionNonExclusive();
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         */
        BeginTransactionNonExclusive();

        /**
         * Begins a transaction in EXCLUSIVE mode.
         * <p>
         * Transactions can be nested.
         * When the outer transaction is ended all of
         * the work done in that transaction and all of the nested transactions will be committed or
         * rolled back. The changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
         * </p>
         * <p>Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransactionWithListener(listener);
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         *
         * @param transactionListener listener that should be notified when the transaction begins,
         * commits, or is rolled back, either explicitly or by a call to
         * {@link #yieldIfContendedSafely}.
         */
        BeginTransactionWithListener(
            [in] ISQLiteTransactionListener* transactionListener);

        /**
         * Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
         * the outer transaction is ended all of the work done in that transaction
         * and all of the nested transactions will be committed or rolled back. The
         * changes will be rolled back if any transaction is ended without being
         * marked as clean (by calling setTransactionSuccessful). Otherwise they
         * will be committed.
         * <p>
         * Here is the standard idiom for transactions:
         *
         * <pre>
         *   db.beginTransactionWithListenerNonExclusive(listener);
         *   try {
         *     ...
         *     db.setTransactionSuccessful();
         *   } finally {
         *     db.endTransaction();
         *   }
         * </pre>
         *
         * @param transactionListener listener that should be notified when the
         *            transaction begins, commits, or is rolled back, either
         *            explicitly or by a call to {@link #yieldIfContendedSafely}.
         */
        BeginTransactionWithListenerNonExclusive(
            [in] ISQLiteTransactionListener* transactionListener);

        /**
         * End a transaction. See beginTransaction for notes about how to use this and when transactions
         * are committed and rolled back.
         */
        EndTransaction();

        /**
         * Marks the current transaction as successful. Do not do any more database work between
         * calling this and calling endTransaction. Do as little non-database work as possible in that
         * situation too. If any errors are encountered between this and endTransaction the transaction
         * will still be committed.
         *
         * @throws IllegalStateException if the current thread is not in a transaction or the
         * transaction is already marked as successful.
         */
        SetTransactionSuccessful();

        /**
         * Returns true if the current thread has a transaction pending.
         *
         * @return True if the current thread is in a transaction.
         */
        InTransaction(
            [out] Boolean* result);

        /**
         * Returns true if the current thread is holding an active connection to the database.
         * <p>
         * The name of this method comes from a time when having an active connection
         * to the database meant that the thread was holding an actual lock on the
         * database.  Nowadays, there is no longer a true "database lock" although threads
         * may block if they cannot acquire a database connection to perform a
         * particular operation.
         * </p>
         *
         * @return True if the current thread is holding an active connection to the database.
         */
        IsDbLockedByCurrentThread(
            [out] Boolean* isLocked);

        /**
         * Always returns false.
         * <p>
         * There is no longer the concept of a database lock, so this method always returns false.
         * </p>
         *
         * @return False.
         * @deprecated Always returns false.  Do not use this method.
         */
        //@Deprecated
        IsDbLockedByOtherThreads(
            [out] Boolean* isLocked);

        /**
         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
         * successful so far. Do not call setTransactionSuccessful before calling this. When this
         * returns a new transaction will have been created but not marked as successful.
         * @return true if the transaction was yielded
         * @deprecated if the db is locked more than once (becuase of nested transactions) then the lock
         *   will not be yielded. Use yieldIfContendedSafely instead.
         */
        //@Deprecated
        YieldIfContended(
            [out] Boolean* isYielded);

        /**
         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
         * successful so far. Do not call setTransactionSuccessful before calling this. When this
         * returns a new transaction will have been created but not marked as successful. This assumes
         * that there are no nested transactions (beginTransaction has only been called once) and will
         * throw an exception if that is not the case.
         * @return true if the transaction was yielded
         */
        YieldIfContendedSafely(
            [out] Boolean* isYielded);

        /**
         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
         * successful so far. Do not call setTransactionSuccessful before calling this. When this
         * returns a new transaction will have been created but not marked as successful. This assumes
         * that there are no nested transactions (beginTransaction has only been called once) and will
         * throw an exception if that is not the case.
         * @param sleepAfterYieldDelay if > 0, sleep this long before starting a new transaction if
         *   the lock was actually yielded. This will allow other background threads to make some
         *   more progress than they would if we started the transaction immediately.
         * @return true if the transaction was yielded
         */
        YieldIfContendedSafely(
            [in] Int64 sleepAfterYieldDelay,
            [out] Boolean* isYielded);

        /**
         * Deprecated.
         * @deprecated This method no longer serves any useful purpose and has been deprecated.
         */
        //@Deprecated
        GetSyncedTables(
            [out] IMap** tables);

        /**
         * Reopens the database in read-write mode.
         * If the database is already read-write, does nothing.
         *
         * @throws SQLiteException if the database could not be reopened as requested, in which
         * case it remains open in read only mode.
         * @throws IllegalStateException if the database is not open.
         *
         * @see #isReadOnly()
         * @hide
         */
        ReopenReadWrite();

        /**
         * Gets the database version.
         *
         * @return the database version
         */
        GetVersion(
            [out] Int32* versions);

        /**
         * Sets the database version.
         *
         * @param version the new database version
         */
        SetVersion(
            [in] Int32 versions);

        /**
         * Returns the maximum size the database may grow to.
         *
         * @return the new maximum database size
         */
        GetMaximumSize(
            [out] Int64* numBytes);

        /**
         * Sets the maximum size the database will grow to. The maximum size cannot
         * be set below the current size.
         *
         * @param numBytes the maximum database size, in bytes
         * @return the new maximum database size
         */
        SetMaximumSize(
            [in] Int64 numBytes,
            [out] Int64* maxSize);

        /**
         * Returns the current database page size, in bytes.
         *
         * @return the database page size, in bytes
         */
        GetPageSize(
            [out] Int64* numBytes);

        /**
         * Sets the database page size. The page size must be a power of two. This
         * method does not work if any data has been written to the database file,
         * and must be called right after the database has been created.
         *
         * @param numBytes the database page size, in bytes
         */
        SetPageSize(
            [in] Int64 numBytes);

        /**
         * Mark this table as syncable. When an update occurs in this table the
         * _sync_dirty field will be set to ensure proper syncing operation.
         *
         * @param table the table to mark as syncable
         * @param deletedTable The deleted table that corresponds to the
         *          syncable table
         * @deprecated This method no longer serves any useful purpose and has been deprecated.
         */
        //@Deprecated
        MarkTableSyncable(
            [in] String table,
            [in] String deletedTable);

        /**
         * Mark this table as syncable, with the _sync_dirty residing in another
         * table. When an update occurs in this table the _sync_dirty field of the
         * row in updateTable with the _id in foreignKey will be set to
         * ensure proper syncing operation.
         *
         * @param table an update on this table will trigger a sync time removal
         * @param foreignKey this is the column in table whose value is an _id in
         *          updateTable
         * @param updateTable this is the table that will have its _sync_dirty
         * @deprecated This method no longer serves any useful purpose and has been deprecated.
         */
        //@Deprecated
        MarkTableSyncable(
            [in] String table,
            [in] String foreignKey,
            [in] String updateTable);

        /**
         * Compiles an SQL statement into a reusable pre-compiled statement object.
         * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
         * statement and fill in those values with {@link SQLiteProgram#bindString}
         * and {@link SQLiteProgram#bindLong} each time you want to run the
         * statement. Statements may not return result sets larger than 1x1.
         *<p>
         * No two threads should be using the same {@link SQLiteStatement} at the same time.
         *
         * @param sql The raw SQL statement, may contain ? for unknown values to be
         *            bound later.
         * @return A pre-compiled {@link SQLiteStatement} object. Note that
         * {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
         */
        CompileStatement(
            [in] String sql,
            [out] ISQLiteStatement** statement);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        Query(
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         * return all columns, which is discouraged to prevent reading
         * data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         * SQL WHERE clause (excluding the WHERE itself). Passing null
         * will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         * replaced by the values from selectionArgs, in order that they
         * appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         * GROUP BY clause (excluding the GROUP BY itself). Passing null
         * will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         * if row grouping is being used, formatted as an SQL HAVING
         * clause (excluding the HAVING itself). Passing null will cause
         * all row groups to be included, and is required when row
         * grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         * (excluding the ORDER BY itself). Passing null will use the
         * default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then {@link OperationCanceledException} will be thrown
         * when the query is executed.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        Query(
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Query the given table, returning a {@link Cursor} over the result set.
         *
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        Query(
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [out] ICursor** cursor);

        /**
         * Query the given table, returning a {@link Cursor} over the result set.
         *
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        Query(
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        QueryWithFactory(
            [in] ISQLiteDatabaseCursorFactory* cursorFactory,
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [out] ICursor** cursor);

        /**
         * Query the given URL, returning a {@link Cursor} over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param distinct true if you want each row to be unique, false otherwise.
         * @param table The table name to compile the query against.
         * @param columns A list of which columns to return. Passing null will
         *            return all columns, which is discouraged to prevent reading
         *            data from storage that isn't going to be used.
         * @param selection A filter declaring which rows to return, formatted as an
         *            SQL WHERE clause (excluding the WHERE itself). Passing null
         *            will return all rows for the given table.
         * @param selectionArgs You may include ?s in selection, which will be
         *         replaced by the values from selectionArgs, in order that they
         *         appear in the selection. The values will be bound as Strings.
         * @param groupBy A filter declaring how to group rows, formatted as an SQL
         *            GROUP BY clause (excluding the GROUP BY itself). Passing null
         *            will cause the rows to not be grouped.
         * @param having A filter declare which row groups to include in the cursor,
         *            if row grouping is being used, formatted as an SQL HAVING
         *            clause (excluding the HAVING itself). Passing null will cause
         *            all row groups to be included, and is required when row
         *            grouping is not being used.
         * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
         *            (excluding the ORDER BY itself). Passing null will use the
         *            default sort order, which may be unordered.
         * @param limit Limits the number of rows returned by the query,
         *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then {@link OperationCanceledException} will be thrown
         * when the query is executed.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         * @see Cursor
         */
        QueryWithFactory(
            [in] ISQLiteDatabaseCursorFactory* cursorFactory,
            [in] Boolean distinct,
            [in] String table,
            [in] ArrayOf<String>* columns,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String groupBy,
            [in] String having,
            [in] String orderBy,
            [in] String limit,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a {@link Cursor} over the result set.
         *
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQuery(
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a {@link Cursor} over the result set.
         *
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then {@link OperationCanceledException} will be thrown
         * when the query is executed.
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQuery(
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a cursor over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param sql the SQL query. The SQL string must not be ; terminated
         * @param selectionArgs You may include ?s in where clause in the query,
         *     which will be replaced by the values from selectionArgs. The
         *     values will be bound as Strings.
         * @param editTable the name of the first table, which is editable
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQueryWithFactory(
            [in] ISQLiteDatabaseCursorFactory* cursorFactory,
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [in] String editTable,
            [out] ICursor** cursor);

        /**
         * Runs the provided SQL and returns a cursor over the result set.
         *
         * @param cursorFactory the cursor factory to use, or null for the default factory
         * @param sql the SQL query. The SQL string must not be ; terminated 855
         * @param selectionArgs You may include ?s in where clause in the query,
         * which will be replaced by the values from selectionArgs. The
         * values will be bound as Strings.
         * @param editTable the name of the first table, which is editable
         * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
         * If the operation is canceled, then {@link OperationCanceledException} will be thrown
         * when the query is executed.   862
         * @return A {@link Cursor} object, which is positioned before the first entry. Note that
         * {@link Cursor}s are not synchronized, see the documentation for more details.
         */
        RawQueryWithFactory(
            [in] ISQLiteDatabaseCursorFactory* cursorFactory,
            [in] String sql,
            [in] ArrayOf<String>* selectionArgs,
            [in] String editTable,
            [in] ICancellationSignal* cancellationSignal,
            [out] ICursor** cursor);

        /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        Insert(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* values,
            [out] Int64* value);

        /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @throws SQLException
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        InsertOrThrow(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* values,
            [out] Int64* value);

        /**
         * Convenience method for replacing a row in the database.
         *
         * @param table the table in which to replace the row
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for
         *   the row.
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        Replace(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [out] Int64* value);

        /**
         * Convenience method for replacing a row in the database.
         *
         * @param table the table in which to replace the row
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for
         *   the row. The key
         * @throws SQLException
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        ReplaceOrThrow(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [out] Int64* value);

        /**
         * General method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>initialValues</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>initialValues</code> is empty.
         * @param initialValues this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @param conflictAlgorithm for insert conflict resolver
         * @return the row ID of the newly inserted row
         * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
         * {@link #CONFLICT_IGNORE}
         * OR -1 if any error
         */
        InsertWithOnConflict(
            [in] String table,
            [in] String nullColumnHack,
            [in] IContentValues* initialValues,
            [in] Int32 conflictAlgorithm,
            [out] Int64* value);

        /**
         * Convenience method for deleting rows in the database.
         *
         * @param table the table to delete from
         * @param whereClause the optional WHERE clause to apply when deleting.
         *            Passing null will delete all rows.
         * @param whereArgs You may include ?s in the where clause, which
         *            will be replaced by the values from whereArgs. The values
         *            will be bound as Strings.
         * @return the number of rows affected if a whereClause is passed in, 0
         *         otherwise. To remove all rows and get a count pass "1" as the
         *         whereClause.
         */
        Delete(
            [in] String table,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [out] Int32* value);

        /**
         * Convenience method for updating rows in the database.
         *
         * @param table the table to update in
         * @param values a map from column names to new column values. null is a
         *            valid value that will be translated to NULL.
         * @param whereClause the optional WHERE clause to apply when updating.
         *            Passing null will update all rows.
         * @param whereArgs You may include ?s in the where clause, which
         *            will be replaced by the values from whereArgs. The values
         *            will be bound as Strings.
         * @return the number of rows affected
         */
        Update(
            [in] String table,
            [in] IContentValues* values,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [out] Int32* value);

        /**
         * Convenience method for updating rows in the database.
         *
         * @param table the table to update in
         * @param values a map from column names to new column values. null is a
         *            valid value that will be translated to NULL.
         * @param whereClause the optional WHERE clause to apply when updating.
         *            Passing null will update all rows.
         * @param whereArgs You may include ?s in the where clause, which
         *            will be replaced by the values from whereArgs. The values
         *            will be bound as Strings.
         * @param conflictAlgorithm for update conflict resolver
         * @return the number of rows affected
         */
        UpdateWithOnConflict(
            [in] String table,
            [in] IContentValues* values,
            [in] String whereClause,
            [in] ArrayOf<String>* whereArgs,
            [in] Int32 conflictAlgorithm,
            [out] Int32* value);

        /**
         * Execute a single SQL statement that is NOT a SELECT
         * or any other SQL statement that returns data.
         * <p>
         * It has no means to return any data (such as the number of affected rows).
         * Instead, you're encouraged to use {@link #insert(String, String, ContentValues)},
         * {@link #update(String, ContentValues, String, String[])}, et al, when possible.
         * </p>
         * <p>
         * When using {@link #enableWriteAheadLogging()}, journal_mode is
         * automatically managed by this class. So, do not set journal_mode
         * using "PRAGMA journal_mode'<value>" statement if your app is using
         * {@link #enableWriteAheadLogging()}
         * </p>
         *
         * @param sql the SQL statement to be executed. Multiple statements separated by semicolons are
         * not supported.
         * @throws SQLException if the SQL string is invalid
         */
        ExecSQL(
            [in] String sql);

        /**
         * Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.
         * <p>
         * For INSERT statements, use any of the following instead.
         * <ul>
         *   <li>{@link #insert(String, String, ContentValues)}</li>
         *   <li>{@link #insertOrThrow(String, String, ContentValues)}</li>
         *   <li>{@link #insertWithOnConflict(String, String, ContentValues, int)}</li>
         * </ul>
         * <p>
         * For UPDATE statements, use any of the following instead.
         * <ul>
         *   <li>{@link #update(String, ContentValues, String, String[])}</li>
         *   <li>{@link #updateWithOnConflict(String, ContentValues, String, String[], int)}</li>
         * </ul>
         * <p>
         * For DELETE statements, use any of the following instead.
         * <ul>
         *   <li>{@link #delete(String, String, String[])}</li>
         * </ul>
         * <p>
         * For example, the following are good candidates for using this method:
         * <ul>
         *   <li>ALTER TABLE</li>
         *   <li>CREATE or DROP table / trigger / view / index / virtual table</li>
         *   <li>REINDEX</li>
         *   <li>RELEASE</li>
         *   <li>SAVEPOINT</li>
         *   <li>PRAGMA that returns no data</li>
         * </ul>
         * </p>
         * <p>
         * When using {@link #enableWriteAheadLogging()}, journal_mode is
         * automatically managed by this class. So, do not set journal_mode
         * using "PRAGMA journal_mode'<value>" statement if your app is using
         * {@link #enableWriteAheadLogging()}
         * </p>
         *
         * @param sql the SQL statement to be executed. Multiple statements separated by semicolons are
         * not supported.
         * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
         * @throws SQLException if the SQL string is invalid
         */
        ExecSQL(
            [in] String sql,
            [in] ArrayOf<IInterface*>* bindArgs);

        /**
         * Returns true if the database is opened as read only.
         *
         * @return True if database is opened as read only.
         */
        IsReadOnly(
            [out] Boolean* isReadOnlyed);

        /**
         * Returns true if the database is in-memory db.
         *
         * @return True if the database is in-memory.
         * @hide
         */
        IsInMemoryDatabase(
            [out] Boolean* result);

        /**
         * Returns true if the database is currently open.
         *
         * @return True if the database is currently open (has not been closed).
         */
        IsOpen(
            [out] Boolean* isOpened);

        /**
         * Returns true if the new version code is greater than the current database version.
         *
         * @param newVersion The new version code.
         * @return True if the new version code is greater than the current database version.
         */
        NeedUpgrade(
            [in] Int32 newVersion,
            [out] Boolean* result);

        /**
         * Gets the path to the database file.
         *
         * @return The path to the database file.
         */
        GetPath(
            [out] String* path);

        /**
         * Sets the locale for this database.  Does nothing if this database has
         * the {@link #NO_LOCALIZED_COLLATORS} flag set or was opened read only.
         *
         * @param locale The new locale.
         *
         * @throws SQLException if the locale could not be set.  The most common reason
         * for this is that there is no collator available for the locale you requested.
         * In this case the database remains unchanged.
         */
        SetLocale(
            [in] ILocale* locale);

        /**
         * Sets the maximum size of the prepared-statement cache for this database.
         * (size of the cache = number of compiled-sql-statements stored in the cache).
         *<p>
         * Maximum cache size can ONLY be increased from its current size (default = 10).
         * If this method is called with smaller size than the current maximum value,
         * then IllegalStateException is thrown.
         *<p>
         * This method is thread-safe.
         *
         * @param cacheSize the size of the cache. can be (0 to {@link #MAX_SQL_CACHE_SIZE})
         * @throws IllegalStateException if input cacheSize > {@link #MAX_SQL_CACHE_SIZE}.
         */
        SetMaxSqlCacheSize(
            [in] Int32 cacheSize);

        /**
         * Sets whether foreign key constraints are enabled for the database.
         * <p>
         * By default, foreign key constraints are not enforced by the database.
         * This method allows an application to enable foreign key constraints.
         * It must be called each time the database is opened to ensure that foreign
         * key constraints are enabled for the session.
         * </p><p>
         * A good time to call this method is right after calling {@link #openOrCreateDatabase}
         * or in the {@link SQLiteOpenHelper#onConfigure} callback.
         * </p><p>
         * When foreign key constraints are disabled, the database does not check whether
         * changes to the database will violate foreign key constraints.  Likewise, when
         * foreign key constraints are disabled, the database will not execute cascade
         * delete or update triggers.  As a result, it is possible for the database
         * state to become inconsistent.  To perform a database integrity check,
         * call {@link #isDatabaseIntegrityOk}.
         * </p><p>
         * This method must not be called while a transaction is in progress.
         * </p><p>
         * See also <a href="http://sqlite.org/foreignkeys.html">SQLite Foreign Key Constraints</a>
         * for more details about foreign key constraint support.
         * </p>
         *
         * @param enable True to enable foreign key constraints, false to disable them.
         *
         * @throws IllegalStateException if the are transactions is in progress
         * when this method is called.
         */
        SetForeignKeyConstraintsEnabled(
            [in] Boolean enabled);

        /**
         * This method enables parallel execution of queries from multiple threads on the
         * same database.  It does this by opening multiple connections to the database
         * and using a different database connection for each query.  The database
         * journal mode is also changed to enable writes to proceed concurrently with reads.
         * <p>
         * When write-ahead logging is not enabled (the default), it is not possible for
         * reads and writes to occur on the database at the same time.  Before modifying the
         * database, the writer implicitly acquires an exclusive lock on the database which
         * prevents readers from accessing the database until the write is completed.
         * </p><p>
         * In contrast, when write-ahead logging is enabled (by calling this method), write
         * operations occur in a separate log file which allows reads to proceed concurrently.
         * While a write is in progress, readers on other threads will perceive the state
         * of the database as it was before the write began.  When the write completes, readers
         * on other threads will then perceive the new state of the database.
         * </p><p>
         * It is a good idea to enable write-ahead logging whenever a database will be
         * concurrently accessed and modified by multiple threads at the same time.
         * However, write-ahead logging uses significantly more memory than ordinary
         * journaling because there are multiple connections to the same database.
         * So if a database will only be used by a single thread, or if optimizing
         * concurrency is not very important, then write-ahead logging should be disabled.
         * </p><p>
         * After calling this method, execution of queries in parallel is enabled as long as
         * the database remains open.  To disable execution of queries in parallel, either
         * call {@link #disableWriteAheadLogging} or close the database and reopen it.
         * </p><p>
         * The maximum number of connections used to execute queries in parallel is
         * dependent upon the device memory and possibly other properties.
         * </p><p>
         * If a query is part of a transaction, then it is executed on the same database handle the
         * transaction was begun.
         * </p><p>
         * Writers should use {@link #beginTransactionNonExclusive()} or
         * {@link #beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)}
         * to start a transaction.  Non-exclusive mode allows database file to be in readable
         * by other threads executing queries.
         * </p><p>
         * If the database has any attached databases, then execution of queries in parallel is NOT
         * possible.  Likewise, write-ahead logging is not supported for read-only databases
         * or memory databases.  In such cases, {@link #enableWriteAheadLogging} returns false.
         * </p><p>
         * The best way to enable write-ahead logging is to pass the
         * {@link #ENABLE_WRITE_AHEAD_LOGGING} flag to {@link #openDatabase}.  This is
         * more efficient than calling {@link #enableWriteAheadLogging}.
         * <code><pre>
         *     SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory,
         *             SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING,
         *             myDatabaseErrorHandler);
         *     db.enableWriteAheadLogging();
         * </pre></code>
         * </p><p>
         * Another way to enable write-ahead logging is to call {@link #enableWriteAheadLogging}
         * after opening the database.
         * <code><pre>
         *     SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory,
         *             SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler);
         *     db.enableWriteAheadLogging();
         * </pre></code>
         * </p><p>
         * See also <a href="http://sqlite.org/wal.html">SQLite Write-Ahead Logging</a> for
         * more details about how write-ahead logging works.
         * </p>
         *
         * @return True if write-ahead logging is enabled.
         *
         * @throws IllegalStateException if there are transactions in progress at the
         * time this method is called.  WAL mode can only be changed when there are no
         * transactions in progress.
         *
         * @see #ENABLE_WRITE_AHEAD_LOGGING
         * @see #disableWriteAheadLogging
         */
        EnableWriteAheadLogging(
            [out] Boolean* result);

        /**
         * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
         *
         * @throws IllegalStateException if there are transactions in progress at the
         * time this method is called.  WAL mode can only be changed when there are no
         * transactions in progress.
         *
         * @see #enableWriteAheadLogging
         */
        DisableWriteAheadLogging();

        /**
         * Returns true if write-ahead logging has been enabled for this database.
         *
         * @return True if write-ahead logging has been enabled for this database.
         *
         * @see #enableWriteAheadLogging
         * @see #ENABLE_WRITE_AHEAD_LOGGING
         */
        IsWriteAheadLoggingEnabled(
            [out] Boolean* result);

        /**
         * Returns list of full pathnames of all attached databases including the main database
         * by executing 'pragma database_list' on the database.
         *
         * @return ArrayList of pairs of (database name, database file path) or null if the database
         * is not open.
         */
        GetAttachedDbs(
            [out] IMap** dbs);

        /**
         * Runs 'pragma integrity_check' on the given database (and all the attached databases)
         * and returns true if the given database (and all its attached databases) pass integrity_check,
         * false otherwise.
         *<p>
         * If the result is false, then this method logs the errors reported by the integrity_check
         * command execution.
         *<p>
         * Note that 'pragma integrity_check' on a database can take a long time.
         *
         * @return true if the given database (and all its attached databases) pass integrity_check,
         * false otherwise.
         */
        IsDatabaseIntegrityOk(
            [out] Boolean* result);
    }

    interface ISQLiteDatabaseHelper {
        /**
         * Attempts to release memory that SQLite holds but does not require to
         * operate properly. Typically this memory will come from the page cache.
         *
         * @return the number of bytes actually released
         */
        ReleaseMemory(
            [out] Int32* result);

        /**
         * Open the database according to the flags {@link #OPEN_READWRITE}
         * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
         *
         * <p>Sets the locale of the database to the  the system's current locale.
         * Call {@link #setLocale} if you would like something else.</p>
         *
         * @param path to database file to open and/or create
         * @param factory an optional factory class that is called to instantiate a
         *            cursor when query is called, or null for default
         * @param flags to control database access mode
         * @return the newly opened database
         * @throws SQLiteException if the database cannot be opened
         */
        OpenDatabase(
            [in] String path,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [in] Int32 flags,
            [out] ISQLiteDatabase** result);

        /**
         * Open the database according to the flags {@link #OPEN_READWRITE}
         * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
         *
         * <p>Sets the locale of the database to the  the system's current locale.
         * Call {@link #setLocale} if you would like something else.</p>
         *
         * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
         * used to handle corruption when sqlite reports database corruption.</p>
         *
         * @param path to database file to open and/or create
         * @param factory an optional factory class that is called to instantiate a
         *            cursor when query is called, or null for default
         * @param flags to control database access mode
         * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
         * when sqlite reports database corruption
         * @return the newly opened database
         * @throws SQLiteException if the database cannot be opened
         */
        OpenDatabase(
            [in] String path,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [in] Int32 flags,
            [in] IDatabaseErrorHandler* errorHandler,
            [out] ISQLiteDatabase** result);

        /**
         * Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).
         */
        OpenOrCreateDatabase(
            [in] IFile* file,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [out] ISQLiteDatabase** result);

        /**
         * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
         */
        OpenOrCreateDatabase(
            [in] String path,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [out] ISQLiteDatabase** result);

        /**
         * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler).
         */
        OpenOrCreateDatabase(
            [in] String path,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [in] IDatabaseErrorHandler* errorHandler,
            [out] ISQLiteDatabase** result);

        /**
         * Deletes a database including its journal file and other auxiliary files
         * that may have been created by the database engine.
         *
         * @param file The database file path.
         * @return True if the database was successfully deleted.
         */
        DeleteDatabase(
            [in] IFile* file,
            [out] Boolean* result);

        /**
         * Create a memory backed SQLite database.  Its contents will be destroyed
         * when the database is closed.
         *
         * <p>Sets the locale of the database to the  the system's current locale.
         * Call {@link #setLocale} if you would like something else.</p>
         *
         * @param factory an optional factory class that is called to instantiate a
         *            cursor when query is called
         * @return a SQLiteDatabase object, or null if the database can't be created
         */
        Create(
            [in] ISQLiteDatabaseCursorFactory* factory,
            [out] ISQLiteDatabase** result);

        /**
         * Finds the name of the first table, which is editable.
         *
         * @param tables a list of tables
         * @return the first table listed
         */
        FindEditTable(
            [in] String tables,
            [out] String* str);
    }

    } // namespace Sqlite
    } // namespace Database
    } // namespace Droid
    } // namespace Elastos
}
