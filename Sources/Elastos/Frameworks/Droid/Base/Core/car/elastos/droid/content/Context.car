
module
{
    using interface Elastos.Core.ICharSequence;
    //using interface Elastos.Core.IClassLoader;
    using interface Elastos.IO.IFile;
    using interface Elastos.IO.IFileInputStream;
    using interface Elastos.IO.IFileOutputStream;
    using interface Elastos.IO.IInputStream;

    interface Elastos.Droid.Content.Pm.IPackageManager;
    interface Elastos.Droid.Content.Pm.IApplicationInfo;
    interface Elastos.Droid.Content.Res.IResourcesTheme;
    interface Elastos.Droid.Content.Res.ITypedArray;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Content.Res.IConfiguration;
    interface Elastos.Droid.Content.Res.IAssetManager;
    interface Elastos.Droid.Content.IContentResolver;
    interface Elastos.Droid.Content.ISharedPreferences;
    interface Elastos.Droid.Content.IBroadcastReceiver;
    interface Elastos.Droid.Content.IIntent;
    interface Elastos.Droid.Content.IComponentName;
    interface Elastos.Droid.Content.IServiceConnection;
    interface Elastos.Droid.Content.IIntentSender;
    interface Elastos.Droid.Content.IIntentFilter;
    interface Elastos.Droid.Utility.IAttributeSet;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Os.ILooper;
    interface Elastos.Droid.Os.IUserHandle;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Database.Sqlite.ISQLiteDatabase;
    interface Elastos.Droid.Database.Sqlite.ISQLiteDatabaseCursorFactory;
    interface Elastos.Droid.Database.IDatabaseErrorHandler;
    interface Elastos.Droid.Graphics.Drawable.IDrawable;
    interface Elastos.Droid.Graphics.IBitmap;
    interface Elastos.Droid.View.IDisplay;
    interface Elastos.Droid.View.IDisplayAdjustments;

    namespace Elastos {
    namespace Droid {
    namespace Content {

    /**
     * Interface to global information about an application environment.  This is
     * an abstract class whose implementation is provided by
     * the Android system.  It
     * allows access to application-specific resources and classes, as well as
     * up-calls for application-level operations such as launching activities,
     * broadcasting and receiving intents, etc.
     */
    [deprecated]
    interface IContext {
        /**
         * File creation mode: the default mode, where the created file can only
         * be accessed by the calling application (or all applications sharing the
         * same user ID).
         * @see #MODE_WORLD_READABLE
         * @see #MODE_WORLD_WRITEABLE
         */
        const Int32 MODE_PRIVATE = 0x0000;

        /**
         * @deprecated Creating world-readable files is very dangerous, and likely
         * to cause security holes in applications.  It is strongly discouraged;
         * instead, applications should use more formal mechanism for interactions
         * such as ContentProvider,BroadcastReceiver, and
         * android.app.Service.  There are no guarantees that this
         * access mode will remain on a file, such as when it goes through a
         * backup and restore.
         * File creation mode: allow all other applications to have read access
         * to the created file.
         *
         * @sa ContentProvider
         * @sa BroadcastReceiver
         * @sa android.app.Service
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_WRITEABLE
         */
        const Int32 MODE_WORLD_READABLE = 0x0001;

        /**
         * @deprecated Creating world-writable files is very dangerous, and likely
         * to cause security holes in applications.  It is strongly discouraged;
         * instead, applications should use more formal mechanism for interactions
         * such as ContentProvider, BroadcastReceiver, and
         * android.app.Service.  There are no guarantees that this
         * access mode will remain on a file, such as when it goes through a
         * backup and restore.
         *
         * @sa ContentProvider
         * @sa BroadcastReceiver
         * @sa android.app.Service
         * File creation mode: allow all other applications to have write access
         * to the created file.
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_READABLE
         */
        const Int32 MODE_WORLD_WRITEABLE = 0x0002;

        /**
         * File creation mode: for use with #openFileOutput, if the file
         * already exists then write data to the end of the existing file
         * instead of erasing it.
         *
         * @sa #openFileOutput
         * @see #openFileOutput
         */
        const Int32 MODE_APPEND = 0x8000;

        /**
         * SharedPreference loading flag: when set, the file on disk will
         * be checked for modification even if the shared preferences
         * instance is already loaded in this process.  This behavior is
         * sometimes desired in cases where the application has multiple
         * processes, all writing to the same SharedPreferences file.
         * Generally there are better forms of communication between
         * processes, though.
         *
         * <p>This was the legacy (but undocumented) behavior in and
         * before Gingerbread (Android 2.3) and this flag is implied when
         * targetting such releases.  For applications targetting SDK
         * versions <em>greater than</em> Android 2.3, this flag must be
         * explicitly set if desired.
         *
         * @see #getSharedPreferences
         */
        const Int32 MODE_MULTI_PROCESS = 0x0004;

        /**
         * Database open flag: when set, the database is opened with write-ahead
         * logging enabled by default.
         *
         * @see #openOrCreateDatabase(String, int, CursorFactory)
         * @see #openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
         * @see SQLiteDatabase#enableWriteAheadLogging
         */
        const Int32 MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008;

        /**
         * Flag for #bindService: automatically create the service as long
         * as the binding exists.  Note that while this will create the service,
         * its android.app.Service#onStartCommand
         * method will still only be called due to an
         * explicit call to #startService.  Even without that, though,
         * this still provides you with access to the service object while the
         * service is created.
         *
         * @sa #bindService
         * @sa android.app.Service#onStartCommand
         * @sa #startService
         *
         * <p>Note that prior to android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH,
         * not supplying this flag would also impact how important the system
         * consider's the target service's process to be.  When set, the only way
         * for it to be raised was by binding from a service in which case it will
         * only be important when that activity is in the foreground.  Now to
         * achieve this behavior you must explicitly supply the new flag
         * #BIND_ADJUST_WITH_ACTIVITY.  For compatibility, old applications
         * that don't specify #BIND_AUTO_CREATE will automatically have
         * the flags #BIND_WAIVE_PRIORITY and
         * #BIND_ADJUST_WITH_ACTIVITY set for them in order to achieve
         * the same result.
         *
         * @sa android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH
         * @sa #BIND_ADJUST_WITH_ACTIVITY
         * @sa #BIND_AUTO_CREATE
         * @sa #BIND_WAIVE_PRIORITY
         * @sa #BIND_ADJUST_WITH_ACTIVITY
         */
        const Int32 BIND_AUTO_CREATE = 0x0001;

        /**
         * Flag for #bindService: include debugging help for mismatched
         * calls to unbind.  When this flag is set, the callstack of the following
         * #unbindService call is retained, to be printed if a later
         * incorrect unbind call is made.  Note that doing this requires retaining
         * information about the binding that was made for the lifetime of the app,
         * resulting in a leak -- this should only be used for debugging.
         *
         * @sa #bindService
         * @sa #unbindService
         */
        const Int32 BIND_DEBUG_UNBIND = 0x0002;

        /**
         * Flag for #bindService: don't allow this binding to raise
         * the target service's process to the foreground scheduling priority.
         * It will still be raised to at least the same memory priority
         * as the client (so that its process will not be killable in any
         * situation where the client is not killable), but for CPU scheduling
         * purposes it may be left in the background.  This only has an impact
         * in the situation where the binding client is a foreground process
         * and the target service is in a background process.
         *
         * @sa #bindService
         */
        const Int32 BIND_NOT_FOREGROUND = 0x0004;

        /**
         * Flag for #bindService: indicates that the client application
         * binding to this service considers the service to be more important than
         * the app itself.  When set, the platform will try to have the out of
         * memory killer kill the app before it kills the service it is bound to, though
         * this is not guaranteed to be the case.
         *
         * @sa #bindService
         */
        const Int32 BIND_ABOVE_CLIENT = 0x0008;

        /**
         * Flag for #bindService: allow the process hosting the bound
         * service to go through its normal memory management.  It will be
         * treated more like a running service, allowing the system to
         * (temporarily) expunge the process if low on memory or for some other
         * whim it may have, and being more aggressive about making it a candidate
         * to be killed (and restarted) if running for a long time.
         *
         * @sa #bindService
         */
        const Int32 BIND_ALLOW_OOM_MANAGEMENT = 0x0010;

        /**
         * Flag for #bindService: don't impact the scheduling or
         * memory management priority of the target service's hosting process.
         * Allows the service's process to be managed on the background LRU list
         * just like a regular application process in the background.
         *
         * @sa #bindService
         */
        const Int32 BIND_WAIVE_PRIORITY = 0x0020;

        /**
         * Flag for #bindService: this service is very important to
         * the client, so should be brought to the foreground process level
         * when the client is.  Normally a process can only be raised to the
         * visibility level by a client, even if that client is in the foreground.
         *
         * @sa #bindService
         */
        const Int32 BIND_IMPORTANT = 0x0040;

        /**
         * Flag for #bindService: If binding from an activity, allow the
         * target service's process importance to be raised based on whether the
         * activity is visible to the user, regardless whether another flag is
         * used to reduce the amount that the client process's overall importance
         * is used to impact it.
         *
         * @sa #bindService
         */
        const Int32 BIND_ADJUST_WITH_ACTIVITY = 0x0080;

        /**
         * @hide Flag for {@link #bindService}: Treat the binding as hosting
         * an activity, an unbinding as the activity going in the background.
         * That is, when unbinding, the process when empty will go on the activity
         * LRU list instead of the regular one, keeping it around more aggressively
         * than it otherwise would be.  This is intended for use with IMEs to try
         * to keep IME processes around for faster keyboard switching.
         */
        const Int32 BIND_TREAT_LIKE_ACTIVITY = 0x08000000;

        /**
         * @hide An idea that is not yet implemented.
         * Flag for #bindService: If binding from an activity, consider
         * this service to be visible like the binding activity is.  That is,
         * it will be treated as something more important to keep around than
         * invisible background activities.  This will impact the number of
         * recent activities the user can switch between without having them
         * restart.  There is no guarantee this will be respected, as the system
         * tries to balance such requests from one app vs. the importantance of
         * keeping other apps around.
         *
         * @sa #bindService
         */
        const Int32 BIND_VISIBLE = 0x10000000;

        /**
         * @hide
         * Flag for {@link #bindService}: Consider this binding to be causing the target
         * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes
         * away.
         */
        const Int32 BIND_SHOWING_UI = 0x20000000;


        /**
         * Flag for #bindService: Don't consider the bound service to be
         * visible, even if the caller is visible.
         *
         * @sa #bindService
         * @hide
         */
        const Int32 BIND_NOT_VISIBLE = 0x40000000;

        /**
         * Use with #getSystemService to retrieve a
         * android.os.PowerManager for controlling power management,
         * including "wake locks," which let you keep the device on while
         * you're running long tasks.
         *
         * @sa #getSystemService
         * @sa android.os.PowerManager
         */
        const String POWER_SERVICE = "power";

        /**
         * Use with #getSystemService to retrieve a
         * android.view.WindowManager for accessing the system's window
         * manager.
         *
         * @sa #getSystemService
         * @sa android.view.WindowManager
         *
         * @see #getSystemService
         * @see android.view.WindowManager
         */
        const String WINDOW_SERVICE = "window";

        /**
         * Use with #getSystemService to retrieve a
         *android.view.LayoutInflater for inflating layout resources in this
         * context.
         *
         * @sa #getSystemService
         * @sa android.view.LayoutInflater
         *
         * @see #getSystemService
         * @see android.view.LayoutInflater
         */
        const String LAYOUT_INFLATER_SERVICE = "layout_inflater";

        /**
         * Use with #getSystemService to retrieve a
         * android.accounts.AccountManager for receiving intents at a
         * time of your choosing.
         *
         * @sa #getSystemService
         * @sa android.accounts.AccountManager
         *
         * @see #getSystemService
         * @see android.accounts.AccountManager
         */
        const String ACCOUNT_SERVICE = "account";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.ActivityManager for interacting with the global
         * system state.
         *
         * @sa #getSystemService
         * @sa android.app.ActivityManager
         *
         * @see #getSystemService
         * @see android.app.ActivityManager
         */
        const String ACTIVITY_SERVICE = "activity";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.AlarmManager for receiving intents at a
         * time of your choosing.
         *
         * @sa #getSystemService
         * @sa android.app.AlarmManager
         *
         * @see #getSystemService
         * @see android.app.AlarmManager
         */
        const String ALARM_SERVICE = "alarm";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.NotificationManager for informing the user of
         * background events.
         *
         * @sa #getSystemService
         * @sa android.app.NotificationManager
         *
         * @see #getSystemService
         * @see android.app.NotificationManager
         */
        const String NOTIFICATION_SERVICE = "notification";

        /**
         * Use with #getSystemService to retrieve a
         * android.view.accessibility.AccessibilityManager for giving the user
         * feedback for UI events through the registered event listeners.
         *
         * @sa #getSystemService
         * @sa android.view.accessibility.AccessibilityManager
         * @see #getSystemService
         * @see android.view.accessibility.AccessibilityManager
         */
        const String ACCESSIBILITY_SERVICE = "accessibility";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.view.accessibility.CaptioningManager} for obtaining
         * captioning properties and listening for changes in captioning
         * preferences.
         *
         * @see #getSystemService
         * @see android.view.accessibility.CaptioningManager
         */
        const String CAPTIONING_SERVICE = "captioning";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.NotificationManager for controlling keyguard.
         *
         * @sa #getSystemService
         * @sa android.app.NotificationManager
         * @see #getSystemService
         * @see android.app.KeyguardManager
         */
        const String KEYGUARD_SERVICE = "keyguard";

        /**
         * Use with #getSystemService to retrieve a
         * android.location.LocationManager for controlling location
         * updates.
         *
         * @sa #getSystemService
         * @sa android.location.LocationManager
         *
         * @see #getSystemService
         * @see android.location.LocationManager
         */
        const String LOCATION_SERVICE = "location";

        /**
         * Use with #getSystemService to retrieve a
         * android.location.CountryDetector for detecting the country that
         * the user is in.
         *
         * @sa #getSystemService
         * @sa android.location.CountryDetector
         *
         * @hide
         */
        const String COUNTRY_DETECTOR = "country_detector";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.SearchManager for handling searches.
         *
         * @sa #getSystemService
         * @sa android.app.SearchManager
         * @see #getSystemService
         * @see android.app.SearchManager
         */
        const String SEARCH_SERVICE = "search";

        /**
         * Use with #getSystemService to retrieve a
         * android.hardware.SensorManager for accessing sensors.
         *
         * @sa #getSystemService
         * @sa android.hardware.SensorManager
         * @see #getSystemService
         * @see android.hardware.SensorManager
         */
        const String SENSOR_SERVICE = "sensor";

        /**
         * Use with #getSystemService to retrieve a
         * android.os.storage.StorageManager for accessing system storage
         * functions.
         *
         * @sa #getSystemService
         * @sa android.os.storage.StorageManager
         *
         * @see #getSystemService
         * @see android.os.storage.StorageManager
         */
        const String STORAGE_SERVICE = "storage";

        /**
         * Use with #getSystemService to retrieve a
         * com.android.server.WallpaperService for accessing wallpapers.
         *
         * @sa #getSystemService
         *
         * @see #getSystemService
         */
        const String WALLPAPER_SERVICE = "wallpaper";

        /**
         * Use with #getSystemService to retrieve a
         * android.os.Vibrator for interacting with the vibration hardware.
         *
         * @sa #getSystemService
         * @sa android.os.Vibrator
         * @see #getSystemService
         * @see android.os.Vibrator
         */
        const String VIBRATOR_SERVICE = "vibrator";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.StatusBarManager for interacting with the status bar.
         *
         * @sa #getSystemService
         * @sa android.app.StatusBarManager
         * @see #getSystemService
         * @see android.app.StatusBarManager
         * @hide
         */
        const String STATUS_BAR_SERVICE = "statusbar";

        /**
         * Use with #getSystemService to retrieve a
         * android.net.ConnectivityManager for handling management of
         * network connections.
         *
         * @sa #getSystemService
         * @sa android.net.ConnectivityManager
         *
         * @see #getSystemService
         * @see android.net.ConnectivityManager
         */
        const String CONNECTIVITY_SERVICE = "connectivity";

        /**
         * Use with #getSystemService to retrieve a
         * android.os.IUpdateLock for managing runtime sequences that
         * must not be interrupted by headless OTA application or similar.
         *
         * @sa #getSystemService
         * @sa android.os.IUpdateLock
         * @hide
         * @see #getSystemService
         * @see android.os.UpdateLock
         */
        const String UPDATE_LOCK_SERVICE = "updatelock";

        /**
         * Use with #getSystemService
         * android.net.NetworkManagementService for handling management of
         * system network services
         *
         * @sa #getSystemService
         * @sa android.net.NetworkManagementService
         *
         * @hide
         * @see #getSystemService
         * @see android.net.NetworkManagementService
         */
        const String NETWORKMANAGEMENT_SERVICE = "network_management";

        /** {@hide} */
        const String NETWORK_STATS_SERVICE = "netstats";

        /** {@hide} */
        const String NETWORK_POLICY_SERVICE = "netpolicy";

        /**
         * Use with #getSystemService
         * android.net.wifi.WifiManager for handling management of
         * Wi-Fi access.
         *
         * @sa #getSystemService
         * @sa android.net.wifi.WifiManager
         *
         * @see #getSystemService
         * @see android.net.wifi.WifiManager
         */
        const String WIFI_SERVICE = "wifi";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.net.wifi.passpoint.WifiPasspointManager} for handling management of
         * Wi-Fi passpoint access.
         *
         * @see #getSystemService
         * @see android.net.wifi.passpoint.WifiPasspointManager
         * @hide
         */
        const String WIFI_PASSPOINT_SERVICE = "wifipasspoint";

        /**
         * Use with #getSystemService to retrieve a
         * android.net.wifi.p2p.WifiP2pManager for handling management of
         * Wi-Fi peer-to-peer connections.
         *
         * @sa #getSystemService
         * @sa android.net.wifi.p2p.WifiP2pManager
         *
         * @see #getSystemService
         * @see android.net.wifi.p2p.WifiP2pManager
         */
        const String WIFI_P2P_SERVICE = "wifip2p";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.net.wifi.WifiScanner} for scanning the wifi universe
         *
         * @see #getSystemService
         * @see android.net.wifi.WifiScanner
         * @hide
         */
        //@SystemApi
        const String WIFI_SCANNING_SERVICE = "wifiscanner";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.net.wifi.RttManager} for ranging devices with wifi
         *
         * @see #getSystemService
         * @see android.net.wifi.RttManager
         * @hide
         */
        //@SystemApi
        const String WIFI_RTT_SERVICE = "rttmanager";

        /**
         * Use with #getSystemService to retrieve a
         * android.net.ethernet.EthernetManager for handling management of
         * Ethernet access.
         *
         * @sa #getSystemService
         * @sa android.net.ethernet.EthernetManager
         */
        const String ETHERNET_SERVICE = "ethernet";

        /**
         * Use with #getSystemService to retrieve a
         * android.net.nsd.NsdManager for handling management of network service
         * discovery
         *
         * @sa #getSystemService
         * @sa android.net.nsd.NsdManager
         *
         * @see #getSystemService
         * @see android.net.nsd.NsdManager
         */
        const String NSD_SERVICE = "servicediscovery";

        /**
         * Use with #getSystemService to retrieve a
         * android.media.AudioManager for handling management of volume,
         * ringer modes and audio routing.
         *
         * @sa #getSystemService
         * @sa android.media.AudioManager
         *
         * @see #getSystemService
         * @see android.media.AudioManager
         */
        const String AUDIO_SERVICE = "audio";

       /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.service.fingerprint.FingerprintManager} for handling management
         * of fingerprints.
         *
         * @see #getSystemService
         * @see android.app.FingerprintManager
         * @hide
         */
        const String FINGERPRINT_SERVICE = "fingerprint";

        /**
         * Use with #getSystemService to retrieve a
         * android.media.MediaRouter for controlling and managing
         * routing of media.
         *
         *
         * @sa #getSystemService
         * @sa android.media.MediaRouter
         * @see #getSystemService
         * @see android.media.MediaRouter
         */
        const String MEDIA_ROUTER_SERVICE = "media_router";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.media.session.MediaSessionManager} for managing media Sessions.
         *
         * @see #getSystemService
         * @see android.media.session.MediaSessionManager
         */
        const String MEDIA_SESSION_SERVICE = "media_session";

        /**
         * Use with #getSystemService to retrieve a
         * android.telephony.TelephonyManager for handling management the
         * telephony features of the device.
         *
         * @sa #getSystemService
         * @sa android.telephony.TelephonyManager
         *
         * @see #getSystemService
         * @see android.telephony.TelephonyManager
         */
        const String TELEPHONY_SERVICE = "phone";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.telecom.TelecomManager} to manage telecom-related features
         * of the device.
         *
         * @see #getSystemService
         * @see android.telecom.TelecomManager
         */
        const String TELECOM_SERVICE = "telecom";

        /**
         * Use with #getSystemService to retrieve a
         * android.text.ClipboardManager for accessing and modifying
         * the contents of the global clipboard.
         *
         * @sa #getSystemService
         * @sa android.text.ClipboardManager
         *
         * @see #getSystemService
         * @see android.text.ClipboardManager
         */
        const String CLIPBOARD_SERVICE = "clipboard";

        /**
         * Use with #getSystemService to retrieve a
         * android.view.inputmethod.InputMethodManager for accessing input
         * methods.
         *
         * @sa #getSystemService
         * @sa android.view.inputmethod.InputMethodManager
         *
         * @see #getSystemService
         */
        const String INPUT_METHOD_SERVICE = "input_method";

        /**
         * Use with #getSystemService to retrieve a
         * android.view.textservice.TextServicesManager for accessing
         * text services.
         *
         * @sa #getSystemService
         * @sa android.view.textservice.TextServicesManager
         *
         * @see #getSystemService
         */
        const String TEXT_SERVICES_MANAGER_SERVICE = "textservices";

        /**
         * Use with #getSystemService to retrieve a
         * android.appwidget.AppWidgetManager for accessing AppWidgets.
         *
         * @sa #getSystemService
         * @sa android.appwidget.AppWidgetManager
         *
         * @hide
         * @see #getSystemService
         */
        const String APPWIDGET_SERVICE = "appwidget";

        /**
         * Official published name of the (internal) voice interaction manager service.
         *
         * @hide
         * @see #getSystemService
         */
        const String VOICE_INTERACTION_MANAGER_SERVICE = "voiceinteraction";

        /**
         * Use with #getSystemService to retrieve an
         * android.app.backup.IBackupManager IBackupManager for communicating
         * with the backup mechanism.
         *
         * @sa #getSystemService
         * @sa android.app.backup.IBackupManager IBackupManager
         * @hide
         *
         * @see #getSystemService
         */
        const String BACKUP_SERVICE = "backup";

        /**
         * Use with #getSystemService to retrieve a
         * android.os.DropBoxManager instance for recording
         * diagnostic logs.
         *
         * @sa #getSystemService
         * @sa android.os.DropBoxManager
         * @see #getSystemService
         */
        const String DROPBOX_SERVICE = "dropbox";

        /**
         * Use with #getSystemService to retrieve a
         * android.app.admin.DevicePolicyManager for working with global
         * device policy management.
         *
         * @sa #getSystemService
         * @sa android.app.admin.DevicePolicyManager
         *
         * @see #getSystemService
         */
        const String DEVICE_POLICY_SERVICE = "device_policy";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.app.UiModeManager} for controlling UI modes.
         *
         * @see #getSystemService
         */
        const String UI_MODE_SERVICE = "uimode";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.app.DownloadManager} for requesting HTTP downloads.
         *
         * @see #getSystemService
         */
        const String DOWNLOAD_SERVICE = "download";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.os.BatteryManager} for managing battery state.
         *
         * @see #getSystemService
         */
        const String BATTERY_SERVICE = "batterymanager";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.nfc.NfcManager} for using NFC.
         *
         * @see #getSystemService
         */
        const String NFC_SERVICE = "nfc";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.bluetooth.BluetoothAdapter} for using Bluetooth.
         *
         * @see #getSystemService
         * @hide
         */
        const String BLUETOOTH_SERVICE = "bluetooth";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.net.sip.SipManager} for accessing the SIP related service.
         *
         * @see #getSystemService
         */
        /** @hide */
        const String SIP_SERVICE = "sip";

        /**
         * Use with {@sa #getSystemService} to retrieve a {@sa
         * android.hardware.usb.UsbManager} for access to USB devices (as a USB host)
         * and for controlling this device's behavior as a USB device.
         *
         * @see #getSystemService
         * @see android.harware.usb.UsbManager
         */
        const String USB_SERVICE = "usb";

        /**
         * Use with {@sa #getSystemService} to retrieve a {@sa
         * android.hardware.SerialManager} for access to serial ports.
         *
         * @see #getSystemService
         * @see android.harware.SerialManager
         *
         * @hide
         */
        const String SERIAL_SERVICE = "serial";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.hardware.hdmi.HdmiControlManager} for controlling and managing
         * HDMI-CEC protocol.
         *
         * @see #getSystemService
         * @see android.hardware.hdmi.HdmiControlManager
         * @hide
         */
        //@SystemApi
        const String HDMI_CONTROL_SERVICE = "hdmi_control";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.hardware.input.InputManager} for interacting with input devices.
         *
         * @see #getSystemService
         * @see android.hardware.input.InputManager
         */
        const String INPUT_SERVICE = "input";

        /**
         * Use with {@sa #getSystemService} to retrieve a
         * {@sa android.hardware.display.DisplayManager} for interacting with display devices.
         *
         * @see #getSystemService
         * @see android.hardware.display.DisplayManager
         */
        const String DISPLAY_SERVICE = "display";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.os.UserManager} for managing users on devices that support multiple users.
         *
         * @see #getSystemService
         * @see android.os.UserManager
         */
        const String USER_SERVICE = "user";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.content.pm.LauncherApps} for querying and monitoring launchable apps across
         * profiles of a user.
         *
         * @see #getSystemService
         * @see android.content.pm.LauncherApps
         */
        const String LAUNCHER_APPS_SERVICE = "launcherapps";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.content.RestrictionsManager} for retrieving application restrictions
         * and requesting permissions for restricted operations.
         * @see #getSystemService
         * @see android.content.RestrictionsManager
         */
        const String RESTRICTIONS_SERVICE = "restrictions";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.app.AppOpsManager} for tracking application operations
         * on the device.
         *
         * @see #getSystemService
         * @see android.app.AppOpsManager
         */
        const String APP_OPS_SERVICE = "appops";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.hardware.camera2.CameraManager} for interacting with
         * camera devices.
         *
         * @see #getSystemService
         * @see android.hardware.camera2.CameraManager
         */
        const String CAMERA_SERVICE = "camera";

        /**
         * {@link android.print.PrintManager} for printing and managing
         * printers and print tasks.
         *
         * @see #getSystemService
         * @see android.print.PrintManager
         */
        const String PRINT_SERVICE = "print";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.hardware.ConsumerIrManager} for transmitting infrared
         * signals from the device.
         *
         * @see #getSystemService
         * @see android.hardware.ConsumerIrManager
         */
        const String CONSUMER_IR_SERVICE = "consumer_ir";

        /**
         * {@link android.app.trust.TrustManager} for managing trust agents.
         * @see #getSystemService
         * @see android.app.trust.TrustManager
         * @hide
         */
        const String TRUST_SERVICE = "trust";

        /**
         * Use with {@link #getSystemService} to retrieve a
         * {@link android.media.tv.TvInputManager} for interacting with TV inputs
         * on the device.
         *
         * @see #getSystemService
         * @see android.media.tv.TvInputManager
         */
        const String TV_INPUT_SERVICE = "tv_input";

        /**
         * {@link android.net.NetworkScoreManager} for managing network scoring.
         * @see #getSystemService
         * @see android.net.NetworkScoreManager
         * @hide
         */
        //@SystemApi
        const String NETWORK_SCORE_SERVICE = "network_score";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.app.UsageStatsManager} for interacting with the status bar.
         *
         * @see #getSystemService
         * @see android.app.UsageStatsManager
         * @hide
         */
        const String USAGE_STATS_SERVICE = "usagestats";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.app.job.JobScheduler} instance for managing occasional
         * background tasks.
         * @see #getSystemService
         * @see android.app.job.JobScheduler
         */
        const String JOB_SCHEDULER_SERVICE = "jobscheduler";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.service.persistentdata.PersistentDataBlockManager} instance
         * for interacting with a storage device that lives across factory resets.
         *
         * @see #getSystemService
         * @see android.service.persistentdata.PersistentDataBlockManager
         * @hide
         */
        //@SystemApi
        const String PERSISTENT_DATA_BLOCK_SERVICE = "persistent_data_block";

        /**
         * Use with {@link #getSystemService} to retrieve a {@link
         * android.media.projection.MediaProjectionManager} instance for managing
         * media projection sessions.
         * @see #getSystemService
         * @see android.media.projection.ProjectionManager
         */
        const String MEDIA_PROJECTION_SERVICE = "media_projection";


        /**
         * Flag for use with {@sa #createPackageContext}: include the application
         * code with the context.  This means loading code into the caller's
         * process, so that {@sa #getClassLoader()} can be used to instantiate
         * the application's classes.  Setting this flags imposes security
         * restrictions on what application context you can access; if the
         * requested application can not be safely loaded into your process,
         * java.lang.SecurityException will be thrown.  If this flag is not set,
         * there will be no restrictions on the packages that can be loaded,
         * but {@sa #getClassLoader} will always return the default system
         * class loader.
         */
        const Int32 CONTEXT_INCLUDE_CODE = 0x00000001;

        /**
         * Flag for use with {@sa #createPackageContext}: ignore any security
         * restrictions on the Context being requested, allowing it to always
         * be loaded.  For use with {@sa #CONTEXT_INCLUDE_CODE} to allow code
         * to be loaded into a process even when it isn't safe to do so.  Use
         * with extreme care!
         */
        const Int32 CONTEXT_IGNORE_SECURITY = 0x00000002;

        /**
         * Flag for use with {@sa #createPackageContext}: a restricted context may
         * disable specific features. For instance, a View associated with a restricted
         * context would ignore particular XML attributes.
         */
        const Int32 CONTEXT_RESTRICTED = 0x00000004;

        /**
         * @hide Used to indicate we should tell the activity manager about the process
         * loading this code.
         */
        const Int32 CONTEXT_REGISTER_PACKAGE = 0x40000000;

        /** Return an AssetManager instance for your application's package. */
        GetAssets(
            [out] IAssetManager** assetManager);

        /** Return a Resources instance for your application's package. */
        GetResources(
            [out] IResources** resources);

        /** Return PackageManager instance to find global package information. */
        GetPackageManager(
            [out] IPackageManager** packageManager);

        /** Return a ContentResolver instance for your application's package. */
        GetContentResolver(
            [out] IContentResolver** resolver);

        /**
         * Return the Looper for the main thread of the current process.  This is
         * the thread used to dispatch calls to application components (activities,
         * services, etc).
         */
        GetMainLooper(
            [out] ILooper** looper);

        /**
         * Return the context of the single, global Application object of the
         * current process.  This generally should only be used if you need a
         * Context whose lifecycle is separate from the current context, that is
         * tied to the lifetime of the process rather than the current component.
         *
         * <p>Consider for example how this interacts with
         * {@sa #registerReceiver(BroadcastReceiver, IntentFilter)}:
         * <ul>
         * <li> <p>If used from an Activity context, the receiver is being registered
         * within that activity.  This means that you are expected to unregister
         * before the activity is done being destroyed; in fact if you do not do
         * so, the framework will clean up your leaked registration as it removes
         * the activity and log an error.  Thus, if you use the Activity context
         * to register a receiver that is static (global to the process, not
         * associated with an Activity instance) then that registration will be
         * removed on you at whatever point the activity you used is destroyed.
         * <li> <p>If used from the Context returned here, the receiver is being
         * registered with the global state associated with your application.  Thus
         * it will never be unregistered for you.  This is necessary if the receiver
         * is associated with static data, not a particular component.  However
         * using the ApplicationContext elsewhere can easily lead to serious leaks
         * if you forget to unregister, unbind, etc.
         * </ul>
         */
        GetApplicationContext(
            [out] IContext** ctx);

        /**
         * Add a new {@sa ComponentCallbacks} to the base application of the
         * Context, which will be called at the same times as the ComponentCallbacks
         * methods of activities and other components are called.  Note that you
         * <em>must</em> be sure to use {@sa #unregisterComponentCallbacks} when
         * appropriate in the future; this will not be removed for you.
         *
         * @param callback The interface to call.  This can be either a
         * {@sa ComponentCallbacks} or {@sa ComponentCallbacks2} interface.
         */
        RegisterComponentCallbacks(
            [in] IComponentCallbacks* componentCallback);

        /**
         * Remove a {@sa ComponentCallbacks} objec that was previously registered
         * with {@sa #registerComponentCallbacks(ComponentCallbacks)}.
         */
        UnregisterComponentCallbacks(
            [in] IComponentCallbacks* componentCallback);

        /**
         * Return a localized, styled CharSequence from the application's package's
         * default string table.
         *
         * @param resId Resource id for the CharSequence text
         */
        GetText(
            [in] Int32 resId,
            [out] ICharSequence** text);

        /**
         * Return a localized string from the application's package's
         * default string table.
         *
         * @param resId Resource id for the string
         */
        GetString(
            [in] Int32 resId,
            [out] String* str);

        /**
         * Return a localized formatted string from the application's package's
         * default string table, substituting the format arguments as defined in
         * {@sa java.util.Formatter} and {@sa java.lang.String#format}.
         *
         * @param resId Resource id for the format string
         * @param formatArgs The format arguments that will be used for substitution.
         */
        GetString(
            [in] Int32 resId,
            [in] ArrayOf<IInterface*>* formatArgs,
            [out] String* str);

        /**
         * Return a drawable object associated with a particular resource ID and
         * styled for the current theme.
         *
         * @param id The desired resource identifier, as generated by the aapt
         *           tool. This integer encodes the package, type, and resource
         *           entry. The value 0 is an invalid identifier.
         * @return Drawable An object that can be used to draw this resource.
         */
        GetDrawable(
            [in] Int32 resId,
            [out] IDrawable** drawable);

        /**
         * Set the base theme for this context.  Note that this should be called
         * before any views are instantiated in the Context (for example before
         * calling {@sa android.app.Activity#setContentView} or
         * {@sa android.view.LayoutInflater#inflate}).
         *
         * @param resid The style resource describing the theme.
         */
        SetTheme(
            [in] Int32 resId);

        /**
         * @hide
         * Needed for some internal implementation...  not public because
         * you can't assume this actually means anything.
         */
        GetThemeResId(
            [out] Int32* resId);

        /**
         * Return the Theme object associated with this Context.
         */
        GetTheme(
            [out] IResourcesTheme** theme);

        /**
         * Retrieve styled attribute information in this Context's theme.  See
         * {@sa Resources.Theme#obtainStyledAttributes(int[])}
         * for more information.
         *
         * @see Resources.Theme#obtainStyledAttributes(int[])
         */
        ObtainStyledAttributes(
            [in] ArrayOf<Int32>* attrs,
            [out] ITypedArray** styles);

        /**
         * Retrieve styled attribute information in this Context's theme.  See
         * {@sa Resources.Theme#obtainStyledAttributes(int, int[])}
         * for more information.
         *
         * @see Resources.Theme#obtainStyledAttributes(int, int[])
         */
        ObtainStyledAttributes(
            [in] Int32 resid,
            [in] ArrayOf<Int32>* attrs,
            [out] ITypedArray** styles);

        /**
         * Retrieve styled attribute information in this Context's theme.  See
         * {@sa Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
         * for more information.
         *
         * @see Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
         */
        ObtainStyledAttributes(
            [in] IAttributeSet* set,
            [in] ArrayOf<Int32>* attrs,
            [out] ITypedArray** styles);

        /**
         * Retrieve styled attribute information in this Context's theme.  See
         * {@sa Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
         * for more information.
         *
         * @see Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
         */
        ObtainStyledAttributes(
            [in] IAttributeSet* set,
            [in] ArrayOf<Int32>* attrs,
            [in] Int32 defStyleAttr,
            [in] Int32 defStyleRes,
            [out] ITypedArray** styles);

        /**
         * Return a class loader you can use to retrieve classes in this package.
         */
        // GetClassLoader(
        //     [out] IClassLoader** loader);

        /** Return the name of this application's package. */
        GetPackageName(
            [out] String* packageName);

        /** Return the name of this application's package. */
        GetBasePackageName(
            [out] String* packageName);

        /** @hide Return the package name that should be used for app ops calls from
         * this context.  This is the same as {@link #getBasePackageName()} except in
         * cases where system components are loaded into other app processes, in which
         * case this will be the name of the primary package in that process (so that app
         * ops uid verification will work with the name).
         */
        GetOpPackageName(
            [out] String* packageName);

        /** Return the full application info for this context's package. */
        GetApplicationInfo(
            [out] IApplicationInfo** info);

        /**
         * Return the full path to this context's primary Android package.
         * The Android package is a ZIP file which contains the application's
         * primary resources.
         *
         * <p>Note: this is not generally useful for applications, since they should
         * not be directly accessing the file system.
         *
         * @return String Path to the resources.
         */
        GetPackageResourcePath(
            [out] String* path);

        /**
         * Return the full path to this context's primary Android package.
         * The Android package is a ZIP file which contains application's
         * primary code and assets.
         *
         * <p>Note: this is not generally useful for applications, since they should
         * not be directly accessing the file system.
         *
         * @return String Path to the code and assets.
         */
        GetPackageCodePath(
            [out] String* codePath);

        /**
         * {@hide}
         * Return the full path to the shared prefs file for the given prefs group name.
         *
         * <p>Note: this is not generally useful for applications, since they should
         * not be directly accessing the file system.
         */
        GetSharedPrefsFile(
            [in] String name,
            [out] IFile** file);

        /**
         * Retrieve and hold the contents of the preferences file 'name', returning
         * a SharedPreferences through which you can retrieve and modify its
         * values.  Only one instance of the SharedPreferences object is returned
         * to any callers for the same name, meaning they will see each other's
         * edits as soon as they are made.
         *
         * @param name Desired preferences file. If a preferences file by this name
         * does not exist, it will be created when you retrieve an
         * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
         * @param mode Operating mode.  Use 0 or {@sa #MODE_PRIVATE} for the
         * default operation, {@sa #MODE_WORLD_READABLE}
         * and {@sa #MODE_WORLD_WRITEABLE} to control permissions.  The bit
         * {@sa #MODE_MULTI_PROCESS} can also be used if multiple processes
         * are mutating the same SharedPreferences file.  {@sa #MODE_MULTI_PROCESS}
         * is always on in apps targetting Gingerbread (Android 2.3) and below, and
         * off by default in later versions.
         *
         * @return Returns the single SharedPreferences instance that can be used
         *         to retrieve and modify the preference values.
         *
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_READABLE
         * @see #MODE_WORLD_WRITEABLE
         * @see #MODE_MULTI_PROCESS
         */
        GetSharedPreferences(
            [in] String name,
            [in] Int32 mode,
            [out] ISharedPreferences** prefs);

        /**
         * Open a private file associated with this Context's application package
         * for reading.
         *
         * @param name The name of the file to open; can not contain path
         *             separators.
         *
         * @return FileInputStream Resulting input stream.
         *
         * @see #openFileOutput
         * @see #fileList
         * @see #deleteFile
         * @see java.io.FileInputStream#FileInputStream(String)
         */
        OpenFileInput(
            [in] String name,
            [out] IFileInputStream** fileInputStream);

        /**
         * Open a private file associated with this Context's application package
         * for writing.  Creates the file if it doesn't already exist.
         *
         * @param name The name of the file to open; can not contain path
         *             separators.
         * @param mode Operating mode.  Use 0 or {@sa #MODE_PRIVATE} for the
         * default operation, {@sa #MODE_APPEND} to append to an existing file,
         * {@sa #MODE_WORLD_READABLE} and {@sa #MODE_WORLD_WRITEABLE} to control
         * permissions.
         *
         * @return FileOutputStream Resulting output stream.
         *
         * @see #MODE_APPEND
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_READABLE
         * @see #MODE_WORLD_WRITEABLE
         * @see #openFileInput
         * @see #fileList
         * @see #deleteFile
         * @see java.io.FileOutputStream#FileOutputStream(String)
         */
        OpenFileOutput(
            [in] String name,
            [in] Int32 mode,
            [out] IFileOutputStream** fileOutputStream);

        /**
         * Delete the given private file associated with this Context's
         * application package.
         *
         * @param name The name of the file to delete; can not contain path
         *             separators.
         *
         * @return True if the file was successfully deleted; else
         *         false.
         *
         * @see #openFileInput
         * @see #openFileOutput
         * @see #fileList
         * @see java.io.File#delete()
         */
        DeleteFile(
            [in] String name,
            [out] Boolean* succeeded);

        /**
         * Returns the absolute path on the filesystem where a file created with
         * {@sa #openFileOutput} is stored.
         *
         * @param name The name of the file for which you would like to get
         *          its path.
         *
         * @return Returns an absolute path to the given file.
         *
         * @see #openFileOutput
         * @see #getFilesDir
         * @see #getDir
         */
        GetFileStreamPath(
            [in] String name,
            [out] IFile** file);

        /**
         * Returns the absolute path to the directory on the filesystem where
         * files created with {@sa #openFileOutput} are stored.
         *
         * @return Returns the path of the directory holding application files.
         *
         * @see #openFileOutput
         * @see #getFileStreamPath
         * @see #getDir
         */
        GetFilesDir(
            [out] IFile** filesDir);

        /**
         * Returns the absolute path to the directory on the filesystem similar to
         * {@link #getFilesDir()}.  The difference is that files placed under this
         * directory will be excluded from automatic backup to remote storage.  See
         * {@link android.app.backup.BackupAgent BackupAgent} for a full discussion
         * of the automatic backup mechanism in Android.
         *
         * <p>No permissions are required to read or write to the returned path, since this
         * path is internal storage.
         *
         * @return The path of the directory holding application files that will not be
         *         automatically backed up to remote storage.
         *
         * @see #openFileOutput
         * @see #getFileStreamPath
         * @see #getDir
         * @see android.app.backup.BackupAgent
         */
        GetNoBackupFilesDir(
            [out] IFile** filesDir);

        /**
         * Returns the absolute path to the directory on the external filesystem
         * (that is somewhere on {@sa android.os.Environment#getExternalStorageDirectory()
         * Environment.getExternalStorageDirectory()}) where the application can
         * place persistent files it owns.  These files are private to the
         * applications, and not typically visible to the user as media.
         *
         * <p>This is like {@sa #getFilesDir()} in that these
         * files will be deleted when the application is uninstalled, however there
         * are some important differences:
         *
         * <ul>
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.  See the
         * APIs on {@sa android.os.Environment} for information in the storage state.
         * <li>There is no security enforced with these files.  All applications
         * can read and write files placed here.
         * </ul>
         *
         * <p>On devices with multiple users (as described by {@sa UserManager}),
         * each user has their own isolated external storage. Applications only
         * have access to the external storage for the user they're running as.</p>
         *
         * <p>Here is an example of typical code to manipulate a file in
         * an application's private storage:</p>
         *
         * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
         * private_file}
         *
         * <p>If you supply a non-null <var>type</var> to this function, the returned
         * file will be a path to a sub-directory of the given type.  Though these files
         * are not automatically scanned by the media scanner, you can explicitly
         * add them to the media database with
         * {@sa android.media.MediaScannerConnection#scanFile(Context, String[], String[],
         *      OnScanCompletedListener) MediaScannerConnection.scanFile}.
         * Note that this is not the same as
         * {@sa android.os.Environment#getExternalStoragePublicDirectory
         * Environment.getExternalStoragePublicDirectory()}, which provides
         * directories of media shared by all applications.  The
         * directories returned here are
         * owned by the application, and their contents will be removed when the
         * application is uninstalled.  Unlike
         * {@sa android.os.Environment#getExternalStoragePublicDirectory
         * Environment.getExternalStoragePublicDirectory()}, the directory
         * returned here will be automatically created for you.
         *
         * <p>Here is an example of typical code to manipulate a picture in
         * an application's private storage and add it to the media database:</p>
         *
         * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
         * private_picture}
         *
         * <p>Writing to this path requires the
         * {@sa android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission.</p>
         *
         * @param type The type of files directory to return.  May be null for
         * the root of the files directory or one of
         * the following Environment constants for a subdirectory:
         * {@sa android.os.Environment#DIRECTORY_MUSIC},
         * {@sa android.os.Environment#DIRECTORY_PODCASTS},
         * {@sa android.os.Environment#DIRECTORY_RINGTONES},
         * {@sa android.os.Environment#DIRECTORY_ALARMS},
         * {@sa android.os.Environment#DIRECTORY_NOTIFICATIONS},
         * {@sa android.os.Environment#DIRECTORY_PICTURES}, or
         * {@sa android.os.Environment#DIRECTORY_MOVIES}.
         *
         * @return Returns the path of the directory holding application files
         * on external storage.  Returns null if external storage is not currently
         * mounted so it could not ensure the path exists; you will need to call
         * this method again when it is available.
         *
         * @see #getFilesDir
         * @see android.os.Environment#getExternalStoragePublicDirectory
         */
        GetExternalFilesDir(
            [in] String type,
            [out] IFile** filesDir);

        /**
         * Returns absolute paths to application-specific directories on all
         * external storage devices where the application can place persistent files
         * it owns. These files are internal to the application, and not typically
         * visible to the user as media.
         * <p>
         * This is like {@link #getFilesDir()} in that these files will be deleted when
         * the application is uninstalled, however there are some important differences:
         * <ul>
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.
         * <li>There is no security enforced with these files.
         * </ul>
         * <p>
         * External storage devices returned here are considered a permanent part of
         * the device, including both emulated external storage and physical media
         * slots, such as SD cards in a battery compartment. The returned paths do
         * not include transient devices, such as USB flash drives.
         * <p>
         * An application may store data on any or all of the returned devices.  For
         * example, an app may choose to store large files on the device with the
         * most available space, as measured by {@link StatFs}.
         * <p>
         * No permissions are required to read or write to the returned paths; they
         * are always accessible to the calling app.  Write access outside of these
         * paths on secondary external storage devices is not available.
         * <p>
         * The first path returned is the same as {@link #getExternalFilesDir(String)}.
         * Returned paths may be {@code null} if a storage device is unavailable.
         *
         * @see #getExternalFilesDir(String)
         * @see Environment#getExternalStorageState(File)
         */
        GetExternalFilesDirs(
            [in] String type,
            [out, callee] ArrayOf<IFile*>* filesDir);

        /**
         * Return the directory where this application's OBB files (if there
         * are any) can be found.  Note if the application does not have any OBB
         * files, this directory may not exist.
         *
         * <p>On devices with multiple users (as described by {@sa UserManager}),
         * multiple users may share the same OBB storage location. Applications
         * should ensure that multiple instances running under different users
         * don't interfere with each other.</p>
         */
        GetObbDir(
            [out] IFile** obbDir);

        /**
         * Returns absolute paths to application-specific directories on all
         * external storage devices where the application's OBB files (if there are
         * any) can be found. Note if the application does not have any OBB files,
         * these directories may not exist.
         * <p>
         * This is like {@link #getFilesDir()} in that these files will be deleted when
         * the application is uninstalled, however there are some important differences:
         * <ul>
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.
         * <li>There is no security enforced with these files.
         * </ul>
         * <p>
         * External storage devices returned here are considered a permanent part of
         * the device, including both emulated external storage and physical media
         * slots, such as SD cards in a battery compartment. The returned paths do
         * not include transient devices, such as USB flash drives.
         * <p>
         * An application may store data on any or all of the returned devices.  For
         * example, an app may choose to store large files on the device with the
         * most available space, as measured by {@link StatFs}.
         * <p>
         * No permissions are required to read or write to the returned paths; they
         * are always accessible to the calling app.  Write access outside of these
         * paths on secondary external storage devices is not available.
         * <p>
         * The first path returned is the same as {@link #getObbDir()}.
         * Returned paths may be {@code null} if a storage device is unavailable.
         *
         * @see #getObbDir()
         * @see Environment#getExternalStorageState(File)
         */
        GetObbDirs(
            [out, callee] ArrayOf<IFile*>* filesDir);

        /**
         * Returns the absolute path to the application specific cache directory
         * on the filesystem. These files will be ones that get deleted first when the
         * device runs low on storage.
         * There is no guarantee when these files will be deleted.
         *
         * <strong>Note: you should not <em>rely</em> on the system deleting these
         * files for you; you should always have a reasonable maximum, such as 1 MB,
         * for the amount of space you consume with cache files, and prune those
         * files when exceeding that space.</strong>
         *
         * @return Returns the path of the directory holding application cache files.
         *
         * @see #openFileOutput
         * @see #getFileStreamPath
         * @see #getDir
         */
        GetCacheDir(
            [out] IFile** cacheDir);

        /**
         * Returns the absolute path to the application specific cache directory on
         * the filesystem designed for storing cached code. The system will delete
         * any files stored in this location both when your specific application is
         * upgraded, and when the entire platform is upgraded.
         * <p>
         * This location is optimal for storing compiled or optimized code generated
         * by your application at runtime.
         * <p>
         * Apps require no extra permissions to read or write to the returned path,
         * since this path lives in their private storage.
         *
         * @return The path of the directory holding application code cache files.
         */
        GetCodeCacheDir(
            [out] IFile** dir);

        /**
         * Returns the absolute path to the directory on the external filesystem
         * (that is somewhere on {@sa android.os.Environment#getExternalStorageDirectory()
         * Environment.getExternalStorageDirectory()} where the application can
         * place cache files it owns.
         *
         * <p>This is like {@sa #getCacheDir()} in that these
         * files will be deleted when the application is uninstalled, however there
         * are some important differences:
         *
         * <ul>
         * <li>The platform does not always monitor the space available in external
         * storage, and thus may not automatically delete these files.  Currently
         * the only time files here will be deleted by the platform is when running
         * on {@sa android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and
         * {@sa android.os.Environment#isExternalStorageEmulated()
         * Environment.isExternalStorageEmulated()} returns true.  Note that you should
         * be managing the maximum space you will use for these anyway, just like
         * with {@sa #getCacheDir()}.
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.  See the
         * APIs on {@sa android.os.Environment} for information in the storage state.
         * <li>There is no security enforced with these files.  All applications
         * can read and write files placed here.
         * </ul>
         *
         * <p>On devices with multiple users (as described by {@sa UserManager}),
         * each user has their own isolated external storage. Applications only
         * have access to the external storage for the user they're running as.</p>
         *
         * <p>Writing to this path requires the
         * {@sa android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission.</p>
         *
         * @return Returns the path of the directory holding application cache files
         * on external storage.  Returns null if external storage is not currently
         * mounted so it could not ensure the path exists; you will need to call
         * this method again when it is available.
         *
         * @see #getCacheDir
         */
        GetExternalCacheDir(
            [out] IFile** dir);

        /**
         * Returns absolute paths to application-specific directories on all
         * external storage devices where the application can place cache files it
         * owns. These files are internal to the application, and not typically
         * visible to the user as media.
         * <p>
         * This is like {@link #getCacheDir()} in that these files will be deleted when
         * the application is uninstalled, however there are some important differences:
         * <ul>
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.
         * <li>There is no security enforced with these files.
         * </ul>
         * <p>
         * External storage devices returned here are considered a permanent part of
         * the device, including both emulated external storage and physical media
         * slots, such as SD cards in a battery compartment. The returned paths do
         * not include transient devices, such as USB flash drives.
         * <p>
         * An application may store data on any or all of the returned devices.  For
         * example, an app may choose to store large files on the device with the
         * most available space, as measured by {@link StatFs}.
         * <p>
         * No permissions are required to read or write to the returned paths; they
         * are always accessible to the calling app.  Write access outside of these
         * paths on secondary external storage devices is not available.
         * <p>
         * The first path returned is the same as {@link #getExternalCacheDir()}.
         * Returned paths may be {@code null} if a storage device is unavailable.
         *
         * @see #getExternalCacheDir()
         * @see Environment#getExternalStorageState(File)
         */
        GetExternalCacheDirs(
            [out, callee] ArrayOf<IFile*>* dirs);

        /**
         * Returns absolute paths to application-specific directories on all
         * external storage devices where the application can place media files.
         * These files are scanned and made available to other apps through
         * {@link MediaStore}.
         * <p>
         * This is like {@link #getExternalFilesDirs} in that these files will be
         * deleted when the application is uninstalled, however there are some
         * important differences:
         * <ul>
         * <li>External files are not always available: they will disappear if the
         * user mounts the external storage on a computer or removes it.
         * <li>There is no security enforced with these files.
         * </ul>
         * <p>
         * External storage devices returned here are considered a permanent part of
         * the device, including both emulated external storage and physical media
         * slots, such as SD cards in a battery compartment. The returned paths do
         * not include transient devices, such as USB flash drives.
         * <p>
         * An application may store data on any or all of the returned devices. For
         * example, an app may choose to store large files on the device with the
         * most available space, as measured by {@link StatFs}.
         * <p>
         * No permissions are required to read or write to the returned paths; they
         * are always accessible to the calling app. Write access outside of these
         * paths on secondary external storage devices is not available.
         * <p>
         * Returned paths may be {@code null} if a storage device is unavailable.
         *
         * @see Environment#getExternalStorageState(File)
         */
        GetExternalMediaDirs(
            [out, callee] ArrayOf<IFile*>* dirs);

        /**
         * Returns an array of strings naming the private files associated with
         * this Context's application package.
         *
         * @return Array of strings naming the private files.
         *
         * @see #openFileInput
         * @see #openFileOutput
         * @see #deleteFile
         */
        GetFileList(
            [out, callee] ArrayOf<String>* fileList);

        /**
         * Retrieve, creating if needed, a new directory in which the application
         * can place its own custom data files.  You can use the returned File
         * object to create and access files in this directory.  Note that files
         * created through a File object will only be accessible by your own
         * application; you can only set the mode of the entire directory, not
         * of individual files.
         *
         * @param name Name of the directory to retrieve.  This is a directory
         * that is created as part of your application data.
         * @param mode Operating mode.  Use 0 or {@sa #MODE_PRIVATE} for the
         * default operation, {@sa #MODE_WORLD_READABLE} and
         * {@sa #MODE_WORLD_WRITEABLE} to control permissions.
         *
         * @return Returns a File object for the requested directory.  The directory
         * will have been created if it does not already exist.
         *
         * @see #openFileOutput(String, int)
         */
        GetDir(
            [in] String name,
            [in] Int32 mode,
            [out] IFile** dir);

        /**
         * Open a new private SQLiteDatabase associated with this Context's
         * application package.  Create the database file if it doesn't exist.
         *
         * @param name The name (unique in the application package) of the database.
         * @param mode Operating mode.  Use 0 or {@sa #MODE_PRIVATE} for the
         *     default operation, {@sa #MODE_WORLD_READABLE}
         *     and {@sa #MODE_WORLD_WRITEABLE} to control permissions.
         *     Use {@sa #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
         * @param factory An optional factory class that is called to instantiate a
         *     cursor when query is called.
         *
         * @return The contents of a newly created database with the given name.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * android.database.sqlite.SQLiteException | if the database file could not be opened.
         *
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_READABLE
         * @see #MODE_WORLD_WRITEABLE
         * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
         * @see #deleteDatabase
         */
        OpenOrCreateDatabase(
            [in] String name,
            [in] Int32 mode,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [out] ISQLiteDatabase** sqliteDB);

        /**
         * Open a new private SQLiteDatabase associated with this Context's
         * application package.  Creates the database file if it doesn't exist.
         *
         * <p>Accepts input param: a concrete instance of {@sa DatabaseErrorHandler} to be
         * used to handle corruption when sqlite reports database corruption.</p>
         *
         * @param name The name (unique in the application package) of the database.
         * @param mode Operating mode.  Use 0 or {@sa #MODE_PRIVATE} for the
         *     default operation, {@sa #MODE_WORLD_READABLE}
         *     and {@sa #MODE_WORLD_WRITEABLE} to control permissions.
         *     Use {@sa #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
         * @param factory An optional factory class that is called to instantiate a
         *     cursor when query is called.
         * @param errorHandler the {@sa DatabaseErrorHandler} to be used when sqlite reports database
         * corruption. if null, {@sa android.database.DefaultDatabaseErrorHandler} is assumed.
         * @return The contents of a newly created database with the given name.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * android.database.sqlite.SQLiteException | if the database file could not be opened.
         *
         * @see #MODE_PRIVATE
         * @see #MODE_WORLD_READABLE
         * @see #MODE_WORLD_WRITEABLE
         * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
         * @see #deleteDatabase
         */
        OpenOrCreateDatabase(
            [in] String name,
            [in] Int32 mode,
            [in] ISQLiteDatabaseCursorFactory* factory,
            [in] IDatabaseErrorHandler* errorHandler,
            [out] ISQLiteDatabase** sqliteDB);

        /**
         * Delete an existing private SQLiteDatabase associated with this Context's
         * application package.
         *
         * @param name The name (unique in the application package) of the
         *             database.
         *
         * @return True if the database was successfully deleted; else false.
         *
         * @see #openOrCreateDatabase
         */
        DeleteDatabase(
            [in] String name,
            [out] Boolean* succeeded);

        /**
         * Returns the absolute path on the filesystem where a database created with
         * {@sa #openOrCreateDatabase} is stored.
         *
         * @param name The name of the database for which you would like to get
         *          its path.
         *
         * @return Returns an absolute path to the given database.
         *
         * @see #openOrCreateDatabase
         */
        GetDatabasePath(
            [in] String name,
            [out] IFile** path);

        /**
         * Returns an array of strings naming the private databases associated with
         * this Context's application package.
         *
         * @return Array of strings naming the private databases.
         *
         * @see #openOrCreateDatabase
         * @see #deleteDatabase
         */
        GetDatabaseList(
            [out, callee] ArrayOf<String>* databaseList);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#getDrawable
         * WallpaperManager.get()} instead.
         */
        GetWallpaper(
            [out] IDrawable** drawable);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#peekDrawable
         * WallpaperManager.peek()} instead.
         */
        PeekWallpaper(
            [out] IDrawable** drawable);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#getDesiredMinimumWidth()
         * WallpaperManager.getDesiredMinimumWidth()} instead.
         */
        GetWallpaperDesiredMinimumWidth(
            [out] Int32* minWidth);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#getDesiredMinimumHeight()
         * WallpaperManager.getDesiredMinimumHeight()} instead.
         */
        GetWallpaperDesiredMinimumHeight(
            [out] Int32* minHeight);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#setBitmap(Bitmap)
         * WallpaperManager.set()} instead.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#SET_WALLPAPER}.
         */
        SetWallpaper(
            [in] IBitmap* bitmap);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#setStream(InputStream)
         * WallpaperManager.set()} instead.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#SET_WALLPAPER}.
         */
        SetWallpaper(
            [in] IInputStream* data);

        /**
         * @deprecated Use {@sa android.app.WallpaperManager#clear
         * WallpaperManager.clear()} instead.
         * <p>This method requires the caller to hold the permission
         * {@sa android.Manifest.permission#SET_WALLPAPER}.
         */
        ClearWallpaper();

        /**
         * Same as {@sa #startActivity(Intent, Bundle)} with no options
         * specified.
         *
         * @param intent The description of the activity to start.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         *
         * @see {@sa #startActivity(Intent, Bundle)}
         * @see PackageManager#resolveActivity
         */
        StartActivity(
            [in] IIntent* intent);

        /**
         * Version of {@sa #startActivity(Intent)} that allows you to specify the
         * user the activity will be started for.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS_FULL permission.
         * @param intent The description of the activity to start.
         * @param user The UserHandle of the user to start this activity for.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         * @hide
         */
        StartActivityAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user);

        /**
         * Launch a new activity.  You will not receive any information about when
         * the activity exits.
         *
         * <p>Note that if this method is being called from outside of an
         * {@sa android.app.Activity} Context, then the Intent must include
         * the {@sa Intent#FLAG_ACTIVITY_NEW_TASK} launch flag.  This is because,
         * without being started from an existing Activity, there is no existing
         * task in which to place the new activity and thus it needs to be placed
         * in its own separate task.
         *
         * <p>This method throws {@sa ActivityNotFoundException}
         * if there was no Activity found to run the given Intent.
         *
         * @param intent The description of the activity to start.
         * @param options Additional options for how the Activity should be started.
         * May be null if there are no options.  See {@sa android.app.ActivityOptions}
         * for how to build the Bundle supplied here; there are no supported definitions
         * for building it manually.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         *
         * @see #startActivity(Intent)
         * @see PackageManager#resolveActivity
         */
        StartActivity(
            [in] IIntent* intent,
            [in] IBundle* options);

        /**
         * Version of {@sa #startActivity(Intent, Bundle)} that allows you to specify the
         * user the activity will be started for.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS_FULL permission.
         * @param intent The description of the activity to start.
         * @param options Additional options for how the Activity should be started.
         * May be null if there are no options.  See {@sa android.app.ActivityOptions}
         * for how to build the Bundle supplied here; there are no supported definitions
         * for building it manually.
         * @param user The UserHandle of the user to start this activity for.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         * @hide
         */
        StartActivityAsUser(
            [in] IIntent* intent,
            [in] IBundle* options,
            [in] IUserHandle* userId);

        /**
         * Same as {@sa #startActivities(Intent[], Bundle)} with no options
         * specified.
         *
         * @param intents An array of Intents to be started.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         *
         * @see {@sa #startActivities(Intent[], Bundle)}
         * @see PackageManager#resolveActivity
         */
        StartActivities(
            [in] ArrayOf<IIntent*>* intents);

        /**
         * Launch multiple new activities.  This is generally the same as calling
         * {@sa #startActivity(Intent)} for the first Intent in the array,
         * that activity during its creation calling {@sa #startActivity(Intent)}
         * for the second entry, etc.  Note that unlike that approach, generally
         * none of the activities except the last in the array will be created
         * at this point, but rather will be created when the user first visits
         * them (due to pressing back from the activity on top).
         *
         * <p>This method throws {@sa ActivityNotFoundException}
         * if there was no Activity found for <em>any</em> given Intent.  In this
         * case the state of the activity stack is undefined (some Intents in the
         * list may be on it, some not), so you probably want to avoid such situations.
         *
         * @param intents An array of Intents to be started.
         * @param options Additional options for how the Activity should be started.
         * See {@sa android.content.Context#startActivity(Intent, Bundle)
         * Context.startActivity(Intent, Bundle)} for more details.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * ActivityNotFoundException
         *
         * @see {@sa #startActivities(Intent[])}
         * @see PackageManager#resolveActivity
         */
        StartActivities(
            [in] ArrayOf<IIntent*>* intents,
            [in] IBundle* options);

        /**
         * @hide
         * Launch multiple new activities.  This is generally the same as calling
         * {@sa #startActivity(Intent)} for the first Intent in the array,
         * that activity during its creation calling {@sa #startActivity(Intent)}
         * for the second entry, etc.  Note that unlike that approach, generally
         * none of the activities except the last in the array will be created
         * at this point, but rather will be created when the user first visits
         * them (due to pressing back from the activity on top).
         *
         * <p>This method throws {@sa ActivityNotFoundException}
         * if there was no Activity found for <em>any</em> given Intent.  In this
         * case the state of the activity stack is undefined (some Intents in the
         * list may be on it, some not), so you probably want to avoid such situations.
         *
         * @param intents An array of Intents to be started.
         * @param options Additional options for how the Activity should be started.
         * @param userHandle The user for whom to launch the activities
         * See {@sa android.content.Context#startActivity(Intent, Bundle)
         * Context.startActivity(Intent, Bundle)} for more details.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :---|
         * ActivityNotFoundException
         *
         * @see {@sa #startActivities(Intent[])}
         * @see PackageManager#resolveActivity
         */
        StartActivitiesAsUser(
            [in] ArrayOf<IIntent*>* intents,
            [in] IBundle* options,
            [in] IUserHandle* userHandle);

        /**
         * Same as {@sa #startIntentSender(IntentSender, Intent, int, int, int, Bundle)}
         * with no options specified.
         *
         * @param intent The IntentSender to launch.
         * @param fillInIntent If non-null, this will be provided as the
         * intent parameter to {@sa IntentSender#sendIntent}.
         * @param flagsMask Intent flags in the original IntentSender that you
         * would like to change.
         * @param flagsValues Desired values for any bits set in
         * <var>flagsMask</var>
         * @param extraFlags Always set to 0.
         *
         * @see #startActivity(Intent)
         * @see #startIntentSender(IntentSender, Intent, int, int, int, Bundle)
         */
        StartIntentSender(
            [in] IIntentSender* intent,
            [in] IIntent* fillInIntent,
            [in] Int32 flagsMask,
            [in] Int32 flagsValues,
            [in] Int32 extraFlags);

        /**
         * Like {@sa #startActivity(Intent, Bundle)}, but taking a IntentSender
         * to start.  If the IntentSender is for an activity, that activity will be started
         * as if you had called the regular {@sa #startActivity(Intent)}
         * here; otherwise, its associated action will be executed (such as
         * sending a broadcast) as if you had called
         * {@sa IntentSender#sendIntent IntentSender.sendIntent} on it.
         *
         * @param intent The IntentSender to launch.
         * @param fillInIntent If non-null, this will be provided as the
         * intent parameter to {@sa IntentSender#sendIntent}.
         * @param flagsMask Intent flags in the original IntentSender that you
         * would like to change.
         * @param flagsValues Desired values for any bits set in
         * <var>flagsMask</var>
         * @param extraFlags Always set to 0.
         * @param options Additional options for how the Activity should be started.
         * See {@sa android.content.Context#startActivity(Intent, Bundle)
         * Context.startActivity(Intent, Bundle)} for more details.  If options
         * have also been supplied by the IntentSender, options given here will
         * override any that conflict with those given by the IntentSender.
         *
         * @see #startActivity(Intent, Bundle)
         * @see #startIntentSender(IntentSender, Intent, int, int, int)
         */
        StartIntentSender(
            [in] IIntentSender* intent,
            [in] IIntent* fillInIntent,
            [in] Int32 flagsMask,
            [in] Int32 flagsValues,
            [in] Int32 extraFlags,
            [in] IBundle* options);

        /**
         * Broadcast the given intent to all interested BroadcastReceivers.  This
         * call is asynchronous; it returns immediately, and you will continue
         * executing while the receivers are run.  No results are propagated from
         * receivers and receivers can not abort the broadcast. If you want
         * to allow receivers to propagate results or abort the broadcast, you must
         * send an ordered broadcast using
         * {@sa #sendOrderedBroadcast(Intent, String)}.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         *
         * @see android.content.BroadcastReceiver
         * @see #registerReceiver
         * @see #sendBroadcast(Intent, String)
         * @see #sendOrderedBroadcast(Intent, String)
         * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendBroadcast(
            [in] IIntent* intent);

        /**
         * Broadcast the given intent to all interested BroadcastReceivers, allowing
         * an optional required permission to be enforced.  This
         * call is asynchronous; it returns immediately, and you will continue
         * executing while the receivers are run.  No results are propagated from
         * receivers and receivers can not abort the broadcast. If you want
         * to allow receivers to propagate results or abort the broadcast, you must
         * send an ordered broadcast using
         * {@sa #sendOrderedBroadcast(Intent, String)}.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param receiverPermission (optional) String naming a permission that
         *               a receiver must hold in order to receive your broadcast.
         *               If null, no permission is required.
         *
         * @see android.content.BroadcastReceiver
         * @see #registerReceiver
         * @see #sendBroadcast(Intent)
         * @see #sendOrderedBroadcast(Intent, String)
         * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendBroadcast(
            [in] IIntent* intent,
            [in] String receiverPermission);

        /**
         * Broadcast the given intent to all interested BroadcastReceivers, delivering
         * them one at a time to allow more preferred receivers to consume the
         * broadcast before it is delivered to less preferred receivers.  This
         * call is asynchronous; it returns immediately, and you will continue
         * executing while the receivers are run.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param receiverPermission (optional) String naming a permissions that
         *               a receiver must hold in order to receive your broadcast.
         *               If null, no permission is required.
         *
         * @see android.content.BroadcastReceiver
         * @see #registerReceiver
         * @see #sendBroadcast(Intent)
         * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendOrderedBroadcast(
            [in] IIntent* intent,
            [in] String receiverPermission);

        /**
         * Version of {@sa #sendBroadcast(Intent)} that allows you to
         * receive data back from the broadcast.  This is accomplished by
         * supplying your own BroadcastReceiver when calling, which will be
         * treated as a final receiver at the end of the broadcast -- its
         * {@sa BroadcastReceiver#onReceive} method will be called with
         * the result values collected from the other receivers.  The broadcast will
         * be serialized in the same way as calling
         * {@sa #sendOrderedBroadcast(Intent, String)}.
         *
         * <p>Like {@sa #sendBroadcast(Intent)}, this method is
         * asynchronous; it will return before
         * resultReceiver.onReceive() is called.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param receiverPermission String naming a permissions that
         *               a receiver must hold in order to receive your broadcast.
         *               If null, no permission is required.
         * @param resultReceiver Your own BroadcastReceiver to treat as the final
         *                       receiver of the broadcast.
         * @param scheduler A custom Handler with which to schedule the
         *                  resultReceiver callback; if null it will be
         *                  scheduled in the Context's main thread.
         * @param initialCode An initial value for the result code.  Often
         *                    Activity.RESULT_OK.
         * @param initialData An initial value for the result data.  Often
         *                    null.
         * @param initialExtras An initial value for the result extras.  Often
         *                      null.
         *
         * @see #sendBroadcast(Intent)
         * @see #sendBroadcast(Intent, String)
         * @see #sendOrderedBroadcast(Intent, String)
         * @see #sendStickyBroadcast(Intent)
         * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
         * @see android.content.BroadcastReceiver
         * @see #registerReceiver
         * @see android.app.Activity#RESULT_OK
         */
        SendOrderedBroadcast(
            [in] IIntent* intent,
            [in] String receiverPermission,
            [in] IBroadcastReceiver* resultReceiver,
            [in] IHandler* scheduler,
            [in] Int32 initialCode,
            [in] String initialData,
            [in] IBundle* initialExtras);

        /**
         * Version of {@sa #sendBroadcast(Intent)} that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         * @param intent The intent to broadcast
         * @param user UserHandle to send the intent to.
         * @see #sendBroadcast(Intent)
         */
        SendBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user);

        /**
         * Version of {@sa #sendBroadcast(Intent, String)} that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param user UserHandle to send the intent to.
         * @param receiverPermission (optional) String naming a permission that
         *               a receiver must hold in order to receive your broadcast.
         *               If null, no permission is required.
         *
         * @see #sendBroadcast(Intent, String)
         */
        SendBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user,
            [in] String receiverPermission);

        /**
         * Version of
         * {@sa #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)}
         * that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param user UserHandle to send the intent to.
         * @param receiverPermission String naming a permissions that
         *               a receiver must hold in order to receive your broadcast.
         *               If null, no permission is required.
         * @param resultReceiver Your own BroadcastReceiver to treat as the final
         *                       receiver of the broadcast.
         * @param scheduler A custom Handler with which to schedule the
         *                  resultReceiver callback; if null it will be
         *                  scheduled in the Context's main thread.
         * @param initialCode An initial value for the result code.  Often
         *                    Activity.RESULT_OK.
         * @param initialData An initial value for the result data.  Often
         *                    null.
         * @param initialExtras An initial value for the result extras.  Often
         *                      null.
         *
         * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendOrderedBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user,
            [in] String receiverPermission,
            [in] IBroadcastReceiver* resultReceiver,
            [in] IHandler* scheduler,
            [in] Int32 initialCode,
            [in] String initialData,
            [in] IBundle* initialExtras);

        /**
         * Perform a {@sa #sendBroadcast(Intent)} that is "sticky," meaning the
         * Intent you are sending stays around after the broadcast is complete,
         * so that others can quickly retrieve that data through the return
         * value of {@sa #registerReceiver(BroadcastReceiver, IntentFilter)}.  In
         * all other ways, this behaves the same as
         * {@sa #sendBroadcast(Intent)}.
         *
         * <p>You must hold the {@sa android.Manifest.permission#BROADCAST_STICKY}
         * permission in order to use this API.  If you do not hold that
         * permission, {@sa SecurityException} will be thrown.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         * Intent will receive the broadcast, and the Intent will be held to
         * be re-broadcast to future receivers.
         *
         * @see #sendBroadcast(Intent)
         * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendStickyBroadcast(
            [in] IIntent* intent);

        /**
         * Version of {@sa #sendStickyBroadcast} that allows you to
         * receive data back from the broadcast.  This is accomplished by
         * supplying your own BroadcastReceiver when calling, which will be
         * treated as a final receiver at the end of the broadcast -- its
         * {@sa BroadcastReceiver#onReceive} method will be called with
         * the result values collected from the other receivers.  The broadcast will
         * be serialized in the same way as calling
         * {@sa #sendOrderedBroadcast(Intent, String)}.
         *
         * <p>Like {@sa #sendBroadcast(Intent)}, this method is
         * asynchronous; it will return before
         * resultReceiver.onReceive() is called.  Note that the sticky data
         * stored is only the data you initially supply to the broadcast, not
         * the result of any changes made by the receivers.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param resultReceiver Your own BroadcastReceiver to treat as the final
         *                       receiver of the broadcast.
         * @param scheduler A custom Handler with which to schedule the
         *                  resultReceiver callback; if null it will be
         *                  scheduled in the Context's main thread.
         * @param initialCode An initial value for the result code.  Often
         *                    Activity.RESULT_OK.
         * @param initialData An initial value for the result data.  Often
         *                    null.
         * @param initialExtras An initial value for the result extras.  Often
         *                      null.
         *
         * @see #sendBroadcast(Intent)
         * @see #sendBroadcast(Intent, String)
         * @see #sendOrderedBroadcast(Intent, String)
         * @see #sendStickyBroadcast(Intent)
         * @see android.content.BroadcastReceiver
         * @see #registerReceiver
         * @see android.app.Activity#RESULT_OK
         */
        SendStickyOrderedBroadcast(
            [in] IIntent* intent,
            [in] IBroadcastReceiver* resultReceiver,
            [in] IHandler* scheduler,
            [in] Int32 initialCode,
            [in] String initialData,
            [in] IBundle* initialExtras);

        /**
         * Remove the data previously sent with {@sa #sendStickyBroadcast},
         * so that it is as if the sticky broadcast had never happened.
         *
         * <p>You must hold the {@sa android.Manifest.permission#BROADCAST_STICKY}
         * permission in order to use this API.  If you do not hold that
         * permission, {@sa SecurityException} will be thrown.
         *
         * @param intent The Intent that was previously broadcast.
         *
         * @see #sendStickyBroadcast
         */
        RemoveStickyBroadcast(
            [in] IIntent* intent);

        /**
         * Version of {@sa #sendStickyBroadcast(Intent)} that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         * Intent will receive the broadcast, and the Intent will be held to
         * be re-broadcast to future receivers.
         * @param user UserHandle to send the intent to.
         *
         * @see #sendBroadcast(Intent)
         */
        SendStickyBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user);

        /**
         * Version of
         * {@sa #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)}
         * that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * @param intent The Intent to broadcast; all receivers matching this
         *               Intent will receive the broadcast.
         * @param user UserHandle to send the intent to.
         * @param resultReceiver Your own BroadcastReceiver to treat as the final
         *                       receiver of the broadcast.
         * @param scheduler A custom Handler with which to schedule the
         *                  resultReceiver callback; if null it will be
         *                  scheduled in the Context's main thread.
         * @param initialCode An initial value for the result code.  Often
         *                    Activity.RESULT_OK.
         * @param initialData An initial value for the result data.  Often
         *                    null.
         * @param initialExtras An initial value for the result extras.  Often
         *                      null.
         *
         * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
         */
        SendStickyOrderedBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user,
            [in] IBroadcastReceiver* resultReceiver,
            [in] IHandler* scheduler,
            [in] Int32 initialCode,
            [in] String initialData,
            [in] IBundle* initialExtras);

        /**
         * Version of {@sa #removeStickyBroadcast(Intent)} that allows you to specify the
         * user the broadcast will be sent to.  This is not available to applications
         * that are not pre-installed on the system image.  Using it requires holding
         * the INTERACT_ACROSS_USERS permission.
         *
         * <p>You must hold the {@sa android.Manifest.permission#BROADCAST_STICKY}
         * permission in order to use this API.  If you do not hold that
         * permission, {@sa SecurityException} will be thrown.
         *
         * @param intent The Intent that was previously broadcast.
         * @param user UserHandle to remove the sticky broadcast from.
         *
         * @see #sendStickyBroadcastAsUser
         */
        RemoveStickyBroadcastAsUser(
            [in] IIntent* intent,
            [in] IUserHandle* user);

        /**
         * Register a BroadcastReceiver to be run in the main activity thread.  The
         * <var>receiver</var> will be called with any broadcast Intent that
         * matches <var>filter</var>, in the main application thread.
         *
         * <p>The system may broadcast Intents that are "sticky" -- these stay
         * around after the broadcast as finished, to be sent to any later
         * registrations. If your IntentFilter matches one of these sticky
         * Intents, that Intent will be returned by this function
         * <strong>and</strong> sent to your <var>receiver</var> as if it had just
         * been broadcast.
         *
         * <p>There may be multiple sticky Intents that match <var>filter</var>,
         * in which case each of these will be sent to <var>receiver</var>.  In
         * this case, only one of these can be returned directly by the function;
         * which of these that is returned is arbitrarily decided by the system.
         *
         * <p>If you know the Intent your are registering for is sticky, you can
         * supply null for your <var>receiver</var>.  In this case, no receiver is
         * registered -- the function simply returns the sticky Intent that
         * matches <var>filter</var>.  In the case of multiple matches, the same
         * rules as described above apply.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * <p>As of {@sa android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
         * registered with this method will correctly respect the
         * {@sa Intent#setPackage(String)} specified for an Intent being broadcast.
         * Prior to that, it would be ignored and delivered to all matching registered
         * receivers.  Be careful if using this for security.</p>
         *
         * <p class="note">Note: this method <em>cannot be called from a
         * {@sa BroadcastReceiver} component;</em> that is, from a BroadcastReceiver
         * that is declared in an application's manifest.  It is okay, however, to call
         * this method from another BroadcastReceiver that has itself been registered
         * at run time with {@sa #registerReceiver}, since the lifetime of such a
         * registered BroadcastReceiver is tied to the object that registered it.</p>
         *
         * @param receiver The BroadcastReceiver to handle the broadcast.
         * @param filter Selects the Intent broadcasts to be received.
         *
         * @return The first sticky intent found that matches <var>filter</var>,
         *         or null if there are none.
         *
         * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
         * @see #sendBroadcast
         * @see #unregisterReceiver
         */
        RegisterReceiver(
            [in] IBroadcastReceiver* receiver,
            [in] IIntentFilter* filter,
            [out] IIntent** stickyIntent);

        /**
         * Register to receive intent broadcasts, to run in the context of
         * <var>scheduler</var>.  See
         * {@sa #registerReceiver(BroadcastReceiver, IntentFilter)} for more
         * information.  This allows you to enforce permissions on who can
         * broadcast intents to your receiver, or have the receiver run in
         * a different thread than the main application thread.
         *
         * <p>See {@sa BroadcastReceiver} for more information on Intent broadcasts.
         *
         * <p>As of {@sa android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
         * registered with this method will correctly respect the
         * {@sa Intent#setPackage(String)} specified for an Intent being broadcast.
         * Prior to that, it would be ignored and delivered to all matching registered
         * receivers.  Be careful if using this for security.</p>
         *
         * @param receiver The BroadcastReceiver to handle the broadcast.
         * @param filter Selects the Intent broadcasts to be received.
         * @param broadcastPermission String naming a permissions that a
         *      broadcaster must hold in order to send an Intent to you.  If null,
         *      no permission is required.
         * @param scheduler Handler identifying the thread that will receive
         *      the Intent.  If null, the main thread of the process will be used.
         *
         * @return The first sticky intent found that matches <var>filter</var>,
         *         or null if there are none.
         *
         * @see #registerReceiver(BroadcastReceiver, IntentFilter)
         * @see #sendBroadcast
         * @see #unregisterReceiver
         */
        RegisterReceiver(
            [in] IBroadcastReceiver* receiver,
            [in] IIntentFilter* filter,
            [in] String broadcastPermission,
            [in] IHandler* scheduler,
            [out] IIntent** stickyIntent);

        /**
         * @hide
         * Same as {@sa #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
         * but for a specific user.  This receiver will receiver broadcasts that
         * are sent to the requested user.  It
         * requires holding the {@sa android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}
         * permission.
         *
         * @param receiver The BroadcastReceiver to handle the broadcast.
         * @param user UserHandle to send the intent to.
         * @param filter Selects the Intent broadcasts to be received.
         * @param broadcastPermission String naming a permissions that a
         *      broadcaster must hold in order to send an Intent to you.  If null,
         *      no permission is required.
         * @param scheduler Handler identifying the thread that will receive
         *      the Intent.  If null, the main thread of the process will be used.
         *
         * @return The first sticky intent found that matches <var>filter</var>,
         *         or null if there are none.
         *
         * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler
         * @see #sendBroadcast
         * @see #unregisterReceiver
         */
        RegisterReceiverAsUser(
            [in] IBroadcastReceiver* receiver,
            [in] IUserHandle* user,
            [in] IIntentFilter* filter,
            [in] String broadcastPermission,
            [in] IHandler* scheduler,
            [out] IIntent** stickyIntent);

        /**
         * Unregister a previously registered BroadcastReceiver.  <em>All</em>
         * filters that have been registered for this BroadcastReceiver will be
         * removed.
         *
         * @param receiver The BroadcastReceiver to unregister.
         *
         * @see #registerReceiver
         */
        UnregisterReceiver(
            [in] IBroadcastReceiver* receiver);

        /**
         * Request that a given application service be started.  The Intent
         * can either contain the complete class name of a specific service
         * implementation to start, or an abstract definition through the
         * action and other fields of the kind of service to start.  If this service
         * is not already running, it will be instantiated and started (creating a
         * process for it if needed); if it is running then it remains running.
         *
         * <p>Every call to this method will result in a corresponding call to
         * the target service's {@sa android.app.Service#onStartCommand} method,
         * with the <var>intent</var> given here.  This provides a convenient way
         * to submit jobs to a service without having to bind and call on to its
         * interface.
         *
         * <p>Using startService() overrides the default service lifetime that is
         * managed by {@sa #bindService}: it requires the service to remain
         * running until {@sa #stopService} is called, regardless of whether
         * any clients are connected to it.  Note that calls to startService()
         * are not nesting: no matter how many times you call startService(),
         * a single call to {@sa #stopService} will stop it.
         *
         * <p>The system attempts to keep running services around as much as
         * possible.  The only time they should be stopped is if the current
         * foreground application is using so many resources that the service needs
         * to be killed.  If any errors happen in the service's process, it will
         * automatically be restarted.
         *
         * <p>This function will throw {@sa SecurityException} if you do not
         * have permission to start the given service.
         *
         * @param service Identifies the service to be started.  The Intent may
         *      specify either an explicit component name to start, or a logical
         *      description (action, category, etc) to match an
         *      {@sa IntentFilter} published by a service.  Additional values
         *      may be included in the Intent extras to supply arguments along with
         *      this specific start call.
         *
         * @return If the service is being started or is already running, the
         * {@sa ComponentName} of the actual service that was started is
         * returned; else if the service does not exist null is returned.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * SecurityException
         *
         * @see #stopService
         * @see #bindService
         */
        StartService(
            [in] IIntent* service,
            [out] IComponentName** name);

        /**
         * Request that a given application service be stopped.  If the service is
         * not running, nothing happens.  Otherwise it is stopped.  Note that calls
         * to startService() are not counted -- this stops the service no matter
         * how many times it was started.
         *
         * <p>Note that if a stopped service still has {@sa ServiceConnection}
         * objects bound to it with the {@sa #BIND_AUTO_CREATE} set, it will
         * not be destroyed until all of these bindings are removed.  See
         * the {@sa android.app.Service} documentation for more details on a
         * service's lifecycle.
         *
         * <p>This function will throw {@sa SecurityException} if you do not
         * have permission to stop the given service.
         *
         * @param service Description of the service to be stopped.  The Intent may
         *      specify either an explicit component name to start, or a logical
         *      description (action, category, etc) to match an
         *      {@sa IntentFilter} published by a service.
         *
         * @return If there is a service matching the given Intent that is already
         * running, then it is stopped and true is returned; else false is returned.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * SecurityException
         *
         * @see #startService
         */
        StopService(
            [in] IIntent* service,
            [out] Boolean* succeeded);

        /**
         * @hide like {@sa #startService(Intent)} but for a specific user.
         */
        StartServiceAsUser(
            [in] IIntent* service,
            [in] IUserHandle* user,
            [out] IComponentName** name);

        /**
         * @hide like {@sa #stopService(Intent)} but for a specific user.
         */
        StopServiceAsUser(
            [in] IIntent* service,
            [in] IUserHandle* user,
            [out] Boolean* succeeded);

        /**
         * Connect to an application service, creating it if needed.  This defines
         * a dependency between your application and the service.  The given
         * <var>conn</var> will receive the service object when it is created and be
         * told if it dies and restarts.  The service will be considered required
         * by the system only for as long as the calling context exists.  For
         * example, if this Context is an Activity that is stopped, the service will
         * not be required to continue running until the Activity is resumed.
         *
         * <p>This function will throw {@sa SecurityException} if you do not
         * have permission to bind to the given service.
         *
         * <p class="note">Note: this method <em>can not be called from a
         * {@sa BroadcastReceiver} component</em>.  A pattern you can use to
         * communicate from a BroadcastReceiver to a Service is to call
         * {@sa #startService} with the arguments containing the command to be
         * sent, with the service calling its
         * {@sa android.app.Service#stopSelf(int)} method when done executing
         * that command.  See the API demo App/Service/Service Start Arguments
         * Controller for an illustration of this.  It is okay, however, to use
         * this method from a BroadcastReceiver that has been registered with
         * {@sa #registerReceiver}, since the lifetime of this BroadcastReceiver
         * is tied to another object (the one that registered it).</p>
         *
         * @param service Identifies the service to connect to.  The Intent may
         *      specify either an explicit component name, or a logical
         *      description (action, category, etc) to match an
         *      {@sa IntentFilter} published by a service.
         * @param conn Receives information as the service is started and stopped.
         *      This must be a valid ServiceConnection object; it must not be null.
         * @param flags Operation options for the binding.  May be 0,
         *          {@sa #BIND_AUTO_CREATE}, {@sa #BIND_DEBUG_UNBIND},
         *          {@sa #BIND_NOT_FOREGROUND}, {@sa #BIND_ABOVE_CLIENT},
         *          {@sa #BIND_ALLOW_OOM_MANAGEMENT}, or
         *          {@sa #BIND_WAIVE_PRIORITY}.
         * @return If you have successfully bound to the service, true is returned;
         *         false is returned if the connection is not made so you will not
         *         receive the service object.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value |
         * :-|
         * SecurityException
         *
         * @see #unbindService
         * @see #startService
         * @see #BIND_AUTO_CREATE
         * @see #BIND_DEBUG_UNBIND
         * @see #BIND_NOT_FOREGROUND
         */
        BindService(
            [in] IIntent* service,
            [in] IServiceConnection* conn,
            [in] Int32 flags,
            [out] Boolean* succeeded);

        /**
         * Same as {@link #bindService(Intent, ServiceConnection, int)}, but with an explicit userHandle
         * argument for use by system server and other multi-user aware code.
         * @hide
         */
        //@SystemApi
        BindServiceAsUser(
            [in] IIntent* service,
            [in] IServiceConnection* conn,
            [in] Int32 flags,
            [in] IUserHandle* user,
            [out] Boolean* succeeded);

        /**
         * Disconnect from an application service.  You will no longer receive
         * calls as the service is restarted, and the service is now allowed to
         * stop at any time.
         *
         * @param conn The connection interface previously supplied to
         *             bindService().  This parameter must not be null.
         *
         * @see #bindService
         */
        UnbindService(
            [in] IServiceConnection* conn);

        /**
         * Start executing an {@sa android.app.Instrumentation} class.  The given
         * Instrumentation component will be run by killing its target application
         * (if currently running), starting the target process, instantiating the
         * instrumentation component, and then letting it drive the application.
         *
         * <p>This function is not synchronous -- it returns as soon as the
         * instrumentation has started and while it is running.
         *
         * <p>Instrumentation is normally only allowed to run against a package
         * that is either unsigned or signed with a signature that the
         * the instrumentation package is also signed with (ensuring the target
         * trusts the instrumentation).
         *
         * @param className Name of the Instrumentation component to be run.
         * @param profileFile Optional path to write profiling data as the
         * instrumentation runs, or null for no profiling.
         * @param arguments Additional optional arguments to pass to the
         * instrumentation, or null.
         *
         * @return Returns true if the instrumentation was successfully started,
         * else false if it could not be found.
         */
        StartInstrumentation(
            [in] IComponentName* className,
            [in] String profileFile,
            [in] IBundle* arguments,
            [out] Boolean* succeeded);

        /**
         * Return the handle to a system-level service by name. The class of the
         * returned object varies by the requested name. Currently available names
         * are:
         *
         * <dl>
         *  <dt> {@sa #WINDOW_SERVICE} ("window")
         *  <dd> The top-level window manager in which you can place custom
         *  windows.  The returned object is a {@sa android.view.WindowManager}.
         *  <dt> {@sa #LAYOUT_INFLATER_SERVICE} ("layout_inflater")
         *  <dd> A {@sa android.view.LayoutInflater} for inflating layout resources
         *  in this context.
         *  <dt> {@sa #ACTIVITY_SERVICE} ("activity")
         *  <dd> A {@sa android.app.ActivityManager} for interacting with the
         *  global activity state of the system.
         *  <dt> {@sa #POWER_SERVICE} ("power")
         *  <dd> A {@sa android.os.PowerManager} for controlling power
         *  management.
         *  <dt> {@sa #ALARM_SERVICE} ("alarm")
         *  <dd> A {@sa android.app.AlarmManager} for receiving intents at the
         *  time of your choosing.
         *  <dt> {@sa #NOTIFICATION_SERVICE} ("notification")
         *  <dd> A {@sa android.app.NotificationManager} for informing the user
         *   of background events.
         *  <dt> {@sa #KEYGUARD_SERVICE} ("keyguard")
         *  <dd> A {@sa android.app.KeyguardManager} for controlling keyguard.
         *  <dt> {@sa #LOCATION_SERVICE} ("location")
         *  <dd> A {@sa android.location.LocationManager} for controlling location
         *   (e.g., GPS) updates.
         *  <dt> {@sa #SEARCH_SERVICE} ("search")
         *  <dd> A {@sa android.app.SearchManager} for handling search.
         *  <dt> {@sa #VIBRATOR_SERVICE} ("vibrator")
         *  <dd> A {@sa android.os.Vibrator} for interacting with the vibrator
         *  hardware.
         *  <dt> {@sa #CONNECTIVITY_SERVICE} ("connection")
         *  <dd> A {@sa android.net.ConnectivityManager ConnectivityManager} for
         *  handling management of network connections.
         *  <dt> {@sa #WIFI_SERVICE} ("wifi")
         *  <dd> A {@sa android.net.wifi.WifiManager WifiManager} for management of
         * Wi-Fi connectivity.
         * <dt> {@sa #INPUT_METHOD_SERVICE} ("input_method")
         * <dd> An {@sa android.view.inputmethod.InputMethodManager InputMethodManager}
         * for management of input methods.
         * <dt> {@sa #UI_MODE_SERVICE} ("uimode")
         * <dd> An {@sa android.app.UiModeManager} for controlling UI modes.
         * <dt> {@sa #DOWNLOAD_SERVICE} ("download")
         * <dd> A {@sa android.app.DownloadManager} for requesting HTTP downloads
         * </dl>
         *
         * <p>Note:  System services obtained via this API may be closely associated with
         * the Context in which they are obtained from.  In general, do not share the
         * service objects between various different contexts (Activities, Applications,
         * Services, Providers, etc.)
         *
         * @param name The name of the desired service.
         *
         * @return The service or null if the name does not exist.
         *
         * @see #WINDOW_SERVICE
         * @see android.view.WindowManager
         * @see #LAYOUT_INFLATER_SERVICE
         * @see android.view.LayoutInflater
         * @see #ACTIVITY_SERVICE
         * @see android.app.ActivityManager
         * @see #POWER_SERVICE
         * @see android.os.PowerManager
         * @see #ALARM_SERVICE
         * @see android.app.AlarmManager
         * @see #NOTIFICATION_SERVICE
         * @see android.app.NotificationManager
         * @see #KEYGUARD_SERVICE
         * @see android.app.KeyguardManager
         * @see #LOCATION_SERVICE
         * @see android.location.LocationManager
         * @see #SEARCH_SERVICE
         * @see android.app.SearchManager
         * @see #SENSOR_SERVICE
         * @see android.hardware.SensorManager
         * @see #STORAGE_SERVICE
         * @see android.os.storage.StorageManager
         * @see #VIBRATOR_SERVICE
         * @see android.os.Vibrator
         * @see #CONNECTIVITY_SERVICE
         * @see android.net.ConnectivityManager
         * @see #WIFI_SERVICE
         * @see android.net.wifi.WifiManager
         * @see #AUDIO_SERVICE
         * @see android.media.AudioManager
         * @see #MEDIA_ROUTER_SERVICE
         * @see android.media.MediaRouter
         * @see #TELEPHONY_SERVICE
         * @see android.telephony.TelephonyManager
         * @see #INPUT_METHOD_SERVICE
         * @see android.view.inputmethod.InputMethodManager
         * @see #UI_MODE_SERVICE
         * @see android.app.UiModeManager
         * @see #DOWNLOAD_SERVICE
         * @see android.app.DownloadManager
         */
        GetSystemService(
            [in] String name,
            [out] IInterface** object);

        /**
         * Determine whether the given permission is allowed for a particular
         * process and user ID running in the system.
         *
         * @param permission The name of the permission being checked.
         * @param pid The process ID being checked against.  Must be > 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the given
         * pid/uid is allowed that permission, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see PackageManager#checkPermission(String, String)
         * @see #checkCallingPermission
         */
        CheckPermission(
            [in] String permission,
            [in] Int32 pid,
            [in] Int32 uid,
            [out] Int32* result);

        /**
         * Determine whether the calling process of an IPC you are handling has been
         * granted a particular permission.  This is basically the same as calling
         * {@sa #checkPermission(String, int, int)} with the pid and uid returned
         * by {@sa android.os.Binder#getCallingPid} and
         * {@sa android.os.Binder#getCallingUid}.  One important difference
         * is that if you are not currently processing an IPC, this function
         * will always fail.  This is done to protect against accidentally
         * leaking permissions; you can use {@sa #checkCallingOrSelfPermission}
         * to avoid this protection.
         *
         * @param permission The name of the permission being checked.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the calling
         * pid/uid is allowed that permission, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see PackageManager#checkPermission(String, String)
         * @see #checkPermission
         * @see #checkCallingOrSelfPermission
         */
        CheckCallingPermission(
            [in] String permission,
            [out] Int32* result);

        /**
         * Determine whether the calling process of an IPC <em>or you</em> have been
         * granted a particular permission.  This is the same as
         * {@sa #checkCallingPermission}, except it grants your own permissions
         * if you are not currently processing an IPC.  Use with care!
         *
         * @param permission The name of the permission being checked.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the calling
         * pid/uid is allowed that permission, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see PackageManager#checkPermission(String, String)
         * @see #checkPermission
         * @see #checkCallingPermission
         */
        CheckCallingOrSelfPermission(
            [in] String permission,
            [out] Int32* result);

        /**
         * If the given permission is not allowed for a particular process
         * and user ID running in the system, throw a {@sa SecurityException}.
         *
         * @param permission The name of the permission being checked.
         * @param pid The process ID being checked against.  Must be &gt; 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkPermission(String, int, int)
         */
        EnforcePermission(
            [in] String permission,
            [in] Int32 pid,
            [in] Int32 uid,
            [in] String message);

        /**
         * If the calling process of an IPC you are handling has not been
         * granted a particular permission, throw a {@sa
         * SecurityException}.  This is basically the same as calling
         * {@sa #enforcePermission(String, int, int, String)} with the
         * pid and uid returned by {@sa android.os.Binder#getCallingPid}
         * and {@sa android.os.Binder#getCallingUid}.  One important
         * difference is that if you are not currently processing an IPC,
         * this function will always throw the SecurityException.  This is
         * done to protect against accidentally leaking permissions; you
         * can use {@sa #enforceCallingOrSelfPermission} to avoid this
         * protection.
         *
         * @param permission The name of the permission being checked.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkCallingPermission(String)
         */
        EnforceCallingPermission(
            [in] String permission,
            [in] String message);

        /**
         * If neither you nor the calling process of an IPC you are
         * handling has been granted a particular permission, throw a
         * {@sa SecurityException}.  This is the same as {@sa
         * #enforceCallingPermission}, except it grants your own
         * permissions if you are not currently processing an IPC.  Use
         * with care!
         *
         * @param permission The name of the permission being checked.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkCallingOrSelfPermission(String)
         */
        EnforceCallingOrSelfPermission(
            [in] String permission,
            [in] String message);

        /**
         * Grant permission to access a specific Uri to another package, regardless
         * of whether that package has general permission to access the Uri's
         * content provider.  This can be used to grant specific, temporary
         * permissions, typically in response to user interaction (such as the
         * user opening an attachment that you would like someone else to
         * display).
         *
         * <p>Normally you should use {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION
         * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION
         * Intent.FLAG_GRANT_WRITE_URI_PERMISSION} with the Intent being used to
         * start an activity instead of this function directly.  If you use this
         * function directly, you should be sure to call
         * {@sa #revokeUriPermission} when the target should no longer be allowed
         * to access it.
         *
         * <p>To succeed, the content provider owning the Uri must have set the
         * {@sa android.R.styleable#AndroidManifestProvider_grantUriPermissions
         * grantUriPermissions} attribute in its manifest or included the
         * {@sa android.R.styleable#AndroidManifestGrantUriPermission
         * &lt;grant-uri-permissions&gt;} tag.
         *
         * @param toPackage The package you would like to allow to access the Uri.
         * @param uri The Uri you would like to grant access to.
         * @param modeFlags The desired access modes.  Any combination of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION
         * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION
         * Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @see #revokeUriPermission
         */
        GrantUriPermission(
            [in] String toPackage,
            [in] IUri* uri,
            [in] Int32 modeFlags);

        /**
         * Remove all permissions to access a particular content provider Uri
         * that were previously added with {@sa #grantUriPermission}.  The given
         * Uri will match all previously granted Uris that are the same or a
         * sub-path of the given Uri.  That is, revoking "content://foo/one" will
         * revoke both "content://foo/target" and "content://foo/target/sub", but not
         * "content://foo".
         *
         * @param uri The Uri you would like to revoke access to.
         * @param modeFlags The desired access modes.  Any combination of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION
         * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION
         * Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @see #grantUriPermission
         */
        RevokeUriPermission(
            [in] IUri* uri,
            [in] Int32 modeFlags);

        /**
         * Determine whether a particular process and user ID has been granted
         * permission to access a specific URI.  This only checks for permissions
         * that have been explicitly granted -- if the given process/uid has
         * more general access to the URI's content provider then this check will
         * always fail.
         *
         * @param uri The uri that is being checked.
         * @param pid The process ID being checked against.  Must be &gt; 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the given
         * pid/uid is allowed to access that uri, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see #checkCallingUriPermission
         */
        CheckUriPermission(
            [in] IUri* uri,
            [in] Int32 pid,
            [in] Int32 uid,
            [in] Int32 modeFlags,
            [out] Int32* result);

        /**
         * Determine whether the calling process and user ID has been
         * granted permission to access a specific URI.  This is basically
         * the same as calling {@sa #checkUriPermission(Uri, int, int,
         * int)} with the pid and uid returned by {@sa
         * android.os.Binder#getCallingPid} and {@sa
         * android.os.Binder#getCallingUid}.  One important difference is
         * that if you are not currently processing an IPC, this function
         * will always fail.
         *
         * @param uri The uri that is being checked.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the caller
         * is allowed to access that uri, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see #checkUriPermission(Uri, int, int, int)
         */
        CheckCallingUriPermission(
            [in] IUri* uri,
            [in] Int32 modeFlags,
            [out] Int32* result);

        /**
         * Determine whether the calling process of an IPC <em>or you</em> has been granted
         * permission to access a specific URI.  This is the same as
         * {@sa #checkCallingUriPermission}, except it grants your own permissions
         * if you are not currently processing an IPC.  Use with care!
         *
         * @param uri The uri that is being checked.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the caller
         * is allowed to access that uri, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         *
         * @see #checkCallingUriPermission
         */
        CheckCallingOrSelfUriPermission(
            [in] IUri* uri,
            [in] Int32 modeFlags,
            [out] Int32* result);

        /**
         * Check both a Uri and normal permission.  This allows you to perform
         * both {@sa #checkPermission} and {@sa #checkUriPermission} in one
         * call.
         *
         * @param uri The Uri whose permission is to be checked, or null to not
         * do this check.
         * @param readPermission The permission that provides overall read access,
         * or null to not do this check.
         * @param writePermission The permission that provides overall write
         * acess, or null to not do this check.
         * @param pid The process ID being checked against.  Must be &gt; 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         *
         * @return Returns {@sa PackageManager#PERMISSION_GRANTED} if the caller
         * is allowed to access that uri or holds one of the given permissions, or
         * {@sa PackageManager#PERMISSION_DENIED} if it is not.
         */
        CheckUriPermission(
            [in] IUri* uri,
            [in] String readPermission,
            [in] String writePermission,
            [in] Int32 pid,
            [in] Int32 uid,
            [in] Int32 modeFlags,
            [out] Int32* result);

        /**
         * If a particular process and user ID has not been granted
         * permission to access a specific URI, throw {@sa
         * SecurityException}.  This only checks for permissions that have
         * been explicitly granted -- if the given process/uid has more
         * general access to the URI's content provider then this check
         * will always fail.
         *
         * @param uri The uri that is being checked.
         * @param pid The process ID being checked against.  Must be &gt; 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkUriPermission(Uri, int, int, int)
         */
        EnforceUriPermission(
            [in] IUri* uri,
            [in] Int32 pid,
            [in] Int32 uid,
            [in] Int32 modeFlags,
            [in] String message);

        /**
         * If the calling process and user ID has not been granted
         * permission to access a specific URI, throw {@sa
         * SecurityException}.  This is basically the same as calling
         * {@sa #enforceUriPermission(Uri, int, int, int, String)} with
         * the pid and uid returned by {@sa
         * android.os.Binder#getCallingPid} and {@sa
         * android.os.Binder#getCallingUid}.  One important difference is
         * that if you are not currently processing an IPC, this function
         * will always throw a SecurityException.
         *
         * @param uri The uri that is being checked.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkCallingUriPermission(Uri, int)
         */
        EnforceCallingUriPermission(
            [in] IUri* uri,
            [in] Int32 modeFlags,
            [in] String message);

        /**
         * If the calling process of an IPC <em>or you</em> has not been
         * granted permission to access a specific URI, throw {@sa
         * SecurityException}.  This is the same as {@sa
         * #enforceCallingUriPermission}, except it grants your own
         * permissions if you are not currently processing an IPC.  Use
         * with care!
         *
         * @param uri The uri that is being checked.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkCallingOrSelfUriPermission(Uri, int)
         */
        EnforceCallingOrSelfUriPermission(
            [in] IUri* uri,
            [in] Int32 modeFlags,
            [in] String message);

        /**
         * Enforce both a Uri and normal permission.  This allows you to perform
         * both {@sa #enforcePermission} and {@sa #enforceUriPermission} in one
         * call.
         *
         * @param uri The Uri whose permission is to be checked, or null to not
         * do this check.
         * @param readPermission The permission that provides overall read access,
         * or null to not do this check.
         * @param writePermission The permission that provides overall write
         * acess, or null to not do this check.
         * @param pid The process ID being checked against.  Must be &gt; 0.
         * @param uid The user ID being checked against.  A uid of 0 is the root
         * user, which will pass every permission check.
         * @param modeFlags The type of access to grant.  May be one or both of
         * {@sa Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
         * {@sa Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
         * @param message A message to include in the exception if it is thrown.
         *
         * @see #checkUriPermission(Uri, String, String, int, int, int)
         */
        EnforceUriPermission(
            [in] IUri* uri,
            [in] String readPermission,
            [in] String writePermission,
            [in] Int32 pid,
            [in] Int32 uid,
            [in] Int32 modeFlags,
            [in] String message);

        /**
         * Return a new Context object for the given application name.  This
         * Context is the same as what the named application gets when it is
         * launched, containing the same resources and class loader.  Each call to
         * this method returns a new instance of a Context object; Context objects
         * are not shared, however they share common state (Resources, ClassLoader,
         * etc) so the Context instance itself is fairly lightweight.
         *
         * <p>Throws {@sa PackageManager.NameNotFoundException} if there is no
         * application with the given package name.
         *
         * <p>Throws {@sa java.lang.SecurityException} if the Context requested
         * can not be loaded into the caller's process for security reasons (see
         * {@sa #CONTEXT_INCLUDE_CODE} for more information}.
         *
         * @param packageName Name of the application's package.
         * @param flags Option flags, one of {@sa #CONTEXT_INCLUDE_CODE}
         *              or {@sa #CONTEXT_IGNORE_SECURITY}.
         *
         * @return A Context for the application.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * java.lang.SecurityException
         * PackageManager.NameNotFoundException | if there is no application with
         * the given package name
         */
        CreatePackageContext(
            [in] String packageName,
            [in] Int32 flags,
            [out] IContext** ctx);

        /**
         * Similar to {@sa #createPackageContext(String, int)}, but with a
         * different {@sa UserHandle}. For example, {@sa #getContentResolver()}
         * will open any {@sa Uri} as the given user.
         *
         * @hide
         */
        CreatePackageContextAsUser(
            [in] String packageName,
            [in] Int32 flags,
            [in] IUserHandle* user,
            [out] IContext** ctx);

        /**
         * Creates a context given an {@link android.content.pm.ApplicationInfo}.
         *
         * @hide
         */
        CreateApplicationContext(
            [in] IApplicationInfo* appInfo,
            [in] Int32 flags,
            [out] IContext** ctx);

        /**
         * Get the userId associated with this context
         * @return user id
         *
         * @hide
         */
         GetUserId(
            [out] Int32* userId);

        /**
         * Return a new Context object for the current Context but whose resources
         * are adjusted to match the given Configuration.  Each call to this method
         * returns a new instance of a Context object; Context objects are not
         * shared, however common state (ClassLoader, other Resources for the
         * same configuration) may be so the Context itself can be fairly lightweight.
         *
         * @param overrideConfiguration A {@sa Configuration} specifying what
         * values to modify in the base Configuration of the original Context's
         * resources.  If the base configuration changes (such as due to an
         * orientation change), the resources of this context will also change except
         * for those that have been explicitly overridden with a value here.
         *
         * @return A Context with the given configuration override.
         */
        CreateConfigurationContext(
            [in] IConfiguration* overrideConfiguration,
            [out] IContext** ctx);

        /**
         * Return a new Context object for the current Context but whose resources
         * are adjusted to match the metrics of the given Display.  Each call to this method
         * returns a new instance of a Context object; Context objects are not
         * shared, however common state (ClassLoader, other Resources for the
         * same configuration) may be so the Context itself can be fairly lightweight.
         *
         * The returned display Context provides a {@sa WindowManager}
         * (see {@sa #getSystemService(String)}) that is configured to show windows
         * on the given display.  The WindowManager's {@sa WindowManager#getDefaultDisplay}
         * method can be used to retrieve the Display from the returned Context.
         *
         * @param display A {@sa Display} object specifying the display
         * for whose metrics the Context's resources should be tailored and upon which
         * new windows should be shown.
         *
         * @return A Context for the display.
         */
        CreateDisplayContext(
            [in] IDisplay* display,
            [out] IContext** ctx);

        /**
         * Gets the display adjustments holder for this context.  This information
         * is provided on a per-application or activity basis and is used to simulate lower density
         * display metrics for legacy applications and restricted screen sizes.
         *
         * @param displayId The display id for which to get compatibility info.
         * @return The compatibility info holder, or null if not required by the application.
         * @hide
         */
        GetDisplayAdjustments(
            [in] Int32 displayId,
            [out] IDisplayAdjustments** da);

        /**
         * Indicates whether this Context is restricted.
         *
         * @return True if this Context is restricted, false otherwise.
         *
         * @see #CONTEXT_RESTRICTED
         */
        IsRestricted(
            [out] Boolean* isRestricted);
    }

    } // namespace Content
    } // namespace Droid
    } // namespace Elastos
}

