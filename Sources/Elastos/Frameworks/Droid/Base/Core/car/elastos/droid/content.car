module
{
    merge("content/AbstractThreadedSyncAdapter.car");
    merge("content/AsyncQueryHandler.car");
    merge("content/AsyncTaskLoader.car");
    merge("content/BroadcastReceiver.car");
    merge("content/ClipData.car");
    merge("content/ClipDescription.car");
    merge("content/ClipboardManager.car");
    merge("content/ComponentCallbacks.car");
    merge("content/ComponentCallbacks2.car");
    merge("content/ComponentName.car");
    merge("content/ContentInsertHandler.car");
    merge("content/ContentProvider.car");
    merge("content/ContentProviderClient.car");
    merge("content/ContentProviderOperation.car");
    merge("content/ContentProviderResult.car");
    merge("content/ContentQueryMap.car");
    merge("content/ContentResolver.car");
    merge("content/ContentUris.car");
    merge("content/ContentValues.car");
    merge("content/Context.car");
    merge("content/ContextWrapper.car");
    merge("content/CursorEntityIterator.car");
    merge("content/CursorLoader.car");
    merge("content/DialogInterface.car");
    merge("content/Entity.car");
    merge("content/EntityIterator.car");
    merge("content/IClipboard.car");
    merge("content/IContentProvider.car");
    merge("content/IContentService.car");
    merge("content/IIntentReceiver.car");
    merge("content/IIntentSender.car");
    merge("content/IOnPrimaryClipChangedListener.car");
    merge("content/IRestrictionsManager.car");
    merge("content/ISyncAdapter.car");
    merge("content/ISyncContext.car");
    merge("content/ISyncServiceAdapter.car");
    merge("content/ISyncStatusObserver.car");
    merge("content/Intent.car");
    merge("content/IntentFilter.car");
    merge("content/IntentSender.car");
    merge("content/Loader.car");
    merge("content/MutableContextWrapper.car");
    merge("content/PeriodicSync.car");
    merge("content/RestrictionEntry.car");
    merge("content/RestrictionsManager.car");
    merge("content/SearchRecentSuggestionsProvider.car");
    merge("content/ServiceConnection.car");
    merge("content/SharedPreferences.car");
    merge("content/SyncAdapterType.car");
    merge("content/SyncContext.car");
    merge("content/SyncInfo.car");
    merge("content/SyncRequest.car");
    merge("content/SyncResult.car");
    merge("content/SyncStats.car");
    merge("content/SyncStatusInfo.car");
    merge("content/SyncStatusObserver.car");
    merge("content/UndoManager.car");
    merge("content/UndoOperation.car");
    merge("content/UndoOwner.car");
    merge("content/UriMatcher.car");
    merge("content/UriPermission.car");


    merge("content/pm/ActivityInfo.car");
    merge("content/pm/ApplicationInfo.car");
    merge("content/pm/ComponentInfo.car");
    merge("content/pm/ConfigurationInfo.car");
    merge("content/pm/ContainerEncryptionParams.car");
    merge("content/pm/FeatureGroupInfo.car");
    merge("content/pm/FeatureInfo.car");
    merge("content/pm/ILauncherApps.car");
    merge("content/pm/IOnAppsChangedListener.car");
    merge("content/pm/IPackageDataObserver.car");
    merge("content/pm/IPackageDeleteObserver.car");
    merge("content/pm/IPackageDeleteObserver2.car");
    merge("content/pm/IPackageInstallObserver.car");
    merge("content/pm/IPackageInstallObserver2.car");
    merge("content/pm/IPackageInstaller.car");
    merge("content/pm/IPackageInstallerCallback.car");
    merge("content/pm/IPackageInstallerSession.car");
    merge("content/pm/IPackageManager.car");
    merge("content/pm/IPackageMoveObserver.car");
    merge("content/pm/IPackageStatsObserver.car");
    merge("content/pm/InstrumentationInfo.car");
    merge("content/pm/KeySet.car");
    merge("content/pm/LabeledIntent.car");
    merge("content/pm/LauncherActivityInfo.car");
    merge("content/pm/LauncherApps.car");
    merge("content/pm/LimitedLengthInputStream.car");
    merge("content/pm/MacAuthenticatedInputStream.car");
    merge("content/pm/ManifestDigest.car");
    merge("content/pm/PackageCleanItem.car");
    merge("content/pm/PackageInfo.car");
    merge("content/pm/PackageInfoLite.car");
    merge("content/pm/PackageInstaller.car");
    merge("content/pm/PackageItemInfo.car");
    merge("content/pm/PackageManager.car");
    merge("content/pm/PackageStats.car");
    merge("content/pm/ParceledListSlice.car");
    merge("content/pm/PathPermission.car");
    merge("content/pm/PermissionGroupInfo.car");
    merge("content/pm/PermissionInfo.car");
    merge("content/pm/ProviderInfo.car");
    merge("content/pm/RegisteredServicesCacheListener.car");
    merge("content/pm/ResolveInfo.car");
    merge("content/pm/ServiceInfo.car");
    merge("content/pm/Signature.car");
    merge("content/pm/UserInfo.car");
    merge("content/pm/VerificationParams.car");
    merge("content/pm/VerifierDeviceIdentity.car");
    merge("content/pm/VerifierInfo.car");
    merge("content/pm/XmlSerializerAndParser.car");

    merge("content/res/AssetFileDescriptor.car");
    merge("content/res/AssetManager.car");
    merge("content/res/ColorStateList.car");
    merge("content/res/CompatibilityInfo.car");
    merge("content/res/Configuration.car");
    merge("content/res/ObbInfo.car");
    merge("content/res/ObbScanner.car");
    merge("content/res/Resources.car");
    merge("content/res/ResourcesKey.car");
    merge("content/res/TypedArray.car");
    merge("content/res/XmlResourceParser.car");

    using interface Elastos.Core.IComparable;
    using interface Elastos.Core.ICloneable;
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.IO.ICloseable;
    using interface Elastos.IO.IFileInputStream;
    using interface Elastos.IO.IFileOutputStream;
    using interface Elastos.IO.IOutputStream;
    using interface Elastos.IO.IInputStream;
    using interface Elastos.IO.IFlushable;
    using interface Elastos.Utility.IObservable;
    using interface Org.Xml.Sax.IContentHandler;

    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.Os.IParcelFileDescriptor;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Database.IContentObserver;
    interface Elastos.Droid.Accounts.IAccount;
    interface Elastos.Droid.Content.ILoader;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Content.Pm.IApplicationInfo;
    interface Elastos.Droid.Utility.IDisplayMetrics;

    namespace Elastos {
    namespace Droid {
    namespace Content {

        class CLoader {
            /**
             * Stores away the application context associated with context.
             * Since Loaders can be used across multiple activities it's dangerous to
             * store the context directly; always use {@link #getContext()} to retrieve
             * the Loader's Context, don't use the constructor argument directly.
             * The Context returned by {@link #getContext} is safe to use across
             * Activity instances.
             *
             * @param context used to retrieve the application context.
             */
            constructor(
                [in] IContext* ctx);

            interface ILoader;
        }

        /**
         * State for a result that is pending for a broadcast receiver.  Returned
         * by {@link BroadcastReceiver#goAsync() goAsync()}
         * while in {@link BroadcastReceiver#onReceive BroadcastReceiver.onReceive()}.
         * This allows you to return from onReceive() without having the broadcast
         * terminate; you must call {@link #finish()} once you are done with the
         * broadcast.  This allows you to process the broadcast off of the main
         * thread of your app.
         *
         * <p>Note on threading: the state inside of this class is not itself
         * thread-safe, however you can use it from any thread if you properly
         * sure that you do not have races.  Typically this means you will hand
         * the entire object to another thread, which will be solely responsible
         * for setting any results and finally calling {@link #finish()}.
         */
        class CPendingResult {
            /** @hide */
            constructor(
                [in] Int32 resultCode,
                [in] String resultData,
                [in] IBundle* resultExtras,
                [in] Int32 type,
                [in] Boolean ordered,
                [in] Boolean sticky,
                [in] IBinder* token,
                [in] Int32 userId);

            interface IPendingResult;
        }

        [deprecated]
        class CClipData {

            constructor();

            /**
             * Create a new clip.
             *
             * @param label Label to show to the user describing this clip.
             * @param mimeTypes An array of MIME types this data is available as.
             * @param item The contents of the first item in the clip.
             */
            constructor(
                [in] ICharSequence* label,
                [in] ArrayOf<String>* mimeTypes,
                [in] IClipDataItem* item);

            /**
             * Create a new clip.
             *
             * @param description The ClipDescription describing the clip contents.
             * @param item The contents of the first item in the clip.
             */
            constructor(
                [in] IClipDescription* description,
                [in] IClipDataItem* item);

            /**
             * Create a new clip that is a copy of another clip.  This does a deep-copy
             * of all items in the clip.
             *
             * @param other The existing ClipData that is to be copied.
             */
            constructor(
                [in] IClipData* other);

            interface IClipData;
            interface IParcelable;
        }

        class CClipDataItem {
            /**
             * Create an Item consisting of a single block of (possibly styled) text.
             */
            constructor(
                [in] ICharSequence* text);

            /**
             * Create an Item consisting of a single block of (possibly styled) text,
             * with an alternative HTML formatted representation.  You <em>must</em>
             * supply a plain text representation in addition to HTML text; coercion
             * will not be done from HTML formated text into plain text.
             */
            constructor(
                [in] ICharSequence* text,
                [in] String htmlText);

            /**
             * Create an Item consisting of an arbitrary Intent.
             */
            constructor(
                [in] IIntent* intent);

            /**
             * Create an Item consisting of an arbitrary URI.
             */
            constructor(
                [in] IUri* uri);

            /**
             * Create a complex Item, containing multiple representations of
             * text, Intent, and/or URI.
             */
            constructor(
                [in] ICharSequence* text,
                [in] IIntent* intent,
                [in] IUri* uri);

            /**
             * Create a complex Item, containing multiple representations of
             * text, HTML text, Intent, and/or URI.  If providing HTML text, you
             * <em>must</em> supply a plain text representation as well; coercion
             * will not be done from HTML formated text into plain text.
             */
            constructor(
                [in] ICharSequence* text,
                [in] String htmlText,
                [in] IIntent* intent,
                [in] IUri* uri);

            interface IClipDataItem;
        }

        singleton class CClipDataHelper {
            interface IClipDataHelper;
        }

        [deprecated]
        class CClipDescription {
            /**
             * Create a new clip.
             *
             * @param label Label to show to the user describing this clip.
             * @param mimeTypes An array of MIME types this data is available as.
             */
            constructor(
                [in] ICharSequence* label,
                [in] ArrayOf<String>* mimeTypes);

            /**
             * Create a copy of a ClipDescription.
             */
            constructor(
                [in] IClipDescription* o);

            constructor();

            interface IClipDescription;
            interface IParcelable;
        }

        singleton class CClipDescriptionHelper {
            interface IClipDescriptionHelper;
        }

        [local]
        class CClipboardManager {
            /** {@hide} */
            constructor(
                [in] IContext* ctx);

            interface IClipboardManager;
            interface Elastos.Droid.Text.IClipboardManager;
        }

        /**
         * Identifier for a specific application component
         * ({@link android.app.Activity}, {@link android.app.Service},
         * {@link android.content.BroadcastReceiver}, or
         * {@link android.content.ContentProvider}) that is available.  Two
         * pieces of information, encapsulated here, are required to identify
         * a component: the package (a String) it exists in, and the class (a String)
         * name inside of that package.
         *
         */
        [local]
        class CComponentName {
            constructor();

            /**
             * Create a new component identifier.
             *
             * @param pkg The name of the package that the component exists in.  Can
             * not be null.
             * @param cls The name of the class inside of <var>pkg</var> that
             * implements the component.  Can not be null.
             */
            constructor(
                [in] String pkg,
                [in] String cls);

            /**
             * Create a new component identifier from a Context and class name.
             *
             * @param pkg A Context for the package implementing the component,
             * from which the actual package name will be retrieved.
             * @param cls The name of the class inside of <var>pkg</var> that
             * implements the component.
             */
            constructor(
                [in] IContext* pkgCtx,
                [in] String cls);

            /**
             * Create a new component identifier from a Context and Class object.
             *
             * @param pkg A Context for the package implementing the component, from
             * which the actual package name will be retrieved.
             * @param cls The Class object of the desired component, from which the
             * actual class name will be retrieved.
             */
            constructor(
                [in] IContext* pkg,
                [in] IClassInfo* IClassInfo);

            interface IComponentName;
            interface IParcelable;
            interface ICloneable;
            interface IComparable;
        }

        singleton class CComponentNameHelper {
            interface IComponentNameHelper;
        }

        singleton class CContentProviderHelper {
            interface IContentProviderHelper;
        }

        class CContentProviderTransport {
            constructor(
                [in] IContentProvider* owner);

            interface IContentProviderTransport;
            interface IIContentProvider;
            interface IBinder;
        }

        /**
         * The public interface object used to interact with a {@link ContentProvider}. This is obtained by
         * calling {@link ContentResolver#acquireContentProviderClient}. This object must be released
         * using {@link #release} in order to indicate to the system that the {@link ContentProvider} is
         * no longer needed and can be killed to free up resources.
         *
         * <p>Note that you should generally create a new ContentProviderClient instance
         * for each thread that will be performing operations.  Unlike
         * {@link ContentResolver}, the methods here such as {@link #query} and
         * {@link #openFile} are not thread safe -- you must not call
         * {@link #release()} on the ContentProviderClient those calls are made from
         * until you are finished with the data they have returned.
         */
        class CContentProviderClient {
            /**
             * @hide
             */
            constructor(
                [in] IContentResolver* resolver,
                [in] IIContentProvider* provider,
                [in] Boolean stable);

            interface IContentProviderClient;
        }

        class CContentProviderOperation {
            /**
            * Creates a {@link ContentProviderOperation} by copying the contents of a
            * {@link Builder}.
            */
            constructor(
                [in] IContentProviderOperationBuilder* operationBuilder);

            constructor();

            interface IContentProviderOperation;
            interface IParcelable;
        }

        class CContentProviderOperationBuilder {
            interface IContentProviderOperationBuilder;
        }

        singleton class CContentProviderOperationHelper {
            interface IContentProviderOperationHelper;
        }

        /**
         * Contains the result of the application of a {@link ContentProviderOperation}. It is guaranteed
         * to have exactly one of {@link #uri} or {@link #count} set.
         */
        class CContentProviderResult {
            constructor(
                [in] IUri* uri);

            constructor(
                [in] Int32 count);

            constructor();

            interface IContentProviderResult;
            interface IParcelable;
        }

        /**
         * Caches the contents of a cursor into a Map of String->ContentValues and optionally
         * keeps the cache fresh by registering for updates on the content backing the cursor. The column of
         * the database that is to be used as the key of the map is user-configurable, and the
         * ContentValues contains all columns other than the one that is designated the key.
         * <p>
         * The cursor data is accessed by row key and column name via getValue().
         */
        class CContentQueryMap {

            constructor(
                [in] ICursor* cursor,
                [in] String columnNameOfKey,
                [in] Boolean keepUpdated,
                [in] IHandler* handlerForUpdateNotifications);

            interface IContentQueryMap;
            interface IObservable;
        }

        /**
         * This class is used to store a set of values that the {@link ContentResolver}
         * can process.
         */
        class CContentValues {
            /**
             * Creates an empty set of values using the default initial size
             */
            constructor();

            /**
             * Creates an empty set of values using the given initial size
             *
             * @param size the initial size of the set of values
             */
            constructor(
                [in] Int32 size);

            /**
             * Creates a set of values copied from the given set
             *
             * @param from the values to copy
             */
            constructor(
                [in] IContentValues* from);

            interface IContentValues;
            interface IParcelable;
        }

        singleton class CContentUris {
            interface IContentUris;
        }

        singleton class CContentResolverHelper {
            interface IContentResolverHelper;
        }

        class CContentResolverOpenResourceIdResult {
            constructor(
                [in] IResources* res,
                [in] Int32 id);

            interface IContentResolverOpenResourceIdResult;
        }

        [local]
        class CContextWrapper {
            constructor(
               [in] IContext* ctx);

           interface IContextWrapper;
           interface IContext;
        }

        [local]
        class CLoaderForceLoadContentObserver {
            constructor(
                [in] ILoader* loader);

            interface ILoaderForceLoadContentObserver;
            interface IContentObserver;
        }

        [deprecated]
        class CCursorLoader {
            constructor(
                [in] IContext* ctx);

            constructor(
                [in] IContext* ctx,
                [in] IUri* uri,
                [in] ArrayOf<String>* projection,
                [in] String selection,
                [in] ArrayOf<String>* selectionArgs,
                [in] String sortOrder);

            interface ICursorLoader;
            interface IAsyncTaskLoader;
            interface ILoader;
        }

        class CDefaultDataHandler {
            interface IContentInsertHandler;
            interface IContentHandler;
        }

        /**
         * A representation of a item using ContentValues. It contains one top level ContentValue
         * plus a collection of Uri, ContentValues tuples as subvalues. One example of its use
         * is in Contacts, where the top level ContentValue contains the columns from the RawContacts
         * table and the subvalues contain a ContentValues object for each row from the Data table that
         * corresponds to that RawContact. The uri refers to the Data table uri for each row.
         */
        class CEntity {
            constructor(
                [in] IContentValues* values);

            interface IEntity;
        }

        class CEntityNamedContentValues {
            constructor(
                [in] IUri* uri,
                [in] IContentValues* values);

            interface IEntityNamedContentValues;
        }

        [local]
        class CIntent {
            constructor();

            constructor(
                [in] IIntent* intent);

            constructor(
                [in] IIntent* intent,
                [in] Boolean all);

            constructor(
                [in] String action);

            constructor(
                [in] String action,
                [in] IUri* uri);

            constructor(
                [in] IContext* packageContext,
                [in] ClassID clsId);

            constructor(
                [in] String action,
                [in] IUri* uri,
                [in] IContext* packageContext,
                [in] IClassInfo* clsinfo);

            interface IIntent;
            interface IParcelable;
            interface ICloneable;
        }

        singleton class CIntentHelper {
            interface IIntentHelper;
        }

        class CIntentFilterComparison {
            constructor(
                [in] IIntent* intent);

            interface IIntentFilterComparison;
        }

        class CIntentFilter {
            constructor();

            constructor(
                [in] String action);

            constructor(
                [in] String action,
                [in] String dataType);

            constructor(
                [in] IIntentFilter* o);

            interface IIntentFilter;
            interface IParcelable;
        }

        singleton class CIntentFilterHelper {
            interface IIntentFilterHelper;
        }

        class CIntentFilterAuthorityEntry {
            constructor();

            constructor(
                [in] String host,
                [in] String port);

            interface IIntentFilterAuthorityEntry;
            interface IParcelable;
        }

        /**
         * Represents a shortcut/live folder icon resource.
         *
         * @see Intent#ACTION_CREATE_SHORTCUT
         * @see Intent#EXTRA_SHORTCUT_ICON_RESOURCE
         * @see android.provider.LiveFolders#ACTION_CREATE_LIVE_FOLDER
         * @see android.provider.LiveFolders#EXTRA_LIVE_FOLDER_ICON
         */
        class CIntentShortcutIconResource {
            constructor();

            interface IIntentShortcutIconResource;
            interface IParcelable;
        }

        singleton class CIntentShortcutIconResourceHelper {
            interface IIntentShortcutIconResourceHelper;
        }

        class CIntentSender {
            constructor();

            interface IIntentSender;
            interface IParcelable;
        }

        singleton class CIntentSenderHelper {
            interface IIntentSenderHelper;
        }

        /**
         * Special version of {@link ContextWrapper} that allows the base context to
         * be modified after it is initially set.
         */
        [local]
        class CMutableContextWrapper {
            constructor(
                [in] IContext* base);

            interface IMutableContextWrapper;
            interface IContextWrapper;
            interface IContext;
        }

        class CPeriodicSync {
            constructor();

            constructor(
                [in] IAccount* account,
                [in] String authority,
                [in] IBundle* extras,
                [in] Int64 period);

            interface IPeriodicSync;
            interface IParcelable;
        }

        [deprecated]
        class CRestrictionEntry {
            constructor();

            constructor(
                [in] Int32 type,
                [in] String key);

            constructor(
                [in] String key,
                [in] String selectedString);

            constructor(
                [in] String key,
                [in] Boolean selectedState);

            constructor(
                [in] String key,
                [in] ArrayOf<String>* selectedStrings);

            constructor(
                [in] String key,
                [in] Int32 selectedInt);

            interface IRestrictionEntry;
            interface IParcelable;
        }

        class CSyncAdapterType {
            constructor();

            constructor(
                [in] String authority,
                [in] String accountType,
                [in] Boolean userVisible,
                [in] Boolean supportsUploading);

            interface ISyncAdapterType;
            interface IParcelable;
        }

        singleton class CSyncAdapterTypeHelper {
            interface ISyncAdapterTypeHelper;
        }

        class CSyncContext {
            interface ISyncContext;
        }

        class CSyncInfo {
            constructor();

            /** @hide */
            constructor(
                [in] Int32 authorityId,
                [in] IAccount* account,
                [in] String authority,
                [in] Int64 startTime);

            interface ISyncInfo;
            interface IParcelable;
        }

        class CSyncRequest {
            constructor();

            interface ISyncRequest;
            interface IParcelable;
        }

        class CSyncRequestBuilder {
            constructor();

            interface ISyncRequestBuilder;
        }

        class CSyncResult {
            constructor();

            constructor(
                [in] Boolean syncAlreadyInProgress);

            interface ISyncResult;
            interface IParcelable;
        }

        singleton class CSyncResultHelper {

            interface ISyncResultHelper;
        }

        class CSyncStats {
            constructor();

            interface ISyncStats;
            interface IParcelable;
        }

        /** @hide */
        class CSyncStatusInfo {
            constructor();

            constructor(
                [in] Int32 authorityId);

            constructor(
                [in] ISyncStatusInfo* other);

            interface ISyncStatusInfo;
            interface IParcelable;
        }

        class CUriMatcher {
            constructor(
                [in] Int32 code);

            interface IUriMatcher;
        }

        class CUriPermission {
            constructor();

            interface IUriPermission;
            interface IParcelable;
        }

        class CSearchRecentSuggestionsProvider {
            interface IContentProvider;
        }

    }//namespace Content
    }//namespace Droid
    }//namespace Elastos

//        namespace Pm {

//     /**
//      * Information you can retrieve about a particular application
//      * activity or receiver. This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;activity&gt; and
//      * &lt;receiver&gt; tags.
//      */
//     class CActivityInfo {
//         constructor();

//         constructor(
//             [in] IActivityInfo* orig);

//         interface IActivityInfo;
//         interface IParcelable;
//     }

//     singleton class CActivityInfoHelper {
//         interface IActivityInfoHelper;
//     }

//     /**
//      * Information you can retrieve about a particular application.  This
//      * corresponds to information collected from the AndroidManifest.xml's
//      * &lt;application&gt; tag.
//      */
//     class CApplicationInfo {
//         constructor();

//         constructor(
//             [in] IApplicationInfo* orig);

//         interface IApplicationInfo;
//         interface IParcelable;
//     }

//     class CApplicationInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IComparator;
//     }

//     /**
//      * Base class containing information common to all application components
//      * ({@link ActivityInfo}, {@link ServiceInfo}).  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all application components.  As such, it does not itself
//      * implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CComponentInfo {
//         constructor();

//         constructor(
//             [in] IComponentInfo* orig);

//         interface IComponentInfo;
//     }

//     /**
//      * Information you can retrieve about hardware configuration preferences
//      * declared by an application. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;uses-configuration&gt; and &lt;uses-feature&gt; tags.
//      */
//     class CConfigurationInfo {
//         constructor();

//         constructor(
//             [in] IConfigurationInfo* orig);

//         interface IConfigurationInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents encryption parameters used to read a container.
//      *
//      * @hide
//      */
// //    [deprecated]
// //    class CContainerEncryptionParams {
// //        constructor();
// //
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey);
// //
// //        /**
// //         * Creates container encryption specifications for installing from encrypted
// //         * containers.
// //         *
// //         * @param encryptionAlgorithm encryption algorithm to use; format matches
// //         *            JCE
// //         * @param encryptionSpec algorithm parameter specification
// //         * @param encryptionKey key used for decryption
// //         * @param macAlgorithm MAC algorithm to use; format matches JCE
// //         * @param macSpec algorithm parameters specification, may be {@code null}
// //         * @param macKey key used for authentication (i.e., for the MAC tag)
// //         * @param macTag message authentication code (MAC) tag for the authenticated
// //         *            data
// //         * @param authenticatedDataStart offset of start of authenticated data in
// //         *            stream
// //         * @param encryptedDataStart offset of start of encrypted data in stream
// //         * @param dataEnd offset of the end of both the authenticated and encrypted
// //         *            data
// //         * @throws InvalidAlgorithmParameterException
// //         */
// //        constructor(
// //            [in] String encryptionAlgorithm,
// //            [in] IAlgorithmParameterSpec* encryptionSpec,
// //            [in] ISecretKey* encryptionKey,
// //            [in] String macAlgorithm,
// //            [in] IAlgorithmParameterSpec* macSpec,
// //            [in] ISecretKey* macKey,
// //            [in] ArrayOf<Byte>* macTag,
// //            [in] Int64 authenticatedDataStart,
// //            [in] Int64 encryptedDataStart,
// //            [in] Int64 dataEnd);
// //
// //        interface IContainerEncryptionParams;
// //        interface IParcelable;
// //    }

//     /**
//      * A single feature that can be requested by an application. This corresponds
//      * to information collected from the
//      * AndroidManifest.xml's &lt;uses-feature&gt; tag.
//      */
//     class CFeatureInfo {
//         constructor();

//         constructor(
//             [in] IFeatureInfo* orig);

//         interface IFeatureInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular piece of test
//      * instrumentation.  This corresponds to information collected
//      * from the AndroidManifest.xml's &lt;instrumentation&gt; tag.
//      */
//     class CInstrumentationInfo {
//         constructor();

//         constructor(
//             [in] IInstrumentationInfo* orig);

//         interface IInstrumentationInfo;
//         interface IPackageItemInfo;
//         interface IParcelable;
//     }

//     /**
//      * A special subclass of Intent that can have a custom label/icon
//      * associated with it.  Primarily for use with {@link Intent#ACTION_CHOOSER}.
//      */
//    class CLabeledIntent {
//        /**
//         * Create a labeled intent from the given intent, supplying the label
//         * and icon resources for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param labelRes Resource containing the label, or 0 if none.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent from the given intent, supplying a textual
//         * label and icon resource for it.
//         *
//         * @param origIntent The original Intent to copy.
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] IIntent* origIntent,
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         /**
//          * Create a labeled intent with no intent data but supplying the label
//          * and icon resources for it.
//          *
//          * @param sourcePackage The package in which the label and icon live.
//          * @param labelRes Resource containing the label, or 0 if none.
//          * @param icon Resource containing the icon, or 0 if none.
//          */
//         constructor(
//             [in] String sourcePackage,
//             [in] Int32 labelRes,
//             [in] Int32 icon);

//        /**
//         * Create a labeled intent with no intent data but supplying a textual
//         * label and icon resource for it.
//         *
//         * @param sourcePackage The package in which the label and icon live.
//         * @param nonLocalizedLabel Concrete text to use for the label.
//         * @param icon Resource containing the icon, or 0 if none.
//         */
//         constructor(
//             [in] String sourcePackage,
//             [in] ICharSequence* nonLocalizedLabel,
//             [in] Int32 icon);

//         constructor();

//        interface ILabeledIntent;
//        interface IParcelable;
//    }

//     /**
//      * A class that limits the amount of data that is read from an InputStream. When
//      * the specified length is reached, the stream returns an EOF even if the
//      * underlying stream still has more data.
//      *
//      * @hide
//      */
//    class CLimitedLengthInputStream {
//        /**
//         * @param in underlying stream to wrap
//         * @param offset offset into stream where data starts
//         * @param length length of data at offset
//         * @throws IOException if an error occurred with the underlying stream
//         */
//        constructor(
//            [in] IInputStream* inStream,
//            [in] Int64 offset,
//            [in] Int64 length);

//        interface ILimitedLengthInputStream;
//    }

//     /**
//      * An input stream filter that applies a MAC to the data passing through it. At
//      * the end of the data that should be authenticated, the tag can be calculated.
//      * After that, the stream should not be used.
//      *
//      * @hide
//      */
//    class CMacAuthenticatedInputStream {
//        constructor(
//            [in] IInputStream* inStream,
//            [in] IMac* mac);

//        interface IMacAuthenticatedInputStream;
//    }

//     /**
//      * Represents the manifest digest for a package. This is suitable for comparison
//      * of two packages to know whether the manifests are identical.
//      *
//      * @hide
//      */
//     [deprecated]
//     class CManifestDigest {
//         constructor();
//         constructor(
//             [in] ArrayOf<Byte>* digest);

//         interface IManifestDigest;
//         interface IParcelable;
//     }

//     singleton class CManifestDigestHelper {
//         interface IManifestDigestHelper;
//     }

//     /** @hide */
//     class CPackageCleanItem {
//         constructor();

//         constructor(
//             [in] Int32 userId,
//             [in] String packageName,
//             [in] Boolean andCode);

//         interface IPackageCleanItem;
//         interface IParcelable;
//     }

//     /**
//      * Overall information about the contents of a package.  This corresponds
//      * to all of the information collected from AndroidManifest.xml.
//      */
//     class CPackageInfo {
//         constructor();

//         interface IPackageInfo;
//         interface IParcelable;
//     }

//     /**
//      * Basic information about a package as specified in its manifest.
//      * Utility class used in PackageManager methods
//      * @hide
//      */
//     class CPackageInfoLite {
//         constructor();

//         interface IPackageInfoLite;
//         interface IParcelable;
//     }

//     /**
//      * Base class containing information common to all package items held by
//      * the package manager.  This provides a very common basic set of attributes:
//      * a label, icon, and meta-data.  This class is not intended
//      * to be used by itself; it is simply here to share common definitions
//      * between all items returned by the package manager.  As such, it does not
//      * itself implement Parcelable, but does provide convenience methods to assist
//      * in the implementation of Parcelable in subclasses.
//      */
//     class CPackageItemInfo {
//         constructor();

//         constructor(
//             [in] IPackageItemInfo* orig);

//         interface IPackageItemInfo;
//     }

//     class CPackageItemInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IPackageItemInfoDisplayNameComparator;
//     }

// //    singleton class CPackageManagerHelper {
// //        interface IPackageManagerHelper;
// //    }

//     /**
//      * implementation of PackageStats associated with a
//      * application package.
//      */
//     class CPackageStats {
//         constructor();

//         constructor(
//             [in] String pkgName);

//         /** @hide */
//         constructor(
//             [in] String pkgName,
//             [in] Int32 userHandle);

//         constructor(
//             [in] IPackageStats* pStats);

//         interface IPackageStats;
//         interface IParcelable;
//     }

//     /**
//      * Builds up a parcel that is discarded when written to another parcel or
//      * written to a list. This is useful for API that sends huge lists across a
//      * Binder that may be larger than the IPC limit.
//      *
//      * @hide
//      */
//     class CParceledListSlice {
//         constructor();

//         interface IParceledListSlice;
//         interface IParcelable;
//     }

//     /**
//      * Description of permissions needed to access a particular path
//      * in a {@link ProviderInfo}.
//      */
//     class CPathPermission {
//         constructor();

//         constructor(
//             [in] String pattern,
//             [in] Int32 type,
//             [in] String readPermission,
//             [in] String writePermission);

//         interface IPathPermission;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * group known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission-group&gt; tags.
//      */
//     class CPermissionGroupInfo {
//         constructor();

//         constructor(
//             [in] IPermissionGroupInfo* orig);

//         interface IPermissionGroupInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information you can retrieve about a particular security permission
//      * known to the system.  This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;permission&gt; tags.
//      */
//     class CPermissionInfo {
//         constructor();

//         constructor(
//             [in] IPermissionInfo* orig);

//         interface IPermissionInfo;
//         interface IParcelable;
//     }

//     singleton class CPermissionInfoHelper {
//         interface IPermissionInfoHelper;
//     }

//     /**
//      * Holds information about a specific
//      * {@link android.content.ContentProvider content provider}. This is returned by
//      * {@link android.content.pm.PackageManager#resolveContentProvider(java.lang.String, int)
//      * PackageManager.resolveContentProvider()}.
//      */
//     class CProviderInfo {
//         constructor();

//         constructor(
//             [in] IProviderInfo* orig);

//         interface IProviderInfo;
//         interface IParcelable;
//     }

//     /**
//      * Information that is returned from resolving an intent
//      * against an IntentFilter. This partially corresponds to
//      * information collected from the AndroidManifest.xml's
//      * &lt;intent&gt; tags.
//      */
//     class CResolveInfo {
//         constructor();

//         constructor(
//             [in] IResolveInfo* orig);

//         interface IResolveInfo;
//         interface IParcelable;
//     }

//     class CResolveInfoDisplayNameComparator {
//         constructor(
//             [in] IPackageManager* pm);

//         interface IResolveInfoDisplayNameComparator;
//     }

//     /**
//      * Information you can retrieve about a particular application
//      * service. This corresponds to information collected from the
//      * AndroidManifest.xml's &lt;service&gt; tags.
//      */
//     class CServiceInfo {
//         constructor();

//         constructor(
//             [in] IServiceInfo* orig);

//         interface IServiceInfo;
//         interface IParcelable;
//     }

//     /**
//      * Opaque, immutable representation of a signature associated with an
//      * application package.
//      */
//     [deprecated]
//     class CSignature {
//         /**
//          * Create Signature from an existing raw byte array.
//          */
//         constructor(
//             [in] ArrayOf<Byte>* signature);

//         /**
//          * Create Signature from a text representation previously returned by
//          * {@link #toChars} or {@link #toCharsString()}. Signatures are expected to
//          * be a hex-encoded ASCII string.
//          *
//          * @param text hex-encoded string representing the signature
//          * @throws IllegalArgumentException when signature is odd-length
//          */
//         constructor(
//             [in] String text);

//         constructor();

//         interface ISignature;
//         interface IParcelable;
//     }

//     /**
//      * Per-user information.
//      * @hide
//      */
//     class CUserInfo {
//         constructor();

//         constructor(
//             [in] IUserInfo* orig);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] Int32 flags);

//         constructor(
//             [in] Int32 id,
//             [in] String name,
//             [in] String iconPath,
//             [in] Int32 flags);

//         interface IUserInfo;
//         interface IParcelable;
//     }

//     /**
//      * Represents verification parameters used to verify packages to be installed.
//      *
//      * @hide
//      */
//      [deprecated]
//      class CVerificationParams {
//          /**
//           * Creates verification specifications for installing with application verification.
//           *
//           * @param verificationURI The location of the supplementary verification
//           *            file. This can be a 'file:' or a 'content:' URI. May be {@code null}.
//           * @param originatingURI URI referencing where the package was downloaded
//           *            from. May be {@code null}.
//           * @param referrer HTTP referrer URI associated with the originatingURI.
//           *            May be {@code null}.
//           * @param originatingUid UID of the application that the install request originated
//           *            from, or NO_UID if not present
//           * @param manifestDigest an object that holds the digest of the package
//           *            which can be used to verify ownership. May be {@code null}.
//           */
//          constructor(
//              [in] IUri* verificationURI,
//              [in] IUri* originatingURI,
//              [in] IUri* referrer,
//              [in] Int32 originatingUid,
//              [in] IManifestDigest* manifestDigest);

//          constructor();

//          interface IVerificationParams;
//          interface IParcelable;
//      }

//     /**
//      * An identity that uniquely identifies a particular device. In this
//      * implementation, the identity is represented as a 64-bit integer encoded to a
//      * 13-character string using RFC 4648's Base32 encoding without the trailing
//      * padding. This makes it easy for users to read and write the code without
//      * confusing 'I' (letter) with '1' (one) or 'O' (letter) with '0' (zero).
//      *
//      * @hide
//      */
//      class CVerifierDeviceIdentity {
//          /**
//           * Create a verifier device identity from a long.
//           *
//           * @param identity device identity in a 64-bit integer.
//           * @throws
//           */
//          constructor(
//              [in] Int64 identity);

//          constructor();

//          interface IVerifierDeviceIdentity;
//          interface IParcelable;
//      }

//      singleton class CVerifierDeviceIdentityHelper {
//          interface IVerifierDeviceIdentityHelper;
//      }

// //    class CVerifierInfo {
// //        /**
// //         * Creates an object that represents a verifier info object.
// //         *
// //         * @param packageName the package name in Java-style. Must not be {@code
// //         *            null} or empty.
// //         * @param publicKey the public key for the signer encoded in Base64. Must
// //         *            not be {@code null} or empty.
// //         * @throws IllegalArgumentException if either argument is null or empty.
// //         */
// //        constructor(
// //            [in] String packageName,
// //            [in] IPublicKey* publicKey);
// //
// //        constructor();
// //
// //        interface IVerifierInfo;
// //        interface IParcelable;
// //    }

//     } // namespace Pm
//     } // namespace Content
//     } // namespace Droid
//     } // namespace Elastos

    namespace Elastos {
    namespace Droid {
    namespace Content {
    namespace Res{

    class CAssetFileDescriptor {

        constructor(
            [in] IParcelFileDescriptor* fd,
            [in] Int64 startOffset,
            [in] Int64 length);

        constructor(
            [in] IParcelFileDescriptor* fd,
            [in] Int64 startOffset,
            [in] Int64 length,
            [in] IBundle* extras);

        constructor();

        interface IAssetFileDescriptor;
        interface IParcelable;
        interface ICloseable;
    }

    class CAssetFileDescriptorAutoCloseInputStream {
        constructor(
            [in] IAssetFileDescriptor* fd);

        interface IAssetFileDescriptorAutoCloseInputStream;
        interface IFileInputStream;
        interface IInputStream;
        interface ICloseable;
    }

    class CAssetFileDescriptorAutoCloseOutputStream {
        constructor(
            [in] IAssetFileDescriptor* fd);

        interface IAssetFileDescriptorAutoCloseOutputStream;
        interface IFileOutputStream;
        interface IOutputStream;
        interface ICloseable;
        interface IFlushable;
    }

    class CAssetManager {

        /**
         * Create a new AssetManager containing only the basic system assets.
         * Applications will not generally use this method, instead retrieving the
         * appropriate asset manager with {@link Resources#getAssets}.    Not for
         * use by applications.
         * {@hide}
         */
        constructor();

        constructor(
            [in] Boolean isSystem);

        interface IAssetManager;
    }

    singleton class CAssetManagerHelper{
        interface IAssetManagerHelper;
    }

    [deprecated]
    class CColorStateList {
        constructor();

        /**
         * Creates a ColorStateList that returns the specified mapping from
         * states to colors.
         */
        constructor(
            [in] ArrayOf<Handle32>* states,
            [in] ArrayOf<Int32>* colors);

        interface IColorStateList;
        interface IParcelable;
    }

    singleton class CColorStateListHelper{

        interface IColorStateListHelper;
    }

    class CCompatibilityInfo {
        constructor(
            [in] IApplicationInfo* appInfo,
            [in] Int32 screenLayout,
            [in] Int32 sw,
            [in] Boolean forceCompat);

        constructor(
            [in] Int32 compFlags,
            [in] Int32 dens,
            [in] Float scale,
            [in] Float invertedScale);

        constructor();

        interface ICompatibilityInfo;
        interface IParcelable;
    }

    singleton class CCompatibilityInfoHelper{
        interface ICompatibilityInfoHelper;
    }

    class CConfiguration{
        /**
         * Construct an invalid Configuration.  You must call {@link #setToDefaults}
         * for this object to be valid.  {@more}
         */
        constructor();

        /**
         * Makes a deep copy suitable for modification.
         */
        constructor(
            [in] IConfiguration* o);

        interface IConfiguration;
        interface IParcelable;
        interface IComparable;
    }

    singleton class CConfigurationHelper{
        interface IConfigurationHelper;
    }

    class CObbInfo {
        constructor();

        interface IObbInfo;
        interface IParcelable;
    }

    singleton class CObbScanner {
        //Don't allow others to instantiate this class

        interface IObbScanner;
    }

    class CResources{
        constructor();

         /**
         * Create a new Resources object on top of an existing set of assets in an
         * AssetManager.
         *
         * @param assets Previously created AssetManager.
         * @param metrics Current display metrics to consider when
         *                selecting/computing resource values.
         * @param config Desired device configuration to consider when
         *               selecting/computing resource values (optional).
         */
        constructor(
            [in] IAssetManager* assets,
            [in] IDisplayMetrics* metrics,
            [in] IConfiguration* config);

        interface IResources;
    }

    singleton class CResourcesHelper {
        interface IResourcesHelper;
    }

    [deprecated]
    class CTypedArray{
        constructor(
            [in] IResources* resources,
            [in] ArrayOf<Int32>* data,
            [in] ArrayOf<Int32>* indices,
            [in] Int32 len);

        interface ITypedArray;
    }

    } // namespace Res
    } // namespace Content
    } // namepsace Droid
    } // namespace Elastos


//     namespace Elastos {
//     namespace Droid {
//     namespace Internal {
//     namespace Content {

//     /**
//      * Native libraries helper.
//      *
//      * @hide
//      */
//     singleton class CNativeLibraryHelper {

//         interface INativeLibraryHelper;
//     }

//     /**
//      * Constants used internally between the PackageManager
//      * and media container service transports.
//      * Some utility methods to invoke MountService api.
//      */
//     singleton class CPackageHelper {

//         interface IPackageHelper;
//     }

//     /**
//      * Helper for building selection clauses for {@link SQLiteDatabase}. Each
//      * appended clause is combined using {@code AND}. This class is <em>not</em>
//      * thread safe.
//      *
//      * @hide
//      */
//     class CSelectionBuilder {

//         interface ISelectionBuilder;
//     }

//     } // namespace Content
//     } // namespace Internal
//     } // namespace Droid
//     } // namespace Elastos

}

