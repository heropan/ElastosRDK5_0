
module
{
    interface Elastos.Droid.View.IKeyEvent;
    interface Elastos.Droid.App.IPendingIntent;
    interface Elastos.Droid.Content.IComponentName;
    interface Elastos.Droid.Bluetooth.IBluetoothDevice;
    interface Elastos.Droid.Media.IIRingtonePlayer;
    interface Elastos.Droid.Media.IRemoteControlClient;
    interface Elastos.Droid.Media.IIRemoteControlDisplay;
    interface Elastos.Droid.Media.IRemoteController;
    interface Elastos.Droid.Media.AudioPolicy.IAudioPolicy;
    interface Elastos.Droid.Media.IAudioPort;
    interface Elastos.Droid.Media.IAudioPatch;
    interface Elastos.Droid.Media.IAudioPortConfig;
    interface Elastos.Droid.Media.IIVolumeController;
    interface Elastos.Utility.IArrayList;

    namespace Elastos {
    namespace Droid {
    namespace Media {

    /**
     * Interface definition for a callback to be invoked when the audio focus of the system is
     * updated.
     */
    interface IAudioManagerOnAudioFocusChangeListener {
        /**
         * Called on the listener to notify it the audio focus for this listener has been changed.
         * The focusChange value indicates whether the focus was gained,
         * whether the focus was lost, and whether that loss is transient, or whether the new focus
         * holder will hold it for an unknown amount of time.
         * When losing focus, listeners can use the focus change information to decide what
         * behavior to adopt when losing focus. A music player could for instance elect to lower
         * the volume of its music stream (duck) for transient focus losses, and pause otherwise.
         * @param focusChange the type of focus change, one of {@link AudioManager#AUDIOFOCUS_GAIN},
         *   {@link AudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT}
         *   and {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}.
         */
        OnAudioFocusChange(
            [in] Int32 focusChange);
    }

    /**
     * Listener registered by client to be notified upon new audio port connections,
     * disconnections or attributes update.
     * @hide
     */
    [deprecated]
    interface IAudioManagerOnAudioPortUpdateListener {
        /**
         * Callback method called upon audio port list update.
         * @param portList the updated list of audio ports
         */
        OnAudioPortListUpdate(
            [in] ArrayOf<IAudioPort*>* portList);

        /**
         * Callback method called upon audio patch list update.
         * @param patchList the updated list of audio patches
         */
        OnAudioPatchListUpdate(
            [in] ArrayOf<IAudioPatch*>* patchList);

        /**
         * Callback method called when the mediaserver dies
         */
        OnServiceDied();
    }

    /**
     * AudioManager provides access to volume and ringer mode control.
     * <p>
     * Use <code>Context.getSystemService(Context.AUDIO_SERVICE)</code> to get
     * an instance of this class.
     */
    [deprecated]
    interface IAudioManager {

        /**
         * Broadcast intent, a hint for applications that audio is about to become
         * 'noisy' due to a change in audio outputs. For example, this intent may
         * be sent when a wired headset is unplugged, or when an A2DP audio
         * sink is disconnected, and the audio system is about to automatically
         * switch audio route to the speaker. Applications that are controlling
         * audio streams may consider pausing, reducing volume or some other action
         * on receipt of this intent so as not to surprise the user with audio
         * from the speaker.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_AUDIO_BECOMING_NOISY = "android.media.AUDIO_BECOMING_NOISY";

        /**
         * Sticky broadcast intent action indicating that the ringer mode has
         * changed. Includes the new ringer mode.
         *
         * @see #EXTRA_RINGER_MODE
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String RINGER_MODE_CHANGED_ACTION = "android.media.RINGER_MODE_CHANGED";

        /**
         * The new ringer mode.
         *
         * @see #RINGER_MODE_CHANGED_ACTION
         * @see #RINGER_MODE_NORMAL
         * @see #RINGER_MODE_SILENT
         * @see #RINGER_MODE_VIBRATE
         */
        const String EXTRA_RINGER_MODE = "android.media.EXTRA_RINGER_MODE";

        /**
         * Broadcast intent action indicating that the vibrate setting has
         * changed. Includes the vibrate type and its new setting.
         *
         * @see #EXTRA_VIBRATE_TYPE
         * @see #EXTRA_VIBRATE_SETTING
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String VIBRATE_SETTING_CHANGED_ACTION = "android.media.VIBRATE_SETTING_CHANGED";

        /**
         * @hide Broadcast intent when the volume for a particular stream type changes.
         * Includes the stream, the new volume and previous volumes.
         * Notes:
         *  - for internal platform use only, do not make public,
         *  - never used for "remote" volume changes
         *
         * @see #EXTRA_VOLUME_STREAM_TYPE
         * @see #EXTRA_VOLUME_STREAM_VALUE
         * @see #EXTRA_PREV_VOLUME_STREAM_VALUE
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String VOLUME_CHANGED_ACTION = "android.media.VOLUME_CHANGED_ACTION";

        /**
         * @hide Broadcast intent when the master volume changes.
         * Includes the new volume
         *
         * @see #EXTRA_MASTER_VOLUME_VALUE
         * @see #EXTRA_PREV_MASTER_VOLUME_VALUE
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String MASTER_VOLUME_CHANGED_ACTION = "android.media.MASTER_VOLUME_CHANGED_ACTION";

        /**
         * @hide Broadcast intent when the master mute state changes.
         * Includes the the new volume
         *
         * @see #EXTRA_MASTER_VOLUME_MUTED
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String MASTER_MUTE_CHANGED_ACTION = "android.media.MASTER_MUTE_CHANGED_ACTION";

        /**
         * The new vibrate setting for a particular type.
         *
         * @see #VIBRATE_SETTING_CHANGED_ACTION
         * @see #EXTRA_VIBRATE_TYPE
         * @see #VIBRATE_SETTING_ON
         * @see #VIBRATE_SETTING_OFF
         * @see #VIBRATE_SETTING_ONLY_SILENT
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
         */
        const String EXTRA_VIBRATE_SETTING = "android.media.EXTRA_VIBRATE_SETTING";

        /**
         * The vibrate type whose setting has changed.
         *
         * @see #VIBRATE_SETTING_CHANGED_ACTION
         * @see #VIBRATE_TYPE_NOTIFICATION
         * @see #VIBRATE_TYPE_RINGER
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
         */
        const String EXTRA_VIBRATE_TYPE = "android.media.EXTRA_VIBRATE_TYPE";

        /**
         * @hide The stream type for the volume changed intent.
         */
        const String EXTRA_VOLUME_STREAM_TYPE = "android.media.EXTRA_VOLUME_STREAM_TYPE";

        /**
         * @hide The volume associated with the stream for the volume changed intent.
         */
        const String EXTRA_VOLUME_STREAM_VALUE = "android.media.EXTRA_VOLUME_STREAM_VALUE";

        /**
         * @hide The previous volume associated with the stream for the volume changed intent.
         */
        const String EXTRA_PREV_VOLUME_STREAM_VALUE = "android.media.EXTRA_PREV_VOLUME_STREAM_VALUE";

        /**
         * @hide The new master volume value for the master volume changed intent.
         * Value is integer between 0 and 100 inclusive.
         */
        const String EXTRA_MASTER_VOLUME_VALUE = "android.media.EXTRA_MASTER_VOLUME_VALUE";

        /**
         * @hide The previous master volume value for the master volume changed intent.
         * Value is integer between 0 and 100 inclusive.
         */
        const String EXTRA_PREV_MASTER_VOLUME_VALUE = "android.media.EXTRA_PREV_MASTER_VOLUME_VALUE";

        /**
         * @hide The new master volume mute state for the master mute changed intent.
         * Value is boolean
         */
        const String EXTRA_MASTER_VOLUME_MUTED = "android.media.EXTRA_MASTER_VOLUME_MUTED";

        /**
         * Broadcast Action: Wired Headset plugged in or unplugged.
         *
         * You <em>cannot</em> receive this through components declared
         * in manifests, only by explicitly registering for it with
         * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver()}.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>name</em> - Headset type, human readable string </li>
         *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
         * </ul>
         * </ul>
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_HEADSET_PLUG =
                "android.intent.action.HEADSET_PLUG";

        /**
         * Broadcast Action: A sticky broadcast indicating an HMDI cable was plugged or unplugged
         *
         * The intent will have the following extra values: {@link #EXTRA_AUDIO_PLUG_STATE},
         * {@link #EXTRA_MAX_CHANNEL_COUNT}, {@link #EXTRA_ENCODINGS}.
         * <p>It can only be received by explicitly registering for it with
         * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)}.
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_HDMI_AUDIO_PLUG =
                "android.media.action.HDMI_AUDIO_PLUG";

        /**
         * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to communicate whether HDMI is plugged in
         * or unplugged.
         * An integer value of 1 indicates a plugged-in state, 0 is unplugged.
         */
        const String EXTRA_AUDIO_PLUG_STATE = "android.media.extra.AUDIO_PLUG_STATE";

        /**
         * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the maximum number of channels
         * supported by the HDMI device.
         * The corresponding integer value is only available when the device is plugged in (as expressed
         * by {@link #EXTRA_AUDIO_PLUG_STATE}).
         */
        const String EXTRA_MAX_CHANNEL_COUNT = "android.media.extra.MAX_CHANNEL_COUNT";

        /**
         * Extra used in {@link #ACTION_HDMI_AUDIO_PLUG} to define the audio encodings supported by
         * the connected HDMI device.
         * The corresponding array of encoding values is only available when the device is plugged in
         * (as expressed by {@link #EXTRA_AUDIO_PLUG_STATE}). Encoding values are defined in
         * {@link AudioFormat} (for instance see {@link AudioFormat#ENCODING_PCM_16BIT}). Use
         * {@link android.content.Intent#getIntArrayExtra(String)} to retrieve the encoding values.
         */
        const String EXTRA_ENCODINGS = "android.media.extra.ENCODINGS";

        /**
         * Broadcast Action: An analog audio speaker/headset plugged in or unplugged.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>name</em> - Headset type, human readable string </li>
         * </ul>
         * </ul>
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_ANALOG_AUDIO_DOCK_PLUG =
                "android.media.action.ANALOG_AUDIO_DOCK_PLUG";

        /**
         * Broadcast Action: A digital audio speaker/headset plugged in or unplugged.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>name</em> - Headset type, human readable string </li>
         * </ul>
         * </ul>
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DIGITAL_AUDIO_DOCK_PLUG =
                "android.media.action.DIGITAL_AUDIO_DOCK_PLUG";

        /**
         * Broadcast Action: A USB audio accessory was plugged in or unplugged.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>card</em> - ALSA card number (integer) </li>
         *   <li><em>device</em> - ALSA device number (integer) </li>
         * </ul>
         * </ul>
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_USB_AUDIO_ACCESSORY_PLUG =
                "android.media.action.USB_AUDIO_ACCESSORY_PLUG";

        /**
         * Broadcast Action: A USB audio device was plugged in or unplugged.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>card</em> - ALSA card number (integer) </li>
         *   <li><em>device</em> - ALSA device number (integer) </li>
         * </ul>
         * </ul>
         * @hide
         */
        // @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_USB_AUDIO_DEVICE_PLUG =
                "android.media.action.USB_AUDIO_DEVICE_PLUG";

        /** The audio stream for phone calls */
        const Int32 STREAM_VOICE_CALL = 0; // IAudioSystem::STREAM_VOICE_CALL;

        /** The audio stream for system sounds */
        const Int32 STREAM_SYSTEM = 1; // IAudioSystem::STREAM_SYSTEM;

        /** The audio stream for the phone ring */
        const Int32 STREAM_RING = 2; // IAudioSystem::STREAM_RING;

        /** The audio stream for music playback */
        const Int32 STREAM_MUSIC = 3; // IAudioSystem::STREAM_MUSIC;

        /** The audio stream for alarms */
        const Int32 STREAM_ALARM = 4; // IAudioSystem::STREAM_ALARM;

        /** The audio stream for notifications */
        const Int32 STREAM_NOTIFICATION = 5; // IAudioSystem::STREAM_NOTIFICATION;

        /** @hide The audio stream for phone calls when connected to bluetooth */
        const Int32 STREAM_BLUETOOTH_SCO = 6; // IAudioSystem::STREAM_BLUETOOTH_SCO;

        /** @hide The audio stream for enforced system sounds in certain countries (e.g camera in Japan) */
        const Int32 STREAM_SYSTEM_ENFORCED = 7; // IAudioSystem::STREAM_SYSTEM_ENFORCED;

        /** The audio stream for DTMF Tones */
        const Int32 STREAM_DTMF = 8; // IAudioSystem::STREAM_DTMF;

        /** @hide The audio stream for text to speech (TTS) */
        const Int32 STREAM_TTS = 9; // IAudioSystem::STREAM_TTS;

        /** Number of audio streams */
        /**
         * @deprecated Use AudioSystem::getNumStreamTypes() instead
         */
        //@Deprecated
        const Int32 NUM_STREAMS = 5; // IAudioSystem::NUM_STREAMS;

        /**  @hide Default volume index values for audio streams */
//      const Int32 DEFAULT_STREAM_VOLUME[] = {
//          4,  // STREAM_VOICE_CALL
//          7,  // STREAM_SYSTEM
//          5,  // STREAM_RING
//          11, // STREAM_MUSIC
//          6,  // STREAM_ALARM
//          5,  // STREAM_NOTIFICATION
//          7,  // STREAM_BLUETOOTH_SCO
//          7,  // STREAM_SYSTEM_ENFORCED
//          11, // STREAM_DTMF
//          11  // STREAM_TTS;
//      };

        /**
         * Increase the ringer volume.
         *
         * @see #adjustVolume(Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         */
        const Int32 ADJUST_RAISE = 1;

        /**
         * Decrease the ringer volume.
         *
         * @see #adjustVolume(Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         */
        const Int32 ADJUST_LOWER = -1;

        /**
         * Maintain the previous ringer volume. This may be useful when needing to
         * show the volume toast without actually modifying the volume.
         *
         * @see #adjustVolume(Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         */
        const Int32 ADJUST_SAME = 0;

        // Flags should be powers of 2!

        /**
         * Show a toast containing the current volume.
         *
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         * @see #adjustVolume(Int32, Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         * @see #setRingerMode(Int32)
         */
        const Int32 FLAG_SHOW_UI = 1 << 0; // 1;

        /**
         * Whether to include ringer modes as possible options when changing volume.
         * For example, if TRUE and volume level is 0 and the volume is adjusted
         * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or
         * vibrate mode.
         * <p>
         * By default this is on for the ring stream. If this flag is included,
         * this behavior will be present regardless of the stream type being
         * affected by the ringer mode.
         *
         * @see #adjustVolume(Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         */
        const Int32 FLAG_ALLOW_RINGER_MODES = 1 << 1; // 2;

        /**
         * Whether to play a sound when changing the volume.
         * <p>
         * If this is given to {@link #adjustVolume(Int32, Int32)} or
         * {@link #adjustSuggestedStreamVolume(Int32, Int32, Int32)}, it may be ignored
         * in some cases (for example, the decided stream type is not
         * {@link AudioManager#STREAM_RING}, or the volume is being adjusted
         * downward).
         *
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         * @see #adjustVolume(Int32, Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         */
        const Int32 FLAG_PLAY_SOUND = 1 << 2; // 4;

        /**
         * Removes any sounds/vibrate that may be in the queue, or are playing (related to
         * changing volume).
         */
        const Int32 FLAG_REMOVE_SOUND_AND_VIBRATE = 1 << 3; // 8;

        /**
         * Whether to vibrate if going into the vibrate ringer mode.
         */
        const Int32 FLAG_VIBRATE = 1 << 4; // 16;

        /**
         * Indicates to VolumePanel that the volume slider should be disabled as user
         * cannot change the stream volume
         * @hide
         */
        const Int32 FLAG_FIXED_VOLUME = 1 << 5; // 32;

        /**
         * Indicates the volume set/adjust call is for Bluetooth absolute volume
         * @hide
         */
        const Int32 FLAG_BLUETOOTH_ABS_VOLUME = 1 << 6;

        /**
         * Adjusting the volume was prevented due to silent mode, display a hint in the UI.
         * @hide
         */
        const Int32 FLAG_SHOW_SILENT_HINT = 1 << 7;

        /**
         * Indicates the volume call is for Hdmi Cec system audio volume
         * @hide
         */
        const Int32 FLAG_HDMI_SYSTEM_AUDIO_VOLUME = 1 << 8;

        /**
         * Indicates that this should only be handled if media is actively playing.
         * @hide
         */
        const Int32 FLAG_ACTIVE_MEDIA_ONLY = 1 << 9;

        /**
         * Like FLAG_SHOW_UI, but only dialog warnings and confirmations, no sliders.
         * @hide
         */
        const Int32 FLAG_SHOW_UI_WARNINGS = 1 << 10;

        /**
         * Ringer mode that will be silent and will not vibrate. (This overrides the
         * vibrate setting.)
         *
         * @see #setRingerMode(Int32)
         * @see #getRingerMode()
         */
        const Int32 RINGER_MODE_SILENT = 0;

        /**
         * Ringer mode that will be silent and will vibrate. (This will cause the
         * phone ringer to always vibrate, but the notification vibrate to only
         * vibrate if set.)
         *
         * @see #setRingerMode(Int32)
         * @see #getRingerMode()
         */
        const Int32 RINGER_MODE_VIBRATE = 1;

        /**
         * Ringer mode that may be audible and may vibrate. It will be audible if
         * the volume before changing out of this mode was audible. It will vibrate
         * if the vibrate setting is on.
         *
         * @see #setRingerMode(Int32)
         * @see #getRingerMode()
         */
        const Int32 RINGER_MODE_NORMAL = 2;

        /**
         * Vibrate type that corresponds to the ringer.
         *
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         * @see #shouldVibrate(Int32)
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode that can be queried via {@link #getRingerMode()}.
         */
        const Int32 VIBRATE_TYPE_RINGER = 0;

        /**
         * Vibrate type that corresponds to notifications.
         *
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         * @see #shouldVibrate(Int32)
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode that can be queried via {@link #getRingerMode()}.
         */
        const Int32 VIBRATE_TYPE_NOTIFICATION = 1;

        /**
         * Vibrate setting that suggests to never vibrate.
         *
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode that can be queried via {@link #getRingerMode()}.
         */
        const Int32 VIBRATE_SETTING_OFF = 0;

        /**
         * Vibrate setting that suggests to vibrate when possible.
         *
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode that can be queried via {@link #getRingerMode()}.
         */
        const Int32 VIBRATE_SETTING_ON = 1;

        /**
         * Vibrate setting that suggests to only vibrate when in the vibrate ringer
         * mode.
         *
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         * @deprecated Applications should maintain their own vibrate policy based on
         * current ringer mode that can be queried via {@link #getRingerMode()}.
         */
        const Int32 VIBRATE_SETTING_ONLY_SILENT = 2;

        /**
         * Suggests using the default stream type. This may not be used in all
         * places a stream type is needed.
         */
        const Int32 USE_DEFAULT_STREAM_TYPE = 0x80000000; // Math::INT32_MIN_VALUE;

        //====================================================================
        // Bluetooth SCO control
        /**
         * Sticky broadcast intent action indicating that the bluetoooth SCO audio
         * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}
         * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}
         * or {@link #SCO_AUDIO_STATE_CONNECTED}
         *
         * @see #startBluetoothSco()
         * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead
         */
        //@Deprecated
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SCO_AUDIO_STATE_CHANGED = "android.media.SCO_AUDIO_STATE_CHANGED";

         /**
         * Sticky broadcast intent action indicating that the bluetoooth SCO audio
         * connection state has been updated.
         * <p>This intent has two extras:
         * <ul>
         *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>
         *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>
         * </ul>
         * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
         * <ul>
         *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>
         *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>
         *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>
         * </ul>
         * @see #startBluetoothSco()
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SCO_AUDIO_STATE_UPDATED = "android.media.ACTION_SCO_AUDIO_STATE_UPDATED";

        /**
         * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} containing the new
         * bluetooth SCO connection state.
         */
        const String EXTRA_SCO_AUDIO_STATE = "android.media.extra.SCO_AUDIO_STATE";

        /**
         * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous
         * bluetooth SCO connection state.
         */
        const String EXTRA_SCO_AUDIO_PREVIOUS_STATE = "android.media.extra.SCO_AUDIO_PREVIOUS_STATE";

        /**
         * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} indicating that the
         * SCO audio channel is not established
         */
        const Int32 SCO_AUDIO_STATE_DISCONNECTED = 0;

        /**
         * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} indicating that the
         * SCO audio channel is established
         */
        const Int32 SCO_AUDIO_STATE_CONNECTED = 1;

        /**
         * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
         * indicating that the SCO audio channel is being established
         */
        const Int32 SCO_AUDIO_STATE_CONNECTING = 2;

        /**
         * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} indicating that
         * there was an error trying to obtain the state
         */
        const Int32 SCO_AUDIO_STATE_ERROR = -1;

        /* modes for setMode/getMode/setRoute/getRoute */
        /**
         * Audio harware modes.
         */
        /**
         * Invalid audio mode.
         */
        const Int32 MODE_INVALID = -2; // IAudioSystem::MODE_INVALID;

        /**
         * Current audio mode. Used to apply audio routing to current mode.
         */
        const Int32 MODE_CURRENT = -1; // IAudioSystem::MODE_CURRENT;

        /**
         * Normal audio mode: not ringing and no call established.
         */
        const Int32 MODE_NORMAL = 0; // IAudioSystem::MODE_NORMAL;

        /**
         * Ringing audio mode. An incoming is being signaled.
         */
        const Int32 MODE_RINGTONE = 1; // IAudioSystem::MODE_RINGTONE;

        /**
         * In call audio mode. A telephony call is established.
         */
        const Int32 MODE_IN_CALL = 2; // IAudioSystem::MODE_IN_CALL;

        /**
         * In communication audio mode. An audio/video chat or VoIP call is established.
         */
        const Int32 MODE_IN_COMMUNICATION = 3; // IAudioSystem::MODE_IN_COMMUNICATION;

        /* Routing bits for setRouting/getRouting API */
        /**
         * Routing audio output to earpiece
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_EARPIECE = 1; // IAudioSystem::ROUTE_EARPIECE;

        /**
         * Routing audio output to speaker
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_SPEAKER = 2; // IAudioSystem::ROUTE_SPEAKER;

        /**
         * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_BLUETOOTH = 4; // IAudioSystem::ROUTE_BLUETOOTH_SCO;

        /**
         * Routing audio output to bluetooth SCO
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_BLUETOOTH_SCO = 4; // IAudioSystem::ROUTE_BLUETOOTH_SCO;

        /**
         * Routing audio output to headset
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_HEADSET = 8; // IAudioSystem::ROUTE_HEADSET;

        /**
         * Routing audio output to bluetooth A2DP
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        const Int32 ROUTE_BLUETOOTH_A2DP = 16; // IAudioSystem::ROUTE_BLUETOOTH_A2DP;

        /**
         * Used for mask parameter of {@link #setRouting(Int32,Int32,Int32)}.
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        const Int32 ROUTE_ALL = 0xFFFFFFFF; // IAudioSystem::ROUTE_ALL;

        /* Sound effect identifiers */
        /**
         * Keyboard and direction pad click sound
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_KEY_CLICK = 0;

        /**
         * Focus has moved up
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_FOCUS_NAVIGATION_UP = 1;

        /**
         * Focus has moved down
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_FOCUS_NAVIGATION_DOWN = 2;

        /**
         * Focus has moved left
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_FOCUS_NAVIGATION_LEFT = 3;

        /**
         * Focus has moved right
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_FOCUS_NAVIGATION_RIGHT = 4;

        /**
         * IME standard keypress sound
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_KEYPRESS_STANDARD = 5;

        /**
         * IME spacebar keypress sound
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_KEYPRESS_SPACEBAR = 6;

        /**
         * IME delete keypress sound
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_KEYPRESS_DELETE = 7;

        /**
         * IME return_keypress sound
         * @see #playSoundEffect(Int32)
         */
        const Int32 FX_KEYPRESS_RETURN = 8;

        /**
         * Invalid keypress sound
         * @see #playSoundEffect(int)
         */
        const Int32 FX_KEYPRESS_INVALID = 9;
        /**
         * @hide Number of sound effects
         */
        const Int32 NUM_SOUND_EFFECTS = 10;

        /**
         * @hide
         * Used to indicate no audio focus has been gained or lost.
         */
        const Int32 AUDIOFOCUS_NONE = 0;

        /**
         * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         * @see #requestAudioFocus(OnAudioFocusChangeListener, Int32, Int32)
         */
        const Int32 AUDIOFOCUS_GAIN = 1;

        /**
         * Used to indicate a temporary gain or request of audio focus, anticipated to last a short
         * amount of time. Examples of temporary changes are the playback of driving directions, or an
         * event notification.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         * @see #requestAudioFocus(OnAudioFocusChangeListener, Int32, Int32)
         */
        const Int32 AUDIOFOCUS_GAIN_TRANSIENT = 2;

        /**
         * Used to indicate a temporary request of audio focus, anticipated to last a short
         * amount of time, and where it is acceptable for other audio applications to keep playing
         * after having lowered their output level (also referred to as "ducking").
         * Examples of temporary changes are the playback of driving directions where playback of music
         * in the background is acceptable.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         * @see #requestAudioFocus(OnAudioFocusChangeListener, Int32, Int32)
         */
        const Int32 AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = 3;

        /**
         * Used to indicate a temporary request of audio focus, anticipated to last a short
         * amount of time, during which no other applications, or system components, should play
         * anything. Examples of exclusive and transient audio focus requests are voice
         * memo recording and speech recognition, during which the system shouldn't play any
         * notifications, and media playback should have paused.
         * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
         */
        const Int32 AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = 4;

        /**
         * Used to indicate a loss of audio focus of unknown duration.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         */
        const Int32 AUDIOFOCUS_LOSS = -1; // -1 * AUDIOFOCUS_GAIN;

        /**
         * Used to indicate a transient loss of audio focus.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         */
        const Int32 AUDIOFOCUS_LOSS_TRANSIENT = -2; // -1 * AUDIOFOCUS_GAIN_TRANSIENT;

        /**
         * Used to indicate a transient loss of audio focus where the loser of the audio focus can
         * lower its output volume if it wants to continue playing (also referred to as "ducking"), as
         * the new focus owner doesn't require others to be silent.
         * @see OnAudioFocusChangeListener#onAudioFocusChange(Int32)
         */
        const Int32 AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK = -3; // -1 * AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;

        /**
         * A failed focus change request.
         */
        const Int32 AUDIOFOCUS_REQUEST_FAILED = 0;

        /**
         * A successful focus change request.
         */
        const Int32 AUDIOFOCUS_REQUEST_GRANTED = 1;

        // This section re-defines new output device constants from AudioSystem, because the AudioSystem
        // class is not used by other parts of the framework, which instead use definitions and methods
        // from AudioManager. AudioSystem is an internal class used by AudioManager and AudioService.

        /** @hide
         * The audio device code for representing "no device." */
        const Int32 DEVICE_NONE = 0x0; //AudioSystem.DEVICE_NONE;

        /** {@hide} The audio output device code for the small speaker at the front of the device used
         *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,
         *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a
         *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.
         */
        const Int32 DEVICE_OUT_EARPIECE = 0x1; // IAudioSystem::DEVICE_OUT_EARPIECE;

        /** {@hide} The audio output device code for the built-in speaker */
        const Int32 DEVICE_OUT_SPEAKER = 0x2; // IAudioSystem::DEVICE_OUT_SPEAKER;

        /** {@hide} The audio output device code for a wired headset with attached microphone */
        const Int32 DEVICE_OUT_WIRED_HEADSET = 0x4; // IAudioSystem::DEVICE_OUT_WIRED_HEADSET;

        /** {@hide} The audio output device code for a wired headphone without attached microphone */
        const Int32 DEVICE_OUT_WIRED_HEADPHONE = 0x8; // IAudioSystem::DEVICE_OUT_WIRED_HEADPHONE;

        /** {@hide} The audio output device code for generic Bluetooth SCO, for voice */
        const Int32 DEVICE_OUT_BLUETOOTH_SCO = 0x10; // IAudioSystem::DEVICE_OUT_BLUETOOTH_SCO;

        /** {@hide} The audio output device code for Bluetooth SCO Headset Profile (HSP) and
         *  Hands-Free Profile (HFP), for voice
         */
        const Int32 DEVICE_OUT_BLUETOOTH_SCO_HEADSET = 0x20; // IAudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET;

        /** {@hide} The audio output device code for Bluetooth SCO car audio, for voice */
        const Int32 DEVICE_OUT_BLUETOOTH_SCO_CARKIT = 0x40; // IAudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT;

        /** {@hide} The audio output device code for generic Bluetooth A2DP, for music */
        const Int32 DEVICE_OUT_BLUETOOTH_A2DP = 0x80; // IAudioSystem::DEVICE_OUT_BLUETOOTH_A2DP;

        /** {@hide} The audio output device code for Bluetooth A2DP headphones, for music */
        const Int32 DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100; // IAudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;

        /** {@hide} The audio output device code for Bluetooth A2DP external speaker, for music */
        const Int32 DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER = 0x200; // IAudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;

        /** {@hide} The audio output device code for S/PDIF or HDMI */
        const Int32 DEVICE_OUT_AUX_DIGITAL = 0x400; // IAudioSystem::DEVICE_OUT_AUX_DIGITAL;

        /** @hide
         * The audio output device code for HDMI */
        const Int32 DEVICE_OUT_HDMI = 0x400; //AudioSystem.DEVICE_OUT_HDMI;

        /** {@hide} The audio output device code for an analog wired headset attached via a
         *  docking station
         */
        const Int32 DEVICE_OUT_ANLG_DOCK_HEADSET = 0x800; // IAudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET;

        /** {@hide} The audio output device code for a digital wired headset attached via a
         *  docking station
         */
        const Int32 DEVICE_OUT_DGTL_DOCK_HEADSET = 0x1000; // IAudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET;

        /** {@hide} The audio output device code for a USB audio accessory. The accessory is in USB host
         * mode and the Android device in USB device mode
         */
        const Int32 DEVICE_OUT_USB_ACCESSORY = 0x2000; // IAudioSystem::DEVICE_OUT_USB_ACCESSORY;

        /** {@hide} The audio output device code for a USB audio device. The device is in USB device
         * mode and the Android device in USB host mode
         */
        const Int32 DEVICE_OUT_USB_DEVICE = 0x4000; // IAudioSystem::DEVICE_OUT_USB_DEVICE;

        /** @hide
         * The audio output device code for projection output.
         */
        const Int32 DEVICE_OUT_REMOTE_SUBMIX = 0x8000; //AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
        /** @hide
         * The audio output device code the telephony voice TX path.
         */
        const Int32 DEVICE_OUT_TELEPHONY_TX = 0x10000; //AudioSystem.DEVICE_OUT_TELEPHONY_TX;
        /** @hide
         * The audio output device code for an analog jack with line impedance detected.
         */
        const Int32 DEVICE_OUT_LINE = 0x20000; //AudioSystem.DEVICE_OUT_LINE;
        /** @hide
         * The audio output device code for HDMI Audio Return Channel.
         */
        const Int32 DEVICE_OUT_HDMI_ARC = 0x40000; //AudioSystem.DEVICE_OUT_HDMI_ARC;
        /** @hide
         * The audio output device code for S/PDIF digital connection.
         */
        const Int32 DEVICE_OUT_SPDIF = 0x80000; //AudioSystem.DEVICE_OUT_SPDIF;
        /** @hide
         * The audio output device code for built-in FM transmitter.
         */
        const Int32 DEVICE_OUT_FM = 0x100000; //AudioSystem.DEVICE_OUT_FM;

        /** {@hide} This is not used as a returned value from {@link #getDevicesForStream}, but could be
         *  used in the future in a set method to select whatever default device is chosen by the
         *  platform-specific implementation.
         */
        const Int32 DEVICE_OUT_DEFAULT = 0x40000000; // IAudioSystem::DEVICE_OUT_DEFAULT;

        /** @hide
         * The audio input device code for default built-in microphone
         */
        const Int32 DEVICE_IN_BUILTIN_MIC = 0x80000004; //AudioSystem.DEVICE_IN_BUILTIN_MIC;
        /** @hide
         * The audio input device code for a Bluetooth SCO headset
         */
        const Int32 DEVICE_IN_BLUETOOTH_SCO_HEADSET = 0x80000008; // AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
        /** @hide
         * The audio input device code for wired headset microphone
         */
        const Int32 DEVICE_IN_WIRED_HEADSET = 0x80000010; // AudioSystem.DEVICE_IN_WIRED_HEADSET;
        /** @hide
         * The audio input device code for HDMI
         */
        const Int32 DEVICE_IN_HDMI = 0x80000020; //AudioSystem.DEVICE_IN_HDMI;
        /** @hide
         * The audio input device code for telephony voice RX path
         */
        const Int32 DEVICE_IN_TELEPHONY_RX = 0x80000040; //AudioSystem.DEVICE_IN_TELEPHONY_RX;
        /** @hide
         * The audio input device code for built-in microphone pointing to the back
         */
        const Int32 DEVICE_IN_BACK_MIC = 0x80000080; //AudioSystem.DEVICE_IN_BACK_MIC;
        /** @hide
         * The audio input device code for analog from a docking station
         */
        const Int32 DEVICE_IN_ANLG_DOCK_HEADSET = 0x80000200; //AudioSystem.DEVICE_IN_ANLG_DOCK_HEADSET;
        /** @hide
         * The audio input device code for digital from a docking station
         */
        const Int32 DEVICE_IN_DGTL_DOCK_HEADSET = 0x80000400; //AudioSystem.DEVICE_IN_DGTL_DOCK_HEADSET;
        /** @hide
         * The audio input device code for a USB audio accessory. The accessory is in USB host
         * mode and the Android device in USB device mode
         */
        const Int32 DEVICE_IN_USB_ACCESSORY = 0x80000800; //AudioSystem.DEVICE_IN_USB_ACCESSORY;
        /** @hide
         * The audio input device code for a USB audio device. The device is in USB device
         * mode and the Android device in USB host mode
         */
        const Int32 DEVICE_IN_USB_DEVICE = 0x80001000; //AudioSystem.DEVICE_IN_USB_DEVICE;
        /** @hide
         * The audio input device code for a FM radio tuner
         */
        const Int32 DEVICE_IN_FM_TUNER = 0x80002000; //AudioSystem.DEVICE_IN_FM_TUNER;
        /** @hide
         * The audio input device code for a TV tuner
         */
        const Int32 DEVICE_IN_TV_TUNER = 0x80004000; //AudioSystem.DEVICE_IN_TV_TUNER;
        /** @hide
         * The audio input device code for an analog jack with line impedance detected
         */
        const Int32 DEVICE_IN_LINE = 0x80008000; //AudioSystem.DEVICE_IN_LINE;
        /** @hide
         * The audio input device code for a S/PDIF digital connection
         */
        const Int32 DEVICE_IN_SPDIF = 0x80010000; //AudioSystem.DEVICE_IN_SPDIF;
        /** @hide
         * The audio input device code for audio loopback
         */
        const Int32 DEVICE_IN_LOOPBACK = 0x80040000; //AudioSystem.DEVICE_IN_LOOPBACK;

        /**
         * Used as a key for {@link #getProperty} to request the native or optimal output sample rate
         * for this device's primary output stream, in decimal Hz.
         */
        const String PROPERTY_OUTPUT_SAMPLE_RATE = "android.media.property.OUTPUT_SAMPLE_RATE";

        /**
         * Used as a key for {@link #getProperty} to request the native or optimal output buffer size
         * for this device's primary output stream, in decimal PCM frames.
         */
        const String PROPERTY_OUTPUT_FRAMES_PER_BUFFER = "android.media.property.OUTPUT_FRAMES_PER_BUFFER";

        /**
         * A special audio session ID to indicate that the audio session ID isn't known and the
         * framework should generate a new value. This can be used when building a new
         * {@link AudioTrack} instance with
         * {@link AudioTrack#AudioTrack(AudioAttributes, AudioFormat, int, int, int)}.
         */
        const Int32 AUDIO_SESSION_ID_GENERATE = 0; //AudioSystem.AUDIO_SESSION_ALLOCATE;

        /**
         * Return codes for listAudioPorts(), createAudioPatch() ...
         */

        /** @hide
         * CANDIDATE FOR PUBLIC API
         */
        const Int32 SUCCESS = 0; //AudioSystem.SUCCESS;
        /**
         * A default error code.
         */
        const Int32 ERROR = -1; //AudioSystem.ERROR;
        /** @hide
         * CANDIDATE FOR PUBLIC API
         */
        const Int32 ERROR_BAD_VALUE = -2; //AudioSystem.BAD_VALUE;
        /** @hide
         */
        const Int32 ERROR_INVALID_OPERATION = -3; //AudioSystem.INVALID_OPERATION;
        /** @hide
         */
        const Int32 ERROR_PERMISSION_DENIED = -4; //AudioSystem.PERMISSION_DENIED;
        /** @hide
         */
        const Int32 ERROR_NO_INIT = -5; //AudioSystem.NO_INIT;
        /**
         * An error code indicating that the object reporting it is no longer valid and needs to
         * be recreated.
         */
        const Int32 ERROR_DEAD_OBJECT = -6; //AudioSystem.DEAD_OBJECT;

        /**
         * Sends a simulated key event for a media button.
         * To simulate a key press, you must first send a KeyEvent built with a
         * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
         * action.
         * <p>The key event will be sent to the current media key event consumer which registered with
         * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
         * @param keyEvent a {@link KeyEvent} instance whose key code is one of
         *     {@link KeyEvent#KEYCODE_MUTE},
         *     {@link KeyEvent#KEYCODE_HEADSETHOOK},
         *     {@link KeyEvent#KEYCODE_MEDIA_PLAY},
         *     {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
         *     {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
         *     {@link KeyEvent#KEYCODE_MEDIA_STOP},
         *     {@link KeyEvent#KEYCODE_MEDIA_NEXT},
         *     {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
         *     {@link KeyEvent#KEYCODE_MEDIA_REWIND},
         *     {@link KeyEvent#KEYCODE_MEDIA_RECORD},
         *     {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
         *     {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
         *     {@link KeyEvent#KEYCODE_MEDIA_EJECT},
         *     or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
         */
        DispatchMediaKeyEvent(
            [in] IKeyEvent* event);

        /**
         * @hide
         */
        PreDispatchKeyEvent(
            [in] IKeyEvent* event,
            [in] Int32 stream);

        /**
         * @hide
         */
        HandleKeyDown(
            [in] IKeyEvent* event,
            [in] Int32 stream);

        /**
         * @hide
         */
        HandleKeyUp(
            [in] IKeyEvent* event,
            [in] Int32 stream);

        /**
         * Indicates if the device implements a fixed volume policy.
         * <p>Some devices may not have volume control and may operate at a fixed volume,
         * and may not enable muting or changing the volume of audio streams.
         * This method will return true on such devices.
         * <p>The following APIs have no effect when volume is fixed:
         * <ul>
         *   <li> {@link #adjustVolume(int, int)}
         *   <li> {@link #adjustSuggestedStreamVolume(int, int, int)}
         *   <li> {@link #adjustStreamVolume(int, int, int)}
         *   <li> {@link #setStreamVolume(int, int, int)}
         *   <li> {@link #setRingerMode(int)}
         *   <li> {@link #setStreamSolo(int, boolean)}
         *   <li> {@link #setStreamMute(int, boolean)}
         * </ul>
         */
        IsVolumeFixed(
            [out] Boolean* result);

        /**
         * Adjusts the volume of a particular stream by one step in a direction.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
         * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
         * {@link #STREAM_ALARM}
         * @param direction The direction to adjust the volume. One of
         *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
         *            {@link #ADJUST_SAME}.
         * @param flags One or more flags.
         * @see #adjustVolume(Int32, Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         */
        AdjustStreamVolume(
            [in] Int32 streamType,
            [in] Int32 direction,
            [in] Int32 flags);

        /**
         * Adjusts the volume of the most relevant stream. For example, if a call is
         * active, it will have the highest priority regardless of if the in-call
         * screen is showing. Another example, if music is playing in the background
         * and a call is not active, the music stream will be adjusted.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param direction The direction to adjust the volume. One of
         *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
         *            {@link #ADJUST_SAME}.
         * @param flags One or more flags.
         * @see #adjustSuggestedStreamVolume(Int32, Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         */
        AdjustVolume(
            [in] Int32 direction,
            [in] Int32 flags);

        /**
         * Adjusts the volume of the most relevant stream, or the given fallback
         * stream.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param direction The direction to adjust the volume. One of
         *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
         *            {@link #ADJUST_SAME}.
         * @param suggestedStreamType The stream type that will be used if there
         *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
         * @param flags One or more flags.
         * @see #adjustVolume(Int32, Int32)
         * @see #adjustStreamVolume(Int32, Int32, Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         */
        AdjustSuggestedStreamVolume(
            [in] Int32 direction,
            [in] Int32 suggestedStreamType,
            [in] Int32 flags);

        /**
         * Adjusts the master volume for the device's audio amplifier.
         * <p>
         *
         * @param steps The number of volume steps to adjust. A positive
         *            value will raise the volume.
         * @param flags One or more flags.
         * @hide
         */
        AdjustMasterVolume(
            [in] Int32 steps,
            [in] Int32 flags);

        /**
         * Returns the current ringtone mode.
         *
         * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
         *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
         * @see #setRingerMode(Int32)
         */
        GetRingerMode(
            [out] Int32* result);

        /**
         * Returns the maximum volume index for a particular stream.
         *
         * @param streamType The stream type whose maximum volume index is returned.
         * @return The maximum valid volume index for the stream.
         * @see #getStreamVolume(Int32)
         */
        GetStreamMaxVolume(
            [in] Int32 streamType,
            [out] Int32* result);

        /**
         * Returns the current volume index for a particular stream.
         *
         * @param streamType The stream type whose volume index is returned.
         * @return The current volume index for the stream.
         * @see #getStreamMaxVolume(Int32)
         * @see #setStreamVolume(Int32, Int32, Int32)
         */
        GetStreamVolume(
            [in] Int32 streamType,
            [out] Int32* result);

        /**
         * Get last audible volume before stream was muted.
         *
         * @hide
         */
        GetLastAudibleStreamVolume(
            [in] Int32 streamType,
            [out] Int32* result);

        /**
         * Get the stream type whose volume is driving the UI sounds volume.
         * UI sounds are screen lock/unlock, camera shutter, key clicks...
         * @hide
         */
        GetMasterStreamType(
            [out] Int32* result);

        /**
         * Sets the ringer mode.
         * <p>
         * Silent mode will mute the volume and will not vibrate. Vibrate mode will
         * mute the volume and vibrate. Normal mode will be audible and may vibrate
         * according to user settings.
         *
         * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
         *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
         * @see #getRingerMode()
         */
        SetRingerMode(
            [in] Int32 ringerMode);

        /**
         * @see #setRingerMode(int)
         * @param checkZen  Update zen mode if necessary to compensate.
         * @hide
         */
        SetRingerMode(
            [in] Int32 ringerMode,
            [in] Boolean checkZen);

        /**
         * Sets the volume index for a particular stream.
         *
         * @param streamType The stream whose volume index should be set.
         * @param index The volume index to set. See
         *            {@link #getStreamMaxVolume(Int32)} for the largest valid value.
         * @param flags One or more flags.
         * @see #getStreamMaxVolume(Int32)
         * @see #getStreamVolume(Int32)
         */
        SetStreamVolume(
            [in] Int32 streamType,
            [in] Int32 index,
            [in] Int32 flags);

        /**
         * Returns the maximum volume index for master volume.
         *
         * @hide
         */
        GetMasterMaxVolume(
            [out] Int32* result);

        /**
         * Returns the current volume index for master volume.
         *
         * @return The current volume index for master volume.
         * @hide
         */
        GetMasterVolume(
            [out] Int32* result);

        /**
         * Get last audible volume before master volume was muted.
         *
         * @hide
         */
        GetLastAudibleMasterVolume(
            [out] Int32* result);

        /**
         * Sets the volume index for master volume.
         *
         * @param index The volume index to set. See
         *            {@link #getMasterMaxVolume(Int32)} for the largest valid value.
         * @param flags One or more flags.
         * @see #getMasterMaxVolume(Int32)
         * @see #getMasterVolume(Int32)
         * @hide
         */
        SetMasterVolume(
            [in] Int32 index,
            [in] Int32 flags);

        /**
         * Solo or unsolo a particular stream. All other streams are muted.
         * <p>
         * The solo command is protected against client process death: if a process
         * with an active solo request on a stream dies, all streams that were muted
         * because of this request will be unmuted automatically.
         * <p>
         * The solo requests for a given stream are cumulative: the AudioManager
         * can receive several solo requests from one or more clients and the stream
         * will be unsoloed only when the same number of unsolo requests are received.
         * <p>
         * For a better user experience, applications MUST unsolo a soloed stream
         * in onPause() and solo is again in onResume() if appropriate.
         *
         * @param streamType The stream to be soloed/unsoloed.
         * @param state The required solo state: TRUE for solo ON, FALSE for solo OFF
         */
        SetStreamSolo(
            [in] Int32 streamType,
            [in] Boolean state);

        /**
         * Mute or unmute an audio stream.
         * <p>
         * The mute command is protected against client process death: if a process
         * with an active mute request on a stream dies, this stream will be unmuted
         * automatically.
         * <p>
         * The mute requests for a given stream are cumulative: the AudioManager
         * can receive several mute requests from one or more clients and the stream
         * will be unmuted only when the same number of unmute requests are received.
         * <p>
         * For a better user experience, applications MUST unmute a muted stream
         * in onPause() and mute is again in onResume() if appropriate.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param streamType The stream to be muted/unmuted.
         * @param state The required mute state: TRUE for mute ON, FALSE for mute OFF
         */
        SetStreamMute(
            [in] Int32 streamType,
            [in] Boolean state);

        /**
         * get stream mute state.
         *
         * @hide
         */
        IsStreamMute(
            [in] Int32 streamType,
            [out] Boolean* result);

        /**
         * set master mute state.
         *
         * @hide
         */
        SetMasterMute(
            [in] Boolean state);

        /**
         * set master mute state with optional flags.
         *
         * @hide
         */
        SetMasterMute(
            [in] Boolean state,
            [in] Int32 flags);

        /**
         * get master mute state.
         *
         * @hide
         */
        IsMasterMute(
            [out] Boolean* result);

        /**
         * forces the stream controlled by hard volume keys
         * specifying streamType == -1 releases control to the
         * logic.
         *
         * @hide
         */
        ForceVolumeControlStream(
            [in] Int32 streamType);

        /**
         * Returns whether a particular type should vibrate according to user
         * settings and the current ringer mode.
         * <p>
         * This shouldn't be needed by most clients that use notifications to
         * vibrate. The notification manager will not vibrate if the policy doesn't
         * allow it, so the client should always set a vibrate pattern and let the
         * notification manager control whether or not to actually vibrate.
         *
         * @param vibrateType The type of vibrate. One of
         *            {@link #VIBRATE_TYPE_NOTIFICATION} or
         *            {@link #VIBRATE_TYPE_RINGER}.
         * @return Whether the type should vibrate at the instant this method is
         *         called.
         * @see #setVibrateSetting(Int32, Int32)
         * @see #getVibrateSetting(Int32)
         */
        ShouldVibrate(
            [in] Int32 vibrateType,
            [out] Boolean* result);

        /**
         * Returns whether the user's vibrate setting for a vibrate type.
         * <p>
         * This shouldn't be needed by most clients that want to vibrate, instead
         * see {@link #shouldVibrate(Int32)}.
         *
         * @param vibrateType The type of vibrate. One of
         *            {@link #VIBRATE_TYPE_NOTIFICATION} or
         *            {@link #VIBRATE_TYPE_RINGER}.
         * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
         *         {@link #VIBRATE_SETTING_OFF}, or
         *         {@link #VIBRATE_SETTING_ONLY_SILENT}.
         * @see #setVibrateSetting(Int32, Int32)
         * @see #shouldVibrate(Int32)
         */
        GetVibrateSetting(
            [in] Int32 vibrateType,
            [out] Int32* result);

        /**
         * Sets the setting for when the vibrate type should vibrate.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param vibrateType The type of vibrate. One of
         *            {@link #VIBRATE_TYPE_NOTIFICATION} or
         *            {@link #VIBRATE_TYPE_RINGER}.
         * @param vibrateSetting The vibrate setting, one of
         *            {@link #VIBRATE_SETTING_ON},
         *            {@link #VIBRATE_SETTING_OFF}, or
         *            {@link #VIBRATE_SETTING_ONLY_SILENT}.
         * @see #getVibrateSetting(Int32)
         * @see #shouldVibrate(Int32)
         */
        SetVibrateSetting(
            [in] Int32 vibrateType,
            [in] Int32 vibrateSetting);

        /**
         * Sets the speakerphone on or off.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param on set <var>TRUE</var> to turn on speakerphone;
         *           <var>FALSE</var> to turn it off
         */
        SetSpeakerphoneOn(
            [in] Boolean on);

        /**
         * Checks whether the speakerphone is on or off.
         *
         * @return TRUE if speakerphone is on, FALSE if it's off
         */
        IsSpeakerphoneOn(
            [out] Boolean* result);

        /**
         * Indicates if current platform supports use of SCO for off call use cases.
         * Application wanted to use bluetooth SCO audio when the phone is not in call
         * must first call thsi method to make sure that the platform supports this
         * feature.
         * @return TRUE if bluetooth SCO can be used for audio when not in call
         *         FALSE otherwise
         * @see #startBluetoothSco()
        */
        IsBluetoothScoAvailableOffCall(
            [out] Boolean* result);

        /**
         * Start bluetooth SCO audio connection.
         * <p>Requires Permission:
         *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
         * <p>This method can be used by applications wanting to send and received audio
         * to/from a bluetooth SCO headset while the phone is not in call.
         * <p>As the SCO connection establishment can take several seconds,
         * applications should not rely on the connection to be available when the method
         * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
         * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
         * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
         * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
         * registration. If the state is already CONNECTED, no state change will be received via the
         * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
         * so that the connection stays active in case the current initiator stops the connection.
         * <p>Unless the connection is already active as described above, the state will always
         * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
         * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
         * <p>When finished with the SCO connection or if the establishment fails, the application must
         * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
         * <p>Even if a SCO connection is established, the following restrictions apply on audio
         * output streams so that they can be routed to SCO headset:
         * <ul>
         *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
         *   <li> the format must be mono </li>
         *   <li> the sampling must be 16kHz or 8kHz </li>
         * </ul>
         * <p>The following restrictions apply on input streams:
         * <ul>
         *   <li> the format must be mono </li>
         *   <li> the sampling must be 8kHz </li>
         * </ul>
         * <p>Note that the phone application always has the priority on the usage of the SCO
         * connection for telephony. If this method is called while the phone is in call
         * it will be ignored. Similarly, if a call is received or sent while an application
         * is using the SCO connection, the connection will be lost for the application and NOT
         * returned automatically when the call ends.
         * @see #stopBluetoothSco()
         * @see #ACTION_SCO_AUDIO_STATE_UPDATED
         */
        StartBluetoothSco();

        /**
         * @hide
         * Start bluetooth SCO audio connection in virtual call mode.
         * <p>Requires Permission:
         *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
         * <p>Similar to {@link #startBluetoothSco()} with explicit selection of virtual call mode.
         * Telephony and communication applications (VoIP, Video Chat) should preferably select
         * virtual call mode.
         * Applications using voice input for search or commands should first try raw audio connection
         * with {@link #startBluetoothSco()} and fall back to startBluetoothScoVirtualCall() in case of
         * failure.
         * @see #startBluetoothSco()
         * @see #stopBluetoothSco()
         * @see #ACTION_SCO_AUDIO_STATE_UPDATED
         */
        StartBluetoothScoVirtualCall();

        /**
         * Stop bluetooth SCO audio connection.
         * <p>Requires Permission:
         *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
         * <p>This method must be called by applications having requested the use of
         * bluetooth SCO audio with {@link #startBluetoothSco()}
         * when finished with the SCO connection or if the establishment times out.
         * @see #startBluetoothSco()
         */
        StopBluetoothSco();

        /**
         * Request use of Bluetooth SCO headset for communications.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param on set <var>TRUE</var> to use bluetooth SCO for communications;
         *               <var>FALSE</var> to not use bluetooth SCO for communications
         */
        SetBluetoothScoOn(
            [in] Boolean on);

        /**
         * Checks whether communications use Bluetooth SCO.
         *
         * @return TRUE if SCO is used for communications;
         *         FALSE if otherwise
         */
        IsBluetoothScoOn(
            [out] Boolean* result);

        /**
         * @param on set <var>TRUE</var> to route A2DP audio to/from Bluetooth
         *           headset; <var>FALSE</var> disable A2DP audio
         * @deprecated Do not use.
         */
        //@Deprecated
        SetBluetoothA2dpOn(
            [in] Boolean on);

        /**
         * Checks whether A2DP audio routing to the Bluetooth headset is on or off.
         *
         * @return TRUE if A2DP audio is being routed to/from Bluetooth headset;
         *         FALSE if otherwise
         */
        IsBluetoothA2dpOn(
            [out] Boolean* result);

        /**
         * Sets audio routing to the wired headset on or off.
         *
         * @param on set <var>TRUE</var> to route audio to/from wired
         *           headset; <var>FALSE</var> disable wired headset audio
         * @deprecated Do not use.
         */
        //@Deprecated
        SetWiredHeadsetOn(
            [in] Boolean on);

        /**
         * Checks whether a wired headset is connected or not.
         * <p>This is not a valid indication that audio playback is
         * actually over the wired headset as audio routing depends on other conditions.
         *
         * @return true if a wired headset is connected.
         *         false if otherwise
         * @deprecated Use only to check is a headset is connected or not.
         */
        IsWiredHeadsetOn(
            [out] Boolean* result);

        /**
         * Sets the microphone mute on or off.
         * <p>
         * This method should only be used by applications that replace the platform-wide
         * management of audio settings or the main telephony application.
         *
         * @param on set <var>TRUE</var> to mute the microphone;
         *           <var>FALSE</var> to turn mute off
         */
        SetMicrophoneMute(
            [in] Boolean on);

        /**
         * Checks whether the microphone mute is on or off.
         *
         * @return TRUE if microphone is muted, FALSE if it's not
         */
        IsMicrophoneMute(
            [out] Boolean* result);

        /**
         * Sets the audio mode.
         * <p>
         * The audio mode encompasses audio routing AND the behavior of
         * the telephony layer. Therefore this method should only be used by applications that
         * replace the platform-wide management of audio settings or the main telephony application.
         * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
         * application when it places a phone call, as it will cause signals from the radio layer
         * to feed the platform mixer.
         *
         * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).
         *              Informs the HAL about the current audio state so that
         *              it can route the audio appropriately.
         */
        SetMode(
            [in] Int32 mode);

        /**
         * Returns the current audio mode.
         *
         * @return      the current audio mode (NORMAL, RINGTONE, or IN_CALL).
         *              Returns the current current audio state from the HAL.
         */
        GetMode(
            [out] Int32* result);

        /**
         * Sets the audio routing for a specified mode
         *
         * @param mode   audio mode to change route. E.g., MODE_RINGTONE.
         * @param routes bit vector of routes requested, created from one or
         *               more of ROUTE_xxx types. Set bits indicate that route should be on
         * @param mask   bit vector of routes to change, created from one or more of
         * ROUTE_xxx types. Unset bits indicate the route should be left unchanged
         *
         * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
         * setBluetoothScoOn() methods instead.
         */
        //@Deprecated
        SetRouting(
            [in] Int32 mode,
            [in] Int32 routes,
            [in] Int32 mask);

        /**
         * Returns the current audio routing bit vector for a specified mode.
         *
         * @param mode audio mode to get route (e.g., MODE_RINGTONE)
         * @return an audio route bit vector that can be compared with ROUTE_xxx
         * bits
         * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),
         * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
         */
        //@Deprecated
        GetRouting(
            [in] Int32 mode,
            [out] Int32* result);

        /**
         * Checks whether any music is active.
         *
         * @return TRUE if any music tracks are active.
         */
        IsMusicActive(
            [out] Boolean* result);

        /**
         * @hide
         * Checks whether any music or media is actively playing on a remote device (e.g. wireless
         *   display). Note that BT audio sinks are not considered remote devices.
         * @return true if {@link AudioManager#STREAM_MUSIC} is active on a remote device
         */
        IsMusicActiveRemotely(
            [out] Boolean* result);

        /**
         * @hide
         * Checks whether the current audio focus is exclusive.
         * @return true if the top of the audio focus stack requested focus
         *     with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}
         */
        IsAudioFocusExclusive(
            [out] Boolean* result);

        /**
         * Return a new audio session identifier not associated with any player or effect.
         * An audio session identifier is a system wide unique identifier for a set of audio streams
         * (one or more mixed together).
         * <p>The primary use of the audio session ID is to associate audio effects to audio players,
         * such as {@link MediaPlayer} or {@link AudioTrack}: all audio effects sharing the same audio
         * session ID will be applied to the mixed audio content of the players that share the same
         * audio session.
         * <p>This method can for instance be used when creating one of the
         * {@link android.media.audiofx.AudioEffect} objects to define the audio session of the effect,
         * or to specify a session for a speech synthesis utterance
         * in {@link android.speech.tts.TextToSpeech.Engine}.
         * @return a new unclaimed and unused audio session identifier, or {@link #ERROR} when the
         *   system failed to generate a new session, a condition in which audio playback or recording
         *   will subsequently fail as well.
         */
        GenerateAudioSessionId(
            [out] Int32* result);

        /*
         * Sets a generic audio configuration parameter. The use of these parameters
         * are platform dependant, see libaudio
         *
         * ** Temporary interface - DO NOT USE
         *
         * TODO: Replace with a more generic key:value get/set mechanism
         *
         * param key   name of parameter to set. Must not be null.
         * param value value of parameter. Must not be null.
         */
        /**
         * @hide
         * @deprecated Use {@link #setPrameters(String)} instead
         */
        //@Deprecated
        SetParameter(
            [in] String key,
            [in] String value);

        /**
         * Sets a variable number of parameter values to audio hardware.
         *
         * @param keyValuePairs list of parameters key value pairs in the form:
         *    key1=value1;key2=value2;...
         *
         */
        SetParameters(
            [in] String keyValuePairs);

        /**
         * Sets a varaible number of parameter values to audio hardware.
         *
         * @param keys list of parameters
         * @return list of parameters key value pairs in the form:
         *    key1=value1;key2=value2;...
         */
        GetParameters(
            [in] String keys,
            [out] String* result);

        /**
         * Plays a sound effect (Key clicks, lid open/close...)
         * @param effectType The type of sound effect. One of
         *            {@link #FX_KEY_CLICK},
         *            {@link #FX_FOCUS_NAVIGATION_UP},
         *            {@link #FX_FOCUS_NAVIGATION_DOWN},
         *            {@link #FX_FOCUS_NAVIGATION_LEFT},
         *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
         *            {@link #FX_KEYPRESS_STANDARD},
         *            {@link #FX_KEYPRESS_SPACEBAR},
         *            {@link #FX_KEYPRESS_DELETE},
         *            {@link #FX_KEYPRESS_RETURN},
         * NOTE: This version uses the UI settings to determine
         * whether sounds are heard or not.
         */
        PlaySoundEffect(
            [in] Int32 effectType);

        /**
         * Plays a sound effect (Key clicks, lid open/close...)
         * @param effectType The type of sound effect. One of
         *            {@link #FX_KEY_CLICK},
         *            {@link #FX_FOCUS_NAVIGATION_UP},
         *            {@link #FX_FOCUS_NAVIGATION_DOWN},
         *            {@link #FX_FOCUS_NAVIGATION_LEFT},
         *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
         *            {@link #FX_KEYPRESS_STANDARD},
         *            {@link #FX_KEYPRESS_SPACEBAR},
         *            {@link #FX_KEYPRESS_DELETE},
         *            {@link #FX_KEYPRESS_RETURN},
         *            {@link #FX_KEYPRESS_INVALID},
         * @param userId The current user to pull sound settings from
         * NOTE: This version uses the UI settings to determine
         * whether sounds are heard or not.
         * @hide
         */
        PlaySoundEffect(
            [in] Int32 effectType,
            [in] Int32 userId);

        /**
         * Plays a sound effect (Key clicks, lid open/close...)
         * @param effectType The type of sound effect. One of
         *            {@link #FX_KEY_CLICK},
         *            {@link #FX_FOCUS_NAVIGATION_UP},
         *            {@link #FX_FOCUS_NAVIGATION_DOWN},
         *            {@link #FX_FOCUS_NAVIGATION_LEFT},
         *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
         *            {@link #FX_KEYPRESS_STANDARD},
         *            {@link #FX_KEYPRESS_SPACEBAR},
         *            {@link #FX_KEYPRESS_DELETE},
         *            {@link #FX_KEYPRESS_RETURN},
         * @param volume Sound effect volume.
         * The volume value is a raw scalar so UI controls should be scaled logarithmically.
         * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
         * NOTE: This version is for applications that have their own
         * settings panel for enabling and controlling volume.
         */
        PlaySoundEffect(
            [in] Int32 effectType,
            [in] Float volume);

        /**
         *  Load Sound effects.
         *  This method must be called when sound effects are enabled.
         */
        LoadSoundEffects();

        /**
         *  Unload Sound effects.
         *  This method can be called to free some memory when
         *  sound effects are disabled.
         */
        UnloadSoundEffects();

        /**
         * @hide
         * Registers a listener to be called when audio focus changes. Calling this method is optional
         * before calling {@link #requestAudioFocus(IOnAudioFocusChangeListener, Int32, Int32)}, as it
         * will register the listener as well if it wasn't registered already.
         * @param l the listener to be notified of audio focus changes.
         */
        RegisterAudioFocusListener(
            [in] IAudioManagerOnAudioFocusChangeListener* l);

        /**
         * @hide
         * Causes the specified listener to not be called anymore when focus is gained or lost.
         * @param l the listener to unregister.
         */
        UnregisterAudioFocusListener(
            [in] IAudioManagerOnAudioFocusChangeListener* l);

        /**
         *  Request audio focus.
         *  Send a request to obtain the audio focus
         *  @param l the listener to be notified of audio focus changes
         *  @param streamType the main audio stream type affected by the focus request
         *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
         *      is temporary, and focus will be abandonned shortly. Examples of transient requests are
         *      for the playback of driving directions, or notifications sounds.
         *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
         *      the previous focus owner to keep playing if it ducks its audio output.
         *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
         *      as the playback of a song or a video.
         *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
         */
        RequestAudioFocus(
            [in] IAudioManagerOnAudioFocusChangeListener* l,
            [in] Int32 streamType,
            [in] Int32 durationHint,
            [out] Int32* result);

        /**
         * @hide
         * Used internally by telephony package to request audio focus. Will cause the focus request
         * to be associated with the "voice communication" identifier only used in AudioService
         * to identify this use case.
         * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
         *    the establishment of the call
         * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
         *    media applications resume after a call
         */
        RequestAudioFocusForCall(
            [in] Int32 streamType,
            [in] Int32 durationHint);

        /**
         * @hide
         * Used internally by telephony package to abandon audio focus, typically after a call or
         * when ringing ends and the call is rejected or not answered.
         * Should match one or more calls to {@link #requestAudioFocusForCall(Int32, Int32)}.
         */
        AbandonAudioFocusForCall();

        /**
         *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
         *  @param l the listener with which focus was requested.
         *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
         */
        AbandonAudioFocus(
            [in] IAudioManagerOnAudioFocusChangeListener* l,
            [out] Int32* result);

        //====================================================================
        // Remote Control
        /**
         * Register a component to be the sole receiver of MEDIA_BUTTON intents.
         * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
         *      that will receive the media button intent. This broadcast receiver must be declared
         *      in the application manifest.
         */
        RegisterMediaButtonEventReceiver(
            [in] IComponentName* eventReceiver);

        /**
         * Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like
         * {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows
         * the buttons to go to any PendingIntent.  Note that you should only use this form if
         * you know you will continue running for the full time until unregistering the
         * PendingIntent.
         * @param eventReceiver target that will receive media button intents.  The PendingIntent
         * will be sent an {@link Intent#ACTION_MEDIA_BUTTON} event when a media button action
         * occurs, with {@link Intent#EXTRA_KEY_EVENT} added and holding the key code of the
         * media button that was pressed.
         * @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.
         */
        // @Deprecated
        RegisterMediaButtonEventReceiver(
            [in] IPendingIntent* eventReceiver);

        /**
         * @hide
         * no-op if (pi == null) or (eventReceiver == null)
         */
        RegisterMediaButtonIntent(
            [in] IPendingIntent* pi,
            [in] IComponentName* eventReceiver);

        /**
         * Unregister the receiver of MEDIA_BUTTON intents.
         * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
         *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.
         */
        UnregisterMediaButtonEventReceiver(
            [in] IComponentName* eventReceiver);

        /**
         * Unregister the receiver of MEDIA_BUTTON intents.
         * @param eventReceiver same PendingIntent that was registed with
         *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.
         * @deprecated Use {@link MediaSession} instead.
         */
        // @Deprecated
        UnregisterMediaButtonEventReceiver(
            [in] IPendingIntent* eventReceiver);

        /**
         * @hide
         */
        UnregisterMediaButtonIntent(
            [in] IPendingIntent* pi);

        /**
         * Registers the remote control client for providing information to display on the remote
         * controls.
         * @param rcClient The remote control client from which remote controls will receive
         *      information to display.
         * @see RemoteControlClient
         * @deprecated Use {@link MediaSession} instead.
         */
        // @Deprecated
        RegisterRemoteControlClient(
            [in] IRemoteControlClient* rcClient);

        /**
         * Unregisters the remote control client that was providing information to display on the
         * remote controls.
         * @param rcClient The remote control client to unregister.
         * @see #registerRemoteControlClient(RemoteControlClient)
         * @deprecated Use {@link MediaSession} instead.
         */
        // @Deprecated
        UnregisterRemoteControlClient(
            [in] IRemoteControlClient* rcClient);

        /**
         * Registers a {@link RemoteController} instance for it to receive media
         * metadata updates and playback state information from applications using
         * {@link RemoteControlClient}, and control their playback.
         * <p>
         * Registration requires the {@link OnClientUpdateListener} listener to be
         * one of the enabled notification listeners (see
         * {@link android.service.notification.NotificationListenerService}).
         *
         * @param rctlr the object to register.
         * @return true if the {@link RemoteController} was successfully registered,
         *         false if an error occurred, due to an internal system error, or
         *         insufficient permissions.
         * @deprecated Use
         *             {@link MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)}
         *             and {@link MediaController} instead.
         */
        // @Deprecated
        RegisterRemoteController(
            [in] IRemoteController* rctlr,
            [out] Boolean* result);

        /**
         * Unregisters a {@link RemoteController}, causing it to no longer receive
         * media metadata and playback state information, and no longer be capable
         * of controlling playback.
         *
         * @param rctlr the object to unregister.
         * @deprecated Use
         *             {@link MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)}
         *             instead.
         */
        // @Deprecated
        UnregisterRemoteController(
            [in] IRemoteController* rctlr);

        /**
         * @hide
         * Registers a remote control display that will be sent information by remote control clients.
         * Use this method if your IRemoteControlDisplay is not going to display artwork, otherwise
         * use {@link #registerRemoteControlDisplay(IRemoteControlDisplay, int, int)} to pass the
         * artwork size directly, or
         * {@link #remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay, int, int)} later if artwork
         * is not yet needed.
         * <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
         * @param rcd the IRemoteControlDisplay
         */
        RegisterRemoteControlDisplay(
            [in] IIRemoteControlDisplay* rcd);

        /**
         * @hide
         * Registers a remote control display that will be sent information by remote control clients.
         * <p>Registration requires the {@link Manifest.permission#MEDIA_CONTENT_CONTROL} permission.
         * @param rcd
         * @param w the maximum width of the expected bitmap. Negative values indicate it is
         *   useless to send artwork.
         * @param h the maximum height of the expected bitmap. Negative values indicate it is
         *   useless to send artwork.
         */
        RegisterRemoteControlDisplay(
            [in] IIRemoteControlDisplay* rcd,
            [in] Int32 w,
            [in] Int32 h);

        /**
         * @hide
         * Unregisters a remote control display that was sent information by remote control clients.
         * @param rcd
         */
        UnregisterRemoteControlDisplay(
            [in] IIRemoteControlDisplay* rcd);

        /**
         * @hide
         * Sets the artwork size a remote control display expects when receiving bitmaps.
         * @param rcd
         * @param w the maximum width of the expected bitmap. Negative values indicate it is
         *   useless to send artwork.
         * @param h the maximum height of the expected bitmap. Negative values indicate it is
         *   useless to send artwork.
         */
        RemoteControlDisplayUsesBitmapSize(
            [in] IIRemoteControlDisplay* rcd,
            [in] Int32 w,
            [in] Int32 h);

        /**
         * @hide
         * Controls whether a remote control display needs periodic checks of the RemoteControlClient
         * playback position to verify that the estimated position has not drifted from the actual
         * position. By default the check is not performed.
         * The IRemoteControlDisplay must have been previously registered for this to have any effect.
         * @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
         *     or disabled. No effect is null.
         * @param wantsSync if true, RemoteControlClient instances which expose their playback position
         *     to the framework will regularly compare the estimated playback position with the actual
         *     position, and will update the IRemoteControlDisplay implementation whenever a drift is
         *     detected.
         */
        RemoteControlDisplayWantsPlaybackPositionSync(
            [in] IIRemoteControlDisplay* rcd,
            [in] Boolean wantsSync);

        /**
         * @hide
         * CANDIDATE FOR PUBLIC API
         * Register the given {@link AudioPolicy}.
         * This call is synchronous and blocks until the registration process successfully completed
         * or failed to complete.
         * @param policy the {@link AudioPolicy} to register.
         * @return {@link #ERROR} if there was an error communicating with the registration service
         *    or if the user doesn't have the required
         *    {@link android.Manifest.permission#MODIFY_AUDIO_ROUTING} permission,
         *    {@link #SUCCESS} otherwise.
         */
        RegisterAudioPolicy(
            [in] IAudioPolicy* policy,
            [out] Int32* result);

        /**
         * @hide
         * CANDIDATE FOR PUBLIC API
         * @param policy the {@link AudioPolicy} to unregister.
         */
        UnregisterAudioPolicyAsync(
            [in] IAudioPolicy* policy);

        /**
         *  @hide
         *  Reload audio settings. This method is called by Settings backup
         *  agent when audio settings are restored and causes the AudioService
         *  to read and apply restored settings.
         */
        ReloadAudioSettings();

        /**
         * @hide
         * Notifies AudioService that it is connected to an A2DP device that supports absolute volume,
         * so that AudioService can send volume change events to the A2DP device, rather than handling
         * them.
         */
        AvrcpSupportsAbsoluteVolume(
            [in] String address,
            [in] Boolean support);

        /**
         * Checks whether the phone is in silent mode, with or without vibrate.
         *
         * @return true if phone is in silent mode, with or without vibrate.
         *
         * @see #getRingerMode()
         *
         * @hide pending API Council approval
         */
        IsSilentMode(
            [out] Boolean* result);

        /**
         * Return the enabled devices for the specified output stream type.
         *
         * @param streamType The stream type to query. One of
         *            {@link #STREAM_VOICE_CALL},
         *            {@link #STREAM_SYSTEM},
         *            {@link #STREAM_RING},
         *            {@link #STREAM_MUSIC},
         *            {@link #STREAM_ALARM},
         *            {@link #STREAM_NOTIFICATION},
         *            {@link #STREAM_DTMF}.
         *
         * @return The bit-mask "or" of audio output device codes for all enabled devices on this
         *         stream. Zero or more of
         *            {@link #DEVICE_OUT_EARPIECE},
         *            {@link #DEVICE_OUT_SPEAKER},
         *            {@link #DEVICE_OUT_WIRED_HEADSET},
         *            {@link #DEVICE_OUT_WIRED_HEADPHONE},
         *            {@link #DEVICE_OUT_BLUETOOTH_SCO},
         *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},
         *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},
         *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},
         *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},
         *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},
         *            {@link #DEVICE_OUT_HDMI},
         *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},
         *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.
         *            {@link #DEVICE_OUT_USB_ACCESSORY}.
         *            {@link #DEVICE_OUT_USB_DEVICE}.
         *            {@link #DEVICE_OUT_REMOTE_SUBMIX}.
         *            {@link #DEVICE_OUT_TELEPHONY_TX}.
         *            {@link #DEVICE_OUT_LINE}.
         *            {@link #DEVICE_OUT_HDMI_ARC}.
         *            {@link #DEVICE_OUT_SPDIF}.
         *            {@link #DEVICE_OUT_FM}.
         *            {@link #DEVICE_OUT_DEFAULT} is not used here.
         *
         * The implementation may support additional device codes beyond those listed, so
         * the application should ignore any bits which it does not recognize.
         * Note that the information may be imprecise when the implementation
         * cannot distinguish whether a particular device is enabled.
         *
         * {@hide}
         */
        GetDevicesForStream(
            [in] Int32 streamType,
            [out] Int32* result);

         /**
         * Indicate wired accessory connection state change.
         * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
         * @param state  new connection state: 1 connected, 0 disconnected
         * @param name   device name
         * {@hide}
         */
        SetWiredDeviceConnectionState(
            [in] Int32 device,
            [in] Int32 state,
            [in] String name);

         /**
         * Indicate A2DP source or sink connection state change.
         * @param device Bluetooth device connected/disconnected
         * @param state  new connection state (BluetoothProfile.STATE_xxx)
         * @param profile profile for the A2DP device
         * (either {@link android.bluetooth.BluetoothProfile.A2DP} or
         * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})
         * @return a delay in ms that the caller should wait before broadcasting
         * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
         * {@hide}
         */
        SetBluetoothA2dpDeviceConnectionState(
            [in] IBluetoothDevice* device,
            [in] Int32 state,
            [in] Int32 profile,
            [out] Int32* result);

        /** {@hide} */
        GetRingtonePlayer(
            [out] IIRingtonePlayer** result);

        /**
         * Returns the value of the property with the specified key.
         * @param key One of the strings corresponding to a property key: either
         *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
         *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
         * @return A string representing the associated value for that property key,
         *         or null if there is no value for that key.
         */
        GetProperty(
            [in] String key,
            [out] String* result);

        /**
         * Returns the estimated latency for the given stream type in milliseconds.
         *
         * DO NOT UNHIDE. The existing approach for doing A/V sync has too many problems. We need
         * a better solution.
         * @hide
         */
        GetOutputLatency(
            [in] Int32 streamType,
            [out] Int32* result);

        /**
         * Registers a global volume controller interface.  Currently limited to SystemUI.
         *
         * @hide
         */
        SetVolumeController(
            [in] IIVolumeController* controller);

        /**
         * Notify audio manager about volume controller visibility changes.
         * Currently limited to SystemUI.
         *
         * @hide
         */
        NotifyVolumeControllerVisible(
            [in] IIVolumeController* controller,
            [in] Boolean visible);

        /**
         * Only useful for volume controllers.
         * @hide
         */
        IsStreamAffectedByRingerMode(
            [in] Int32 streamType,
            [out] Boolean* result);

        /**
         * Only useful for volume controllers.
         * @hide
         */
        DisableSafeMediaVolume();

        /**
         * Set Hdmi Cec system audio mode.
         *
         * @param on whether to be on system audio mode
         * @return output device type. 0 (DEVICE_NONE) if failed to set device.
         * @hide
         */
        SetHdmiSystemAudioSupported(
            [in] Boolean on,
            [out] Int32* result);

        /**
         * Returns true if Hdmi Cec system audio mode is supported.
         *
         * @hide
         */
        // @SystemApi
        IsHdmiSystemAudioSupported(
            [out] Boolean* result);

        /**
         * Returns a list of descriptors for all audio ports managed by the audio framework.
         * Audio ports are nodes in the audio framework or audio hardware that can be configured
         * or connected and disconnected with createAudioPatch() or releaseAudioPatch().
         * See AudioPort for a list of attributes of each audio port.
         * @param ports An AudioPort ArrayList where the list will be returned.
         * @hide
         */
        ListAudioPorts(
            [in] IArrayList* ports,
            [out] Int32* result);

        /**
         * Specialized version of listAudioPorts() listing only audio devices (AudioDevicePort)
         * @see listAudioPorts(ArrayList<AudioPort>)
         * @hide
         */
        ListAudioDevicePorts(
            [in] IArrayList* devices,
            [out] Int32* result);

        /**
         * Create a connection between two or more devices. The framework will reject the request if
         * device types are not compatible or the implementation does not support the requested
         * configuration.
         * NOTE: current implementation is limited to one source and one sink per patch.
         * @param patch AudioPatch array where the newly created patch will be returned.
         *              As input, if patch[0] is not null, the specified patch will be replaced by the
         *              new patch created. This avoids calling releaseAudioPatch() when modifying a
         *              patch and allows the implementation to optimize transitions.
         * @param sources List of source audio ports. All must be AudioPort.ROLE_SOURCE.
         * @param sinks   List of sink audio ports. All must be AudioPort.ROLE_SINK.
         *
         * @return - {@link #SUCCESS} if connection is successful.
         *         - {@link #ERROR_BAD_VALUE} if incompatible device types are passed.
         *         - {@link #ERROR_INVALID_OPERATION} if the requested connection is not supported.
         *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to create
         *         a patch.
         *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead
         *         - {@link #ERROR} if patch cannot be connected for any other reason.
         *
         *         patch[0] contains the newly created patch
         * @hide
         */
        CreateAudioPatch(
            [in] ArrayOf<IAudioPatch*>* patch,
            [in] ArrayOf<IAudioPortConfig*>* sources,
            [in] ArrayOf<IAudioPortConfig*>* sinks,
            [out] Int32* result);

        /**
         * Releases an existing audio patch connection.
         * @param patch The audio patch to disconnect.
         * @return - {@link #SUCCESS} if disconnection is successful.
         *         - {@link #ERROR_BAD_VALUE} if the specified patch does not exist.
         *         - {@link #ERROR_PERMISSION_DENIED} if the client does not have permission to release
         *         a patch.
         *         - {@link #ERROR_DEAD_OBJECT} if the server process is dead
         *         - {@link #ERROR} if patch cannot be released for any other reason.
         * @hide
         */
        ReleaseAudioPatch(
            [in] IAudioPatch* patch,
            [out] Int32* result);

        /**
         * List all existing connections between audio ports.
         * @param patches An AudioPatch array where the list will be returned.
         * @hide
         */
        ListAudioPatches(
            [in] IArrayList* patches,
            [out] Int32* result);

        /**
         * Set the gain on the specified AudioPort. The AudioGainConfig config is build by
         * AudioGain.buildConfig()
         * @hide
         */
        SetAudioPortGain(
            [in] IAudioPort* port,
            [in] IAudioGainConfig* gain,
            [out] Int32* result);

        /**
         * Register an audio port list update listener.
         * @hide
         */
        RegisterAudioPortUpdateListener(
            [in] IAudioManagerOnAudioPortUpdateListener* l);

        /**
         * Unregister an audio port list update listener.
         * @hide
         */
        UnregisterAudioPortUpdateListener(
            [in] IAudioManagerOnAudioPortUpdateListener* l);

        ResetAudioPortGeneration(
            [out] Int32* result);

        UpdateAudioPortCache(
            [in] IArrayList* ports,
            [in] IArrayList* patches,
            [out] Int32* result);
    }

    interface IAudioManagerHelper{
        /**
         * Checks valid ringer mode values.
         *
         * @return true if the ringer mode indicated is valid, false otherwise.
         *
         * @see #setRingerMode(Int32)
         * @hide
         */
        IsValidRingerMode(
            [in] Int32 rightMode,
            [out] Boolean* result);

        /**
         * Return true if the device code corresponds to an output device.
         * @hide
         */
        IsOutputDevice(
            [in] Int32 device,
            [out] Boolean* result);

        /**
         * Return true if the device code corresponds to an input device.
         * @hide
         */
        IsInputDevice(
            [in] Int32 device,
            [out] Boolean* result);
    }

    } // namespace media
    } // namepsace Droid
    } // namespace Elastos
}
