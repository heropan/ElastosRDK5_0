
module
{
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.Core.IStringBuilder;
    using interface Elastos.IO.ISerializable;
    using interface Elastos.Utility.IArrayList;
    using interface Org.Xmlpull.V1.IXmlPullParser;
    using interface Org.Xmlpull.V1.IXmlSerializer;

    interface Elastos.Droid.Content.IClipData;
    interface Elastos.Droid.Content.IComponentName;
    interface Elastos.Droid.Content.IContentResolver;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.Pm.IActivityInfo;
    interface Elastos.Droid.Content.Pm.IPackageManager;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Graphics.IRect;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Utility.IAttributeSet;

    namespace Elastos {
    namespace Droid {
    namespace Content {

    [deprecated]
    interface IIntent {
        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Standard intent activity actions (see action variable).

        /**
         *  Activity Action: Start as a main entry point, does not expect to
         *  receive data.
         *  <p>Input: nothing
         *  <p>Output: nothing
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_MAIN = "android.intent.action.MAIN";

        /**
         * Activity Action: Display the data to the user.  This is the most common
         * action performed on data -- it is the generic action you can use on
         * a piece of data to get the most reasonable thing to occur.  For example,
         * when used on a contacts entry it will view the entry; when used on a
         * mailto: URI it will bring up a compose window filled with the information
         * supplied by the URI; when used with a tel: URI it will invoke the
         * dialer.
         * <p>Input: {@link #getData} is URI from which to retrieve data.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_VIEW = "android.intent.action.VIEW";

        /**
         * A synonym for {@link #ACTION_VIEW}, the "standard" action that is
         * performed on a piece of data.
         */
        const String ACTION_DEFAULT = "android.intent.action.VIEW";

        /**
         * Used to indicate that some piece of data should be attached to some other
         * place.  For example, image data could be attached to a contact.  It is up
         * to the recipient to decide where the data should be attached; the intent
         * does not specify the ultimate destination.
         * <p>Input: {@link #getData} is URI of data to be attached.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";

        /**
         * Activity Action: Provide explicit editable access to the given data.
         * <p>Input: {@link #getData} is URI of data to be edited.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_EDIT = "android.intent.action.EDIT";

        /**
         * Activity Action: Pick an existing item, or insert a new item, and then edit it.
         * <p>Input: {@link #getType} is the desired MIME type of the item to create or edit.
         * The extras can contain type specific data to pass through to the editing/creating
         * activity.
         * <p>Output: The URI of the item that was picked.  This must be a content:
         * URI so that any receiver can access it.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_INSERT_OR_EDIT = "android.intent.action.INSERT_OR_EDIT";

        /**
         * Activity Action: Pick an item from the data, returning what was selected.
         * <p>Input: {@link #getData} is URI containing a directory of data
         * (vnd.android.cursor.dir/*) from which to pick an item.
         * <p>Output: The URI of the item that was picked.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_PICK = "android.intent.action.PICK";

        /**
         * Activity Action: Creates a shortcut.
         * <p>Input: Nothing.</p>
         * <p>Output: An Intent representing the shortcut. The intent must contain three
         * extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String),
         * and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE
         * (value: ShortcutIconResource).</p>
         *
         * @see #EXTRA_SHORTCUT_INTENT
         * @see #EXTRA_SHORTCUT_NAME
         * @see #EXTRA_SHORTCUT_ICON
         * @see #EXTRA_SHORTCUT_ICON_RESOURCE
         * @see android.content.Intent.ShortcutIconResource
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_CREATE_SHORTCUT = "android.intent.action.CREATE_SHORTCUT";

        /**
         * The name of the extra used to define the Intent of a shortcut.
         *
         * @see #ACTION_CREATE_SHORTCUT
         */
        const String EXTRA_SHORTCUT_INTENT = "android.intent.extra.shortcut.INTENT";
        /**
         * The name of the extra used to define the name of a shortcut.
         *
         * @see #ACTION_CREATE_SHORTCUT
         */
        const String EXTRA_SHORTCUT_NAME = "android.intent.extra.shortcut.NAME";
        /**
         * The name of the extra used to define the icon, as a Bitmap, of a shortcut.
         *
         * @see #ACTION_CREATE_SHORTCUT
         */
        const String EXTRA_SHORTCUT_ICON = "android.intent.extra.shortcut.ICON";
        /**
         * The name of the extra used to define the icon, as a ShortcutIconResource, of a shortcut.
         *
         * @see #ACTION_CREATE_SHORTCUT
         * @see android.content.Intent.ShortcutIconResource
         */
        const String EXTRA_SHORTCUT_ICON_RESOURCE =
                "android.intent.extra.shortcut.ICON_RESOURCE";

        /**
         * Activity Action: Display an activity chooser, allowing the user to pick
         * what they want to before proceeding.  This can be used as an alternative
         * to the standard activity picker that is displayed by the system when
         * you try to start an activity with multiple possible matches, with these
         * differences in behavior:
         * <ul>
         * <li>You can specify the title that will appear in the activity chooser.
         * <li>The user does not have the option to make one of the matching
         * activities a preferred activity, and all possible activities will
         * always be shown even if one of them is currently marked as the
         * preferred activity.
         * </ul>
         * <p>
         * This action should be used when the user will naturally expect to
         * select an activity in order to proceed.  An example if when not to use
         * it is when the user clicks on a "mailto:" link.  They would naturally
         * expect to go directly to their mail app, so startActivity() should be
         * called directly: it will
         * either launch the current preferred app, or put up a dialog allowing the
         * user to pick an app to use and optionally marking that as preferred.
         * <p>
         * In contrast, if the user is selecting a menu item to send a picture
         * they are viewing to someone else, there are many different things they
         * may want to do at this point: send it through e-mail, upload it to a
         * web service, etc.  In this case the CHOOSER action should be used, to
         * always present to the user a list of the things they can do, with a
         * nice title given by the caller such as "Send this photo with:".
         * <p>
         * If you need to grant URI permissions through a chooser, you must specify
         * the permissions to be granted on the ACTION_CHOOSER Intent
         * <em>in addition</em> to the EXTRA_INTENT inside.  This means using
         * {@link #setClipData} to specify the URIs to be granted as well as
         * {@link #FLAG_GRANT_READ_URI_PERMISSION} and/or
         * {@link #FLAG_GRANT_WRITE_URI_PERMISSION} as appropriate.
         * <p>
         * As a convenience, an Intent of this form can be created with the
         * {@link #createChooser} function.
         * <p>
         * Input: No data should be specified.  get*Extra must have
         * a {@link #EXTRA_INTENT} field containing the Intent being executed,
         * and can optionally have a {@link #EXTRA_TITLE} field containing the
         * title text to display in the chooser.
         * <p>
         * Output: Depends on the protocol of {@link #EXTRA_INTENT}.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_CHOOSER = "android.intent.action.CHOOSER";

        /**
         * Activity Action: Allow the user to select a particular kind of data and
         * return it.  This is different than {@link #ACTION_PICK} in that here we
         * just say what kind of data is desired, not a URI of existing data from
         * which the user can pick.  A ACTION_GET_CONTENT could allow the user to
         * create the data as it runs (for example taking a picture or recording a
         * sound), let them browse over the web and download the desired data,
         * etc.
         * <p>
         * There are two main ways to use this action: if you want a specific kind
         * of data, such as a person contact, you set the MIME type to the kind of
         * data you want and launch it with {@link Context#startActivity(Intent)}.
         * The system will then launch the best application to select that kind
         * of data for you.
         * <p>
         * You may also be interested in any of a set of types of content the user
         * can pick.  For example, an e-mail application that wants to allow the
         * user to add an attachment to an e-mail message can use this action to
         * bring up a list of all of the types of content the user can attach.
         * <p>
         * In this case, you should wrap the GET_CONTENT intent with a chooser
         * (through {@link #createChooser}), which will give the proper interface
         * for the user to pick how to send your data and allow you to specify
         * a prompt indicating what they are doing.  You will usually specify a
         * broad MIME type (such as image/* or {@literal *}/*), resulting in a
         * broad range of content types the user can select from.
         * <p>
         * When using such a broad GET_CONTENT action, it is often desirable to
         * only pick from data that can be represented as a stream.  This is
         * accomplished by requiring the {@link #CATEGORY_OPENABLE} in the Intent.
         * <p>
         * Callers can optionally specify {@link #EXTRA_LOCAL_ONLY} to request that
         * the launched content chooser only returns results representing data that
         * is locally available on the device.  For example, if this extra is set
         * to true then an image picker should not show any pictures that are available
         * from a remote server but not already on the local device (thus requiring
         * they be downloaded when opened).
         * <p>
         * Input: {@link #getType} is the desired MIME type to retrieve.  Note
         * that no URI is supplied in the intent, as there are no constraints on
         * where the returned data originally comes from.  You may also include the
         * {@link #CATEGORY_OPENABLE} if you can only accept data that can be
         * opened as a stream.  You may use {@link #EXTRA_LOCAL_ONLY} to limit content
         * selection to local data.
         * <p>
         * Output: The URI of the item that was picked.  This must be a content:
         * URI so that any receiver can access it.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_GET_CONTENT = "android.intent.action.GET_CONTENT";

        /**
         * Activity Action: Dial a number as specified by the data.  This shows a
         * UI with the number being dialed, allowing the user to explicitly
         * initiate the call.
         * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
         * is URI of a phone number to be dialed or a tel: URI of an explicit phone
         * number.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_DIAL = "android.intent.action.DIAL";

        /**
         * Activity Action: Perform a call to someone specified by the data.
         * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
         * is URI of a phone number to be dialed or a tel: URI of an explicit phone
         * number.
         * <p>Output: nothing.
         *
         * <p>Note: there will be restrictions on which applications can initiate a
         * call; most applications should use the {@link #ACTION_DIAL}.
         * <p>Note: this Intent <strong>cannot</strong> be used to call emergency
         * numbers.  Applications can <strong>dial</strong> emergency numbers using
         * {@link #ACTION_DIAL}, however.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_CALL = "android.intent.action.CALL";

        /**
         * Activity Action: Perform a call to an emergency number specified by the
         * data.
         * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
         * tel: URI of an explicit phone number.
         * <p>Output: nothing.
         * @hide
         */
        const String ACTION_CALL_EMERGENCY = "android.intent.action.CALL_EMERGENCY";

        /**
         * Activity action: Perform a call to any number (emergency or not)
         * specified by the data.
         * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
         * tel: URI of an explicit phone number.
         * <p>Output: nothing.
         * @hide
         */
        const String ACTION_CALL_PRIVILEGED = "android.intent.action.CALL_PRIVILEGED";

        /**
         * Activity Action: Send a message to someone specified by the data.
         * <p>Input: {@link #getData} is URI describing the target.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SENDTO = "android.intent.action.SENDTO";

        /**
         * Activity Action: Deliver some data to someone else.  Who the data is
         * being delivered to is not specified; it is up to the receiver of this
         * action to ask the user where the data should be sent.
         * <p>
         * When launching a SEND intent, you should usually wrap it in a chooser
         * (through {@link #createChooser}), which will give the proper interface
         * for the user to pick how to send your data and allow you to specify
         * a prompt indicating what they are doing.
         * <p>
         * Input: {@link #getType} is the MIME type of the data being sent.
         * get*Extra can have either a {@link #EXTRA_TEXT}
         * or {@link #EXTRA_STREAM} field, containing the data to be sent.  If
         * using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it
         * should be the MIME type of the data in EXTRA_STREAM.  Use {@literal *}/*
         * if the MIME type is unknown (this will only allow senders that can
         * handle generic data streams).  If using {@link #EXTRA_TEXT}, you can
         * also optionally supply {@link #EXTRA_HTML_TEXT} for clients to retrieve
         * your text with HTML formatting.
         * <p>
         * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
         * being sent can be supplied through {@link #setClipData(ClipData)}.  This
         * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
         * content: URIs and other advanced features of {@link ClipData}.  If
         * using this approach, you still must supply the same data through the
         * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
         * for compatibility with old applications.  If you don't set a ClipData,
         * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
         * <p>
         * Optional standard extras, which may be interpreted by some recipients as
         * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
         * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
         * <p>
         * Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SEND = "android.intent.action.SEND";

        /**
         * Activity Action: Deliver multiple data to someone else.
         * <p>
         * Like {@link #ACTION_SEND}, except the data is multiple.
         * <p>
         * Input: {@link #getType} is the MIME type of the data being sent.
         * get*ArrayListExtra can have either a {@link #EXTRA_TEXT} or {@link
         * #EXTRA_STREAM} field, containing the data to be sent.  If using
         * {@link #EXTRA_TEXT}, you can also optionally supply {@link #EXTRA_HTML_TEXT}
         * for clients to retrieve your text with HTML formatting.
         * <p>
         * Multiple types are supported, and receivers should handle mixed types
         * whenever possible. The right way for the receiver to check them is to
         * use the content resolver on each URI. The intent sender should try to
         * put the most concrete mime type in the intent type, but it can fall
         * back to {@literal <type>/*} or {@literal *}/* as needed.
         * <p>
         * e.g. if you are sending image/jpg and image/jpg, the intent's type can
         * be image/jpg, but if you are sending image/jpg and image/png, then the
         * intent's type should be image/*.
         * <p>
         * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
         * being sent can be supplied through {@link #setClipData(ClipData)}.  This
         * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
         * content: URIs and other advanced features of {@link ClipData}.  If
         * using this approach, you still must supply the same data through the
         * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
         * for compatibility with old applications.  If you don't set a ClipData,
         * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
         * <p>
         * Optional standard extras, which may be interpreted by some recipients as
         * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
         * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
         * <p>
         * Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SEND_MULTIPLE = "android.intent.action.SEND_MULTIPLE";

        /**
         * Activity Action: Handle an incoming phone call.
         * <p>Input: nothing.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_ANSWER = "android.intent.action.ANSWER";

        /**
         * Activity Action: Insert an empty item into the given container.
         * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
         * in which to place the data.
         * <p>Output: URI of the new data that was created.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_INSERT = "android.intent.action.INSERT";

        /**
         * Activity Action: Create a new item in the given container, initializing it
         * from the current contents of the clipboard.
         * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
         * in which to place the data.
         * <p>Output: URI of the new data that was created.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_PASTE = "android.intent.action.PASTE";

        /**
         * Activity Action: Delete the given data from its container.
         * <p>Input: {@link #getData} is URI of data to be deleted.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_DELETE = "android.intent.action.DELETE";

        /**
         * Activity Action: Run the data, whatever that means.
         * <p>Input: ?  (Note: this is currently specific to the test harness.)
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_RUN = "android.intent.action.RUN";

        /**
         * Activity Action: Perform a data synchronization.
         * <p>Input: ?
         * <p>Output: ?
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SYNC = "android.intent.action.SYNC";

        /**
         * Activity Action: Pick an activity given an intent, returning the class
         * selected.
         * <p>Input: get*Extra field {@link #EXTRA_INTENT} is an Intent
         * used with {@link PackageManager#queryIntentActivities} to determine the
         * set of activities from which to pick.
         * <p>Output: Class name of the activity that was selected.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_PICK_ACTIVITY = "android.intent.action.PICK_ACTIVITY";

        /**
         * Activity Action: Perform a search.
         * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
         * is the text to search for.  If empty, simply
         * enter your search results Activity with the search UI activated.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SEARCH = "android.intent.action.SEARCH";

        /**
         * Activity Action: Start the platform-defined tutorial
         * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
         * is the text to search for.  If empty, simply
         * enter your search results Activity with the search UI activated.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SYSTEM_TUTORIAL = "android.intent.action.SYSTEM_TUTORIAL";

        /**
         * Activity Action: Perform a web search.
         * <p>
         * Input: {@link android.app.SearchManager#QUERY
         * getStringExtra(SearchManager.QUERY)} is the text to search for. If it is
         * a url starts with http or https, the site will be opened. If it is plain
         * text, Google search will be applied.
         * <p>
         * Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_WEB_SEARCH = "android.intent.action.WEB_SEARCH";

        /**
         * Activity Action: Perform assist action.
         * <p>
         * Input: nothing
         * Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_ASSIST = "android.intent.action.ASSIST";

        /**
         * Activity Action: Perform voice assist action.
         * <p>
         * Input: {@link #EXTRA_ASSIST_PACKAGE}, {@link #EXTRA_ASSIST_CONTEXT}, can provide
         * additional optional contextual information about where the user was when they
         * requested the voice assist.
         * Output: nothing.
         * @hide
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_VOICE_ASSIST = "android.intent.action.VOICE_ASSIST";

        /**
         * An optional field on {@link #ACTION_ASSIST} containing the name of the current foreground
         * application package at the time the assist was invoked.
         */
        const String EXTRA_ASSIST_PACKAGE
                = "android.intent.extra.ASSIST_PACKAGE";

        /**
         * An optional field on {@link #ACTION_ASSIST} and containing additional contextual
         * information supplied by the current foreground app at the time of the assist request.
         * This is a {@link Bundle} of additional data.
         */
        const String EXTRA_ASSIST_CONTEXT
                = "android.intent.extra.ASSIST_CONTEXT";

        /**
         * An optional field on {@link #ACTION_ASSIST} suggesting that the user will likely use a
         * keyboard as the primary input device for assistance.
         */
        const String EXTRA_ASSIST_INPUT_HINT_KEYBOARD =
                "android.intent.extra.ASSIST_INPUT_HINT_KEYBOARD";

        /**
         * Activity Action: List all available applications
         * <p>Input: Nothing.
         * <p>Output: nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_ALL_APPS = "android.intent.action.ALL_APPS";

        /**
         * Activity Action: Show settings for choosing wallpaper
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SET_WALLPAPER = "android.intent.action.SET_WALLPAPER";

        /**
         * Activity Action: Show activity for reporting a bug.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_BUG_REPORT = "android.intent.action.BUG_REPORT";

        /**
         *  Activity Action: Main entry point for factory tests.  Only used when
         *  the device is booting in factory test node.  The implementing package
         *  must be installed in the system image.
         *  <p>Input: nothing
         *  <p>Output: nothing
         */
        const String ACTION_FACTORY_TEST = "android.intent.action.FACTORY_TEST";

        /**
         * Activity Action: The user pressed the "call" button to go to the dialer
         * or other appropriate UI for placing a call.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_CALL_BUTTON = "android.intent.action.CALL_BUTTON";

        /**
         * Activity Action: Start Voice Command.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_VOICE_COMMAND = "android.intent.action.VOICE_COMMAND";

        /**
         * Activity Action: Start action associated with long pressing on the
         * search key.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_SEARCH_LONG_PRESS = "android.intent.action.SEARCH_LONG_PRESS";

        /**
         * Activity Action: The user pressed the "Report" button in the crash/ANR dialog.
         * This intent is delivered to the package which installed the application, usually
         * Google Play.
         * <p>Input: No data is specified. The bug report is passed in using
         * an {@link #EXTRA_BUG_REPORT} field.
         * <p>Output: Nothing.
         *
         * @see #EXTRA_BUG_REPORT
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";

        /**
         * Activity Action: Show power usage information to the user.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_POWER_USAGE_SUMMARY = "android.intent.action.POWER_USAGE_SUMMARY";

        /**
         * Activity Action: Setup wizard to launch after a platform update.  This
         * activity should have a string meta-data field associated with it,
         * {@link #METADATA_SETUP_VERSION}, which defines the current version of
         * the platform for setup.  The activity will be launched only if
         * {@link android.provider.Settings.Secure#LAST_SETUP_SHOWN} is not the
         * same value.
         * <p>Input: Nothing.
         * <p>Output: Nothing.
         * @hide
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_UPGRADE_SETUP = "android.intent.action.UPGRADE_SETUP";

        /**
         * Activity Action: Show settings for managing network data usage of a
         * specific application. Applications should define an activity that offers
         * options to control data usage.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_MANAGE_NETWORK_USAGE = "android.intent.action.MANAGE_NETWORK_USAGE";

        /**
         * Activity Action: Launch application installer.
         * <p>
         * Input: The data must be a content: or file: URI at which the application
         * can be retrieved.  As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1},
         * you can also use "package:<package-name>" to install an application for the
         * current user that is already installed for another user. You can optionally supply
         * {@link #EXTRA_INSTALLER_PACKAGE_NAME}, {@link #EXTRA_NOT_UNKNOWN_SOURCE},
         * {@link #EXTRA_ALLOW_REPLACE}, and {@link #EXTRA_RETURN_RESULT}.
         * <p>
         * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
         * succeeded.
         *
         * @see #EXTRA_INSTALLER_PACKAGE_NAME
         * @see #EXTRA_NOT_UNKNOWN_SOURCE
         * @see #EXTRA_RETURN_RESULT
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_INSTALL_PACKAGE = "android.intent.action.INSTALL_PACKAGE";

        /**
         * Used as a string extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
         * package.  Specifies the installer package name; this package will receive the
         * {@link #ACTION_APP_ERROR} intent.
         */
        const String EXTRA_INSTALLER_PACKAGE_NAME = "android.intent.extra.INSTALLER_PACKAGE_NAME";

        /**
         * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
         * package.  Specifies that the application being installed should not be
         * treated as coming from an unknown source, but as coming from the app
         * invoking the Intent.  For this to work you must start the installer with
         * startActivityForResult().
         */
        const String EXTRA_NOT_UNKNOWN_SOURCE = "android.intent.extra.NOT_UNKNOWN_SOURCE";

        /**
         * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
         * {@link #ACTION_VIEW} to indicate the URI from which the local APK in the Intent
         * data field originated from.
         */
        const String EXTRA_ORIGINATING_URI = "android.intent.extra.ORIGINATING_URI";

        /**
         * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
         * {@link #ACTION_VIEW} to indicate the HTTP referrer URI associated with the Intent
         * data field or {@link #EXTRA_ORIGINATING_URI}.
         */
        const String EXTRA_REFERRER = "android.intent.extra.REFERRER";

        /**
         * Used as an int extra field with {@link #ACTION_INSTALL_PACKAGE} and
         * {@link} #ACTION_VIEW} to indicate the uid of the package that initiated the install
         * @hide
         */
        const String EXTRA_ORIGINATING_UID = "android.intent.extra.ORIGINATING_UID";

        /**
         * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
         * package.  Tells the installer UI to skip the confirmation with the user
         * if the .apk is replacing an existing one.
         * @deprecated As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, Android
         * will no longer show an interstitial message about updating existing
         * applications so this is no longer needed.
         */
        //@Deprecated
        const String EXTRA_ALLOW_REPLACE = "android.intent.extra.ALLOW_REPLACE";

        /**
         * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} or
         * {@link #ACTION_UNINSTALL_PACKAGE}.  Specifies that the installer UI should
         * return to the application the result code of the install/uninstall.  The returned result
         * code will be {@link android.app.Activity#RESULT_OK} on success or
         * {@link android.app.Activity#RESULT_FIRST_USER} on failure.
         */
        const String EXTRA_RETURN_RESULT = "android.intent.extra.RETURN_RESULT";

        /**
         * Package manager install result code.  @hide because result codes are not
         * yet ready to be exposed.
         */
        const String EXTRA_INSTALL_RESULT = "android.intent.extra.INSTALL_RESULT";

        /**
         * Activity Action: Launch application uninstaller.
         * <p>
         * Input: The data must be a package: URI whose scheme specific part is
         * the package name of the current installed package to be uninstalled.
         * You can optionally supply {@link #EXTRA_RETURN_RESULT}.
         * <p>
         * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
         * succeeded.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_UNINSTALL_PACKAGE = "android.intent.action.UNINSTALL_PACKAGE";

        /**
         * Specify whether the package should be uninstalled for all users.
         * @hide because these should not be part of normal application flow.
         */
        const String EXTRA_UNINSTALL_ALL_USERS = "android.intent.extra.UNINSTALL_ALL_USERS";

        /**
         * A string associated with a {@link #ACTION_UPGRADE_SETUP} activity
         * describing the last run version of the platform that was setup.
         * @hide
         */
        const String METADATA_SETUP_VERSION = "android.SETUP_VERSION";

        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Standard intent broadcast actions (see action variable).

        /**
         * Broadcast Action: Sent after the screen turns off.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SCREEN_OFF = "android.intent.action.SCREEN_OFF";

        /**
         * Broadcast Action: Sent after the screen turns on.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SCREEN_ON = "android.intent.action.SCREEN_ON";

        /**
         * Broadcast Action: Sent after the system stops dreaming.
         *
         * <p class="note">This is a protected intent that can only be sent by the system.
         * It is only sent to registered receivers.</p>
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DREAMING_STOPPED = "android.intent.action.DREAMING_STOPPED";

        /**
         * Broadcast Action: Sent after the system starts dreaming.
         *
         * <p class="note">This is a protected intent that can only be sent by the system.
         * It is only sent to registered receivers.</p>
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DREAMING_STARTED = "android.intent.action.DREAMING_STARTED";

        /**
         * Broadcast Action: Sent when the user is present after device wakes up (e.g when the
         * keyguard is gone).
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_USER_PRESENT = "android.intent.action.USER_PRESENT";

        /**
         * Broadcast Action: The current time has changed.  Sent every
         * minute.  You can <em>not</em> receive this through components declared
         * in manifests, only by exlicitly registering for it with
         * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver()}.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";

        /**
         * Broadcast Action: The time was set.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";

        /**
         * Broadcast Action: The date has changed.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";

        /**
         * Broadcast Action: The timezone has changed. The intent will have the following extra values:</p>
         * <ul>
         *   <li><em>time-zone</em> - The java.util.TimeZone.getID() value identifying the new time zone.</li>
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_TIMEZONE_CHANGED = "android.intent.action.TIMEZONE_CHANGED";

        /**
         * Clear DNS Cache Action: This is broadcast when networks have changed and old
         * DNS entries should be tossed.
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_CLEAR_DNS_CACHE = "android.intent.action.CLEAR_DNS_CACHE";

        /**
         * Alarm Changed Action: This is broadcast when the AlarmClock
         * application's alarm is set or unset.  It is used by the
         * AlarmClock application and the StatusBar service.
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_ALARM_CHANGED = "android.intent.action.ALARM_CHANGED";

        /**
         * Sync State Changed Action: This is broadcast when the sync starts or stops or when one has
         * been failing for a long time.  It is used by the SyncManager and the StatusBar service.
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SYNC_STATE_CHANGED = "android.intent.action.SYNC_STATE_CHANGED";

        /**
         * Broadcast Action: This is broadcast once, after the system has finished
         * booting.  It can be used to perform application-specific initialization,
         * such as installing alarms.  You must hold the
         * {@link android.Manifest.permission#RECEIVE_BOOT_COMPLETED} permission
         * in order to receive this broadcast.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED";

        /**
         * Broadcast Action: This is broadcast when a user action should request a
         * temporary system dialog to dismiss.  Some examples of temporary system
         * dialogs are the notification window-shade and the recent tasks dialog.
         */
        const String ACTION_CLOSE_SYSTEM_DIALOGS = "android.intent.action.CLOSE_SYSTEM_DIALOGS";

        /**
         * Broadcast Action: Trigger the download and eventual installation
         * of a package.
         * <p>Input: {@link #getData} is the URI of the package file to download.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * @deprecated This constant has never been used.
         */
        //@Deprecated
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_INSTALL = "android.intent.action.PACKAGE_INSTALL";

        /**
         * Broadcast Action: A new application package has been installed on the
         * device. The data contains the name of the package.  Note that the
         * newly installed package does <em>not</em> receive this broadcast.
         * <p>May include the following extras:
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
         * <li> {@link #EXTRA_REPLACING} is set to true if this is following
         * an {@link #ACTION_PACKAGE_REMOVED} broadcast for the same package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_ADDED = "android.intent.action.PACKAGE_ADDED";

        /**
         * Broadcast Action: A new version of an application package has been
         * installed, replacing an existing version that was previously installed.
         * The data contains the name of the package.
         * <p>May include the following extras:
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_REPLACED = "android.intent.action.PACKAGE_REPLACED";

        /**
         * Broadcast Action: A new version of your application has been installed
         * over an existing one.  This is only sent to the application that was
         * replaced.  It does not contain any additional data; to receive it, just
         * use an intent filter for this action.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MY_PACKAGE_REPLACED = "android.intent.action.MY_PACKAGE_REPLACED";

        /**
         * Broadcast Action: An existing application package has been removed from
         * the device.  The data contains the name of the package.  The package
         * that is being installed does <em>not</em> receive this Intent.
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
         * to the package.
         * <li> {@link #EXTRA_DATA_REMOVED} is set to true if the entire
         * application -- data and code -- is being removed.
         * <li> {@link #EXTRA_REPLACING} is set to true if this will be followed
         * by an {@link #ACTION_PACKAGE_ADDED} broadcast for the same package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_REMOVED = "android.intent.action.PACKAGE_REMOVED";

        /**
         * Broadcast Action: An existing application package has been completely
         * removed from the device.  The data contains the name of the package.
         * This is like {@link #ACTION_PACKAGE_REMOVED}, but only set when
         * {@link #EXTRA_DATA_REMOVED} is true and
         * {@link #EXTRA_REPLACING} is false of that broadcast.
         *
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
         * to the package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_FULLY_REMOVED = "android.intent.action.PACKAGE_FULLY_REMOVED";

        /**
         * Broadcast Action: An existing application package has been changed (e.g.
         * a component has been enabled or disabled).  The data contains the name of
         * the package.
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
         * <li> {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST} containing the class name
         * of the changed components.
         * <li> {@link #EXTRA_DONT_KILL_APP} containing boolean field to override the
         * default action of restarting the application.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_CHANGED = "android.intent.action.PACKAGE_CHANGED";

        /**
         * @hide
         * Broadcast Action: Ask system services if there is any reason to
         * restart the given package.  The data contains the name of the
         * package.
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
         * <li> {@link #EXTRA_PACKAGES} String array of all packages to check.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_QUERY_PACKAGE_RESTART = "android.intent.action.QUERY_PACKAGE_RESTART";

        /**
         * Broadcast Action: The user has restarted a package, and all of its
         * processes have been killed.  All runtime state
         * associated with it (processes, alarms, notifications, etc) should
         * be removed.  Note that the restarted package does <em>not</em>
         * receive this broadcast.
         * The data contains the name of the package.
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_RESTARTED = "android.intent.action.PACKAGE_RESTARTED";

        /**
         * Broadcast Action: The user has cleared the data of a package.  This should
         * be preceded by {@link #ACTION_PACKAGE_RESTARTED}, after which all of
         * its persistent data is erased and this broadcast sent.
         * Note that the cleared package does <em>not</em>
         * receive this broadcast. The data contains the name of the package.
         * <ul>
         * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_DATA_CLEARED = "android.intent.action.PACKAGE_DATA_CLEARED";

        /**
         * Broadcast Action: A user ID has been removed from the system.  The user
         * ID number is stored in the extra data under {@link #EXTRA_UID}.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_UID_REMOVED = "android.intent.action.UID_REMOVED";

        /**
         * Broadcast Action: Sent to the installer package of an application
         * when that application is first launched (that is the first time it
         * is moved out of the stopped state).  The data contains the name of the package.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_FIRST_LAUNCH = "android.intent.action.PACKAGE_FIRST_LAUNCH";

        /**
         * Broadcast Action: Sent to the system package verifier when a package
         * needs to be verified. The data contains the package URI.
         * <p class="note">
         * This is a protected intent that can only be sent by the system.
         * </p>
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_NEEDS_VERIFICATION = "android.intent.action.PACKAGE_NEEDS_VERIFICATION";

        /**
         * Broadcast Action: Sent to the system package verifier when a package is
         * verified. The data contains the package URI.
         * <p class="note">
         * This is a protected intent that can only be sent by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PACKAGE_VERIFIED = "android.intent.action.PACKAGE_VERIFIED";

        /**
         * Broadcast Action: Resources for a set of packages (which were
         * previously unavailable) are currently
         * available since the media on which they exist is available.
         * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
         * list of packages whose availability changed.
         * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
         * list of uids of packages whose availability changed.
         * Note that the
         * packages in this list do <em>not</em> receive this broadcast.
         * The specified set of packages are now available on the system.
         * <p>Includes the following extras:
         * <ul>
         * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
         * whose resources(were previously unavailable) are currently available.
         * {@link #EXTRA_CHANGED_UID_LIST} is the set of uids of the
         * packages whose resources(were previously unavailable)
         * are  currently available.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";

        /**
         * Broadcast Action: Resources for a set of packages are currently
         * unavailable since the media on which they exist is unavailable.
         * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
         * list of packages whose availability changed.
         * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
         * list of uids of packages whose availability changed.
         * The specified set of packages can no longer be
         * launched and are practically unavailable on the system.
         * <p>Inclues the following extras:
         * <ul>
         * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
         * whose resources are no longer available.
         * {@link #EXTRA_CHANGED_UID_LIST} is the set of packages
         * whose resources are no longer available.
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";

        /**
         * Broadcast Action:  The current system wallpaper has changed.  See
         * {@link android.app.WallpaperManager} for retrieving the new wallpaper.
         * This should <em>only</em> be used to determine when the wallpaper
         * has changed to show the new wallpaper to the user.  You should certainly
         * never, in response to this, change the wallpaper or other attributes of
         * it such as the suggested size.  That would be crazy, right?  You'd cause
         * all kinds of loops, especially if other apps are doing similar things,
         * right?  Of course.  So please don't do this.
         *
         * @deprecated Modern applications should use
         * {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WALLPAPER
         * WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER} to have the wallpaper
         * shown behind their UI, rather than watching for this broadcast and
         * rendering the wallpaper on their own.
         */
        //@Deprecated @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_WALLPAPER_CHANGED = "android.intent.action.WALLPAPER_CHANGED";

        /**
         * Broadcast Action: The current device {@link android.content.res.Configuration}
         * (orientation, locale, etc) has changed.  When such a change happens, the
         * UIs (view hierarchy) will need to be rebuilt based on this new
         * information; for the most part, applications don't need to worry about
         * this, because the system will take care of stopping and restarting the
         * application to make sure it sees the new changes.  Some system code that
         * can not be restarted will need to watch for this action and handle it
         * appropriately.
         *
         * <p class="note">
         * You can <em>not</em> receive this through components declared
         * in manifests, only by explicitly registering for it with
         * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver()}.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * @see android.content.res.Configuration
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_CONFIGURATION_CHANGED = "android.intent.action.CONFIGURATION_CHANGED";

        /**
         * Broadcast Action: The current device's locale has changed.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_LOCALE_CHANGED = "android.intent.action.LOCALE_CHANGED";

        /**
         * Broadcast Action:  This is a <em>sticky broadcast</em> containing the
         * charging state, level, and other information about the battery.
         * See {@link android.os.BatteryManager} for documentation on the
         * contents of the Intent.
         *
         * <p class="note">
         * You can <em>not</em> receive this through components declared
         * in manifests, only by explicitly registering for it with
         * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver()}.  See {@link #ACTION_BATTERY_LOW},
         * {@link #ACTION_BATTERY_OKAY}, {@link #ACTION_POWER_CONNECTED},
         * and {@link #ACTION_POWER_DISCONNECTED} for distinct battery-related
         * broadcasts that are sent and can be received through manifest
         * receivers.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";

        /**
         * Broadcast Action:  Indicates low battery condition on the device.
         * This broadcast corresponds to the "Low battery warning" system dialog.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";

        /**
         * Broadcast Action:  Indicates the battery is now okay after being low.
         * This will be sent after {@link #ACTION_BATTERY_LOW} once the battery has
         * gone back up to an okay state.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";

        /**
         * Broadcast Action:  External power has been connected to the device.
         * This is intended for applications that wish to register specifically to this notification.
         * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
         * stay active to receive this notification.  This action can be used to implement actions
         * that wait until power is available to trigger.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_POWER_CONNECTED = "android.intent.action.ACTION_POWER_CONNECTED";

        /**
         * Broadcast Action:  External power has been removed from the device.
         * This is intended for applications that wish to register specifically to this notification.
         * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
         * stay active to receive this notification.  This action can be used to implement actions
         * that wait until power is available to trigger.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_POWER_DISCONNECTED = "android.intent.action.ACTION_POWER_DISCONNECTED";

        /**
         * Broadcast Action:  Device is shutting down.
         * This is broadcast when the device is being shut down (completely turned
         * off, not sleeping).  Once the broadcast is complete, the final shutdown
         * will proceed and all unsaved data lost.  Apps will not normally need
         * to handle this, since the foreground activity will be paused as well.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";

        /**
         * Activity Action:  Start this activity to request system shutdown.
         * The optional boolean extra field {@link #EXTRA_KEY_CONFIRM} can be set to true
         * to request confirmation from the user before shutting down.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * {@hide}
         */
        const String ACTION_REQUEST_SHUTDOWN = "android.intent.action.ACTION_REQUEST_SHUTDOWN";

        /**
         * Broadcast Action:  A sticky broadcast that indicates low memory
         * condition on the device
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DEVICE_STORAGE_LOW = "android.intent.action.DEVICE_STORAGE_LOW";

        /**
         * Broadcast Action:  Indicates low memory condition on the device no longer exists
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DEVICE_STORAGE_OK = "android.intent.action.DEVICE_STORAGE_OK";

        /**
         * Broadcast Action:  A sticky broadcast that indicates a memory full
         * condition on the device. This is intended for activities that want
         * to be able to fill the data partition completely, leaving only
         * enough free space to prevent system-wide SQLite failures.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * {@hide}
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DEVICE_STORAGE_FULL = "android.intent.action.DEVICE_STORAGE_FULL";

        /**
         * Broadcast Action:  Indicates memory full condition on the device
         * no longer exists.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * {@hide}
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DEVICE_STORAGE_NOT_FULL = "android.intent.action.DEVICE_STORAGE_NOT_FULL";

        /**
         * Broadcast Action:  Indicates low memory condition notification acknowledged by user
         * and package management should be started.
         * This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW
         * notification.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MANAGE_PACKAGE_STORAGE = "android.intent.action.MANAGE_PACKAGE_STORAGE";

        /**
         * Broadcast Action:  The device has entered USB Mass Storage mode.
         * This is used mainly for the USB Settings panel.
         * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
         * when the SD card file system is mounted or unmounted
         * @deprecated replaced by android.os.storage.StorageEventListener
         */
        //@Deprecated
        const String ACTION_UMS_CONNECTED = "android.intent.action.UMS_CONNECTED";

        /**
         * Broadcast Action:  The device has exited USB Mass Storage mode.
         * This is used mainly for the USB Settings panel.
         * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
         * when the SD card file system is mounted or unmounted
         * @deprecated replaced by android.os.storage.StorageEventListener
         */
        //@Deprecated
        const String ACTION_UMS_DISCONNECTED = "android.intent.action.UMS_DISCONNECTED";

        /**
         * Broadcast Action:  External media has been removed.
         * The path to the mount point for the removed media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_REMOVED = "android.intent.action.MEDIA_REMOVED";

        /**
         * Broadcast Action:  External media is present, but not mounted at its mount point.
         * The path to the mount point for the removed media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_UNMOUNTED = "android.intent.action.MEDIA_UNMOUNTED";

        /**
         * Broadcast Action:  External media is present, and being disk-checked
         * The path to the mount point for the checking media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_CHECKING = "android.intent.action.MEDIA_CHECKING";

        /**
         * Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
         * The path to the mount point for the checking media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_NOFS = "android.intent.action.MEDIA_NOFS";

        /**
         * Broadcast Action:  External media is present and mounted at its mount point.
         * The path to the mount point for the removed media is contained in the Intent.mData field.
         * The Intent contains an extra with name "read-only" and Boolean value to indicate if the
         * media was mounted read only.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_MOUNTED = "android.intent.action.MEDIA_MOUNTED";

        /**
         * Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
         * The path to the mount point for the shared media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_SHARED = "android.intent.action.MEDIA_SHARED";

        /**
         * Broadcast Action:  External media is no longer being shared via USB mass storage.
         * The path to the mount point for the previously shared media is contained in the Intent.mData field.
         *
         * @hide
         */
        const String ACTION_MEDIA_UNSHARED = "android.intent.action.MEDIA_UNSHARED";

        /**
         * Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
         * The path to the mount point for the removed media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_BAD_REMOVAL = "android.intent.action.MEDIA_BAD_REMOVAL";

        /**
         * Broadcast Action:  External media is present but cannot be mounted.
         * The path to the mount point for the removed media is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_UNMOUNTABLE = "android.intent.action.MEDIA_UNMOUNTABLE";

        /**
         * Broadcast Action:  User has expressed the desire to remove the external storage media.
         * Applications should close all files they have open within the mount point when they receive this intent.
         * The path to the mount point for the media to be ejected is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_EJECT = "android.intent.action.MEDIA_EJECT";

        /**
         * Broadcast Action:  The media scanner has started scanning a directory.
         * The path to the directory being scanned is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_SCANNER_STARTED = "android.intent.action.MEDIA_SCANNER_STARTED";

        /**
         * Broadcast Action:  The media scanner has finished scanning a directory.
         * The path to the scanned directory is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_SCANNER_FINISHED = "android.intent.action.MEDIA_SCANNER_FINISHED";

        /**
         * Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
         * The path to the file is contained in the Intent.mData field.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_SCANNER_SCAN_FILE = "android.intent.action.MEDIA_SCANNER_SCAN_FILE";

        /**
         * Broadcast Action:  The "Media Button" was pressed.  Includes a single
         * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
         * caused the broadcast.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_MEDIA_BUTTON = "android.intent.action.MEDIA_BUTTON";

        /**
         * Broadcast Action:  The "Camera Button" was pressed.  Includes a single
         * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
         * caused the broadcast.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_CAMERA_BUTTON = "android.intent.action.CAMERA_BUTTON";

        // *** NOTE: @todo(*) The following really should go into a more domain-specific
        // location; they are not general-purpose actions.

        /**
         * Broadcast Action: A GTalk connection has been established.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_GTALK_SERVICE_CONNECTED = "android.intent.action.GTALK_CONNECTED";

        /**
         * Broadcast Action: A GTalk connection has been disconnected.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_GTALK_SERVICE_DISCONNECTED = "android.intent.action.GTALK_DISCONNECTED";

        /**
         * Broadcast Action: An input method has been changed.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_INPUT_METHOD_CHANGED = "android.intent.action.INPUT_METHOD_CHANGED";

        /**
         * <p>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
         * more radios have been turned off or on. The intent will have the following extra value:</p>
         * <ul>
         *   <li><em>state</em> - A boolean value indicating whether Airplane Mode is on. If true,
         *   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
         *   turned off</li>
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_AIRPLANE_MODE_CHANGED = "android.intent.action.AIRPLANE_MODE";

        /**
         * Broadcast Action: Some content providers have parts of their namespace
         * where they publish new events or items that the user may be especially
         * interested in. For these things, they may broadcast this action when the
         * set of interesting items change.
         *
         * For example, GmailProvider sends this notification when the set of unread
         * mail in the inbox changes.
         *
         * <p>The data of the intent identifies which part of which provider
         * changed. When queried through the content resolver, the data URI will
         * return the data set in question.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>count</em> - The number of items in the data set. This is the
         *       same as the number of items in the cursor returned by querying the
         *       data URI. </li>
         * </ul>
         *
         * This intent will be sent at boot (if the count is non-zero) and when the
         * data set changes. It is possible for the data set to change without the
         * count changing (for example, if a new unread message arrives in the same
         * sync operation in which a message is archived). The phone should still
         * ring/vibrate/etc as normal in this case.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_PROVIDER_CHANGED = "android.intent.action.PROVIDER_CHANGED";

        /**
         * Broadcast Action: Wired Headset plugged in or unplugged.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
         *   <li><em>name</em> - Headset type, human readable string </li>
         *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
         * </ul>
         * </ul>
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";

        /**
         * <p>Broadcast Action: The user has switched on advanced settings in the settings app:</p>
         * <ul>
         *   <li><em>state</em> - A boolean value indicating whether the settings is on or off.</li>
         * </ul>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_ADVANCED_SETTINGS_CHANGED = "android.intent.action.ADVANCED_SETTINGS";

        /**
         *  Broadcast Action: Sent after application restrictions are changed.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.</p>
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_APPLICATION_RESTRICTIONS_CHANGED =
                "android.intent.action.APPLICATION_RESTRICTIONS_CHANGED";

        /**
         * Broadcast Action: An outgoing call is about to be placed.
         *
         * <p>The Intent will have the following extra value:
         * <ul>
         *   <li><em>{@link android.content.Intent#EXTRA_PHONE_NUMBER}</em> -
         *       the phone number originally intended to be dialed.</li>
         * </ul>
         * <p>Once the broadcast is finished, the resultData is used as the actual
         * number to call.  If  <code>null</code>, no call will be placed.</p>
         * <p>It is perfectly acceptable for multiple receivers to process the
         * outgoing call in turn: for example, a parental control application
         * might verify that the user is authorized to place the call at that
         * time, then a number-rewriting application might add an area code if
         * one was not specified.</p>
         * <p>For consistency, any receiver whose purpose is to prohibit phone
         * calls should have a priority of 0, to ensure it will see the final
         * phone number to be dialed.
         * Any receiver whose purpose is to rewrite phone numbers to be called
         * should have a positive priority.
         * Negative priorities are reserved for the system for this broadcast;
         * using them may cause problems.</p>
         * <p>Any BroadcastReceiver receiving this Intent <em>must not</em>
         * abort the broadcast.</p>
         * <p>Emergency calls cannot be intercepted using this mechanism, and
         * other calls cannot be modified to call emergency numbers using this
         * mechanism.
         * <p>You must hold the
         * {@link android.Manifest.permission#PROCESS_OUTGOING_CALLS}
         * permission to receive this Intent.</p>
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_NEW_OUTGOING_CALL = "android.intent.action.NEW_OUTGOING_CALL";

        /**
         * Broadcast Action: Have the device reboot.  This is only for use by
         * system code.
         *
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_REBOOT = "android.intent.action.REBOOT";

        /**
         * Broadcast Action:  A sticky broadcast for changes in the physical
         * docking state of the device.
         *
         * <p>The intent will have the following extra values:
         * <ul>
         *   <li><em>{@link #EXTRA_DOCK_STATE}</em> - the current dock
         *       state, indicating which dock the device is physically in.</li>
         * </ul>
         * <p>This is intended for monitoring the current physical dock state.
         * See {@link android.app.UiModeManager} for the normal API dealing with
         * dock mode changes.
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_DOCK_EVENT = "android.intent.action.DOCK_EVENT";

        /**
         * Broadcast Action: A broadcast when idle maintenance can be started.
         * This means that the user is not interacting with the device and is
         * not expected to do so soon. Typical use of the idle maintenance is
         * to perform somehow expensive tasks that can be postponed at a moment
         * when they will not degrade user experience.
         * <p>
         * <p class="note">In order to keep the device responsive in case of an
         * unexpected user interaction, implementations of a maintenance task
         * should be interruptible. In such a scenario a broadcast with action
         * {@link #ACTION_IDLE_MAINTENANCE_END} will be sent. In other words, you
         * should not do the maintenance work in
         * {@link BroadcastReceiver#onReceive(Context, Intent)}, rather start a
         * maintenance service by {@link Context#startService(Intent)}. Also
         * you should hold a wake lock while your maintenance service is running
         * to prevent the device going to sleep.
         * </p>
         * <p>
         * <p class="note">This is a protected intent that can only be sent by
         * the system.
         * </p>
         *
         * @see #ACTION_IDLE_MAINTENANCE_END
         *
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_IDLE_MAINTENANCE_START =
                "android.intent.action.ACTION_IDLE_MAINTENANCE_START";

        /**
         * Broadcast Action:  A broadcast when idle maintenance should be stopped.
         * This means that the user was not interacting with the device as a result
         * of which a broadcast with action {@link #ACTION_IDLE_MAINTENANCE_START}
         * was sent and now the user started interacting with the device. Typical
         * use of the idle maintenance is to perform somehow expensive tasks that
         * can be postponed at a moment when they will not degrade user experience.
         * <p>
         * <p class="note">In order to keep the device responsive in case of an
         * unexpected user interaction, implementations of a maintenance task
         * should be interruptible. Hence, on receiving a broadcast with this
         * action, the maintenance task should be interrupted as soon as possible.
         * In other words, you should not do the maintenance work in
         * {@link BroadcastReceiver#onReceive(Context, Intent)}, rather stop the
         * maintenance service that was started on receiving of
         * {@link #ACTION_IDLE_MAINTENANCE_START}.Also you should release the wake
         * lock you acquired when your maintenance service started.
         * </p>
         * <p class="note">This is a protected intent that can only be sent
         * by the system.
         *
         * @see #ACTION_IDLE_MAINTENANCE_START
         *
         * @hide
         */
        //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
        const String ACTION_IDLE_MAINTENANCE_END =
                "android.intent.action.ACTION_IDLE_MAINTENANCE_END";

        /**
         * Broadcast Action: a remote intent is to be broadcasted.
         *
         * A remote intent is used for remote RPC between devices. The remote intent
         * is serialized and sent from one device to another device. The receiving
         * device parses the remote intent and broadcasts it. Note that anyone can
         * broadcast a remote intent. However, if the intent receiver of the remote intent
         * does not trust intent broadcasts from arbitrary intent senders, it should require
         * the sender to hold certain permissions so only trusted sender's broadcast will be
         * let through.
         * @hide
         */
        const String ACTION_REMOTE_INTENT = "com.google.android.c2dm.intent.RECEIVE";

        /**
         * Broadcast Action: hook for permforming cleanup after a system update.
         *
         * The broadcast is sent when the system is booting, before the
         * BOOT_COMPLETED broadcast.  It is only sent to receivers in the system
         * image.  A receiver for this should do its work and then disable itself
         * so that it does not get run again at the next boot.
         * @hide
         */
        const String ACTION_PRE_BOOT_COMPLETED = "android.intent.action.PRE_BOOT_COMPLETED";

        /**
         * Broadcast to a specific application to query any supported restrictions to impose
         * on restricted users. The broadcast intent contains an extra
         * {@link #EXTRA_RESTRICTIONS_BUNDLE} with the currently persisted
         * restrictions as a Bundle of key/value pairs. The value types can be Boolean, String or
         * String[] depending on the restriction type.<p/>
         * The response should contain an extra {@link #EXTRA_RESTRICTIONS_LIST},
         * which is of type <code>ArrayList&lt;RestrictionEntry&gt;</code>. It can also
         * contain an extra {@link #EXTRA_RESTRICTIONS_INTENT}, which is of type <code>Intent</code>.
         * The activity specified by that intent will be launched for a result which must contain
         * one of the extras {@link #EXTRA_RESTRICTIONS_LIST} or {@link #EXTRA_RESTRICTIONS_BUNDLE}.
         * The keys and values of the returned restrictions will be persisted.
         * @see RestrictionEntry
         */
        const String ACTION_GET_RESTRICTION_ENTRIES =
                "android.intent.action.GET_RESTRICTION_ENTRIES";

        /**
         * @hide
         * Activity to challenge the user for a PIN that was configured when setting up
         * restrictions. Restrictions include blocking of apps and preventing certain user operations,
         * controlled by {@link android.os.UserManager#setUserRestrictions(Bundle).
         * Launch the activity using
         * {@link android.app.Activity#startActivityForResult(Intent, int)} and check if the
         * result is {@link android.app.Activity#RESULT_OK} for a successful response to the
         * challenge.<p/>
         * Before launching this activity, make sure that there is a PIN in effect, by calling
         * {@link android.os.UserManager#hasRestrictionsChallenge()}.
         */
        const String ACTION_RESTRICTIONS_CHALLENGE =
                "android.intent.action.RESTRICTIONS_CHALLENGE";

        /**
         * Sent the first time a user is starting, to allow system apps to
         * perform one time initialization.  (This will not be seen by third
         * party applications because a newly initialized user does not have any
         * third party applications installed for it.)  This is sent early in
         * starting the user, around the time the home app is started, before
         * {@link #ACTION_BOOT_COMPLETED} is sent.  This is sent as a foreground
         * broadcast, since it is part of a visible user interaction; be as quick
         * as possible when handling it.
         */
        const String ACTION_USER_INITIALIZE = "android.intent.action.USER_INITIALIZE";

        /**
         * Sent when a user switch is happening, causing the process's user to be
         * brought to the foreground.  This is only sent to receivers registered
         * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver}.  It is sent to the user that is going to the
         * foreground.  This is sent as a foreground
         * broadcast, since it is part of a visible user interaction; be as quick
         * as possible when handling it.
         */
        const String ACTION_USER_FOREGROUND = "android.intent.action.USER_FOREGROUND";

        /**
         * Sent when a user switch is happening, causing the process's user to be
         * sent to the background.  This is only sent to receivers registered
         * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
         * Context.registerReceiver}.  It is sent to the user that is going to the
         * background.  This is sent as a foreground
         * broadcast, since it is part of a visible user interaction; be as quick
         * as possible when handling it.
         */
        const String ACTION_USER_BACKGROUND = "android.intent.action.USER_BACKGROUND";

        /**
         * Broadcast sent to the system when a user is added. Carries an extra
         * EXTRA_USER_HANDLE that has the userHandle of the new user.  It is sent to
         * all running users.  You must hold
         * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
         * @hide
         */
        const String ACTION_USER_ADDED = "android.intent.action.USER_ADDED";

        /**
         * Broadcast sent by the system when a user is started. Carries an extra
         * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only sent to
         * registered receivers, not manifest receivers.  It is sent to the user
         * that has been started.  This is sent as a foreground
         * broadcast, since it is part of a visible user interaction; be as quick
         * as possible when handling it.
         * @hide
         */
        const String ACTION_USER_STARTED = "android.intent.action.USER_STARTED";

        /**
         * Broadcast sent when a user is in the process of starting.  Carries an extra
         * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
         * sent to registered receivers, not manifest receivers.  It is sent to all
         * users (including the one that is being started).  You must hold
         * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
         * this broadcast.  This is sent as a background broadcast, since
         * its result is not part of the primary UX flow; to safely keep track of
         * started/stopped state of a user you can use this in conjunction with
         * {@link #ACTION_USER_STOPPING}.  It is <b>not</b> generally safe to use with
         * other user state broadcasts since those are foreground broadcasts so can
         * execute in a different order.
         * @hide
         */
        const String ACTION_USER_STARTING = "android.intent.action.USER_STARTING";

        /**
         * Broadcast sent when a user is going to be stopped.  Carries an extra
         * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
         * sent to registered receivers, not manifest receivers.  It is sent to all
         * users (including the one that is being stopped).  You must hold
         * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
         * this broadcast.  The user will not stop until all receivers have
         * handled the broadcast.  This is sent as a background broadcast, since
         * its result is not part of the primary UX flow; to safely keep track of
         * started/stopped state of a user you can use this in conjunction with
         * {@link #ACTION_USER_STARTING}.  It is <b>not</b> generally safe to use with
         * other user state broadcasts since those are foreground broadcasts so can
         * execute in a different order.
         * @hide
         */
        const String ACTION_USER_STOPPING = "android.intent.action.USER_STOPPING";

        /**
         * Broadcast sent to the system when a user is stopped. Carries an extra
         * EXTRA_USER_HANDLE that has the userHandle of the user.  This is similar to
         * {@link #ACTION_PACKAGE_RESTARTED}, but for an entire user instead of a
         * specific package.  This is only sent to registered receivers, not manifest
         * receivers.  It is sent to all running users <em>except</em> the one that
         * has just been stopped (which is no longer running).
         * @hide
         */
        const String ACTION_USER_STOPPED = "android.intent.action.USER_STOPPED";

        /**
         * Broadcast sent to the system when a user is removed. Carries an extra EXTRA_USER_HANDLE that has
         * the userHandle of the user.  It is sent to all running users except the
         * one that has been removed. The user will not be completely removed until all receivers have
         * handled the broadcast. You must hold
         * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
         * @hide
         */
        const String ACTION_USER_REMOVED = "android.intent.action.USER_REMOVED";

        /**
         * Broadcast sent to the system when the user switches. Carries an extra EXTRA_USER_HANDLE that has
         * the userHandle of the user to become the current one. This is only sent to
         * registered receivers, not manifest receivers.  It is sent to all running users.
         * You must hold
         * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
         * @hide
         */
        const String ACTION_USER_SWITCHED = "android.intent.action.USER_SWITCHED";

        /**
         * Broadcast sent to the system when a user's information changes. Carries an extra
         * {@link #EXTRA_USER_HANDLE} to indicate which user's information changed.
         * This is only sent to registered receivers, not manifest receivers. It is sent to the user
         * whose information has changed.
         * @hide
         */
        const String ACTION_USER_INFO_CHANGED = "android.intent.action.USER_INFO_CHANGED";

        /**
         * Broadcast sent to the primary user when an associated managed profile is added (the profile
         * was created and is ready to be used). Carries an extra {@link #EXTRA_USER} that specifies
         * the UserHandle of the profile that was added. Only applications (for example Launchers)
         * that need to display merged content across both primary and managed profiles need to
         * worry about this broadcast. This is only sent to registered receivers,
         * not manifest receivers.
         */
        const String ACTION_MANAGED_PROFILE_ADDED =
                "android.intent.action.MANAGED_PROFILE_ADDED";

        /**
         * Broadcast sent to the primary user when an associated managed profile is removed. Carries an
         * extra {@link #EXTRA_USER} that specifies the UserHandle of the profile that was removed.
         * Only applications (for example Launchers) that need to display merged content across both
         * primary and managed profiles need to worry about this broadcast. This is only sent to
         * registered receivers, not manifest receivers.
         */
        const String ACTION_MANAGED_PROFILE_REMOVED =
                "android.intent.action.MANAGED_PROFILE_REMOVED";

        /**
         * Sent when the user taps on the clock widget in the system's "quick settings" area.
         */
        const String ACTION_QUICK_CLOCK = "android.intent.action.QUICK_CLOCK";

        /**
         * Activity Action: Shows the brightness setting dialog.
         * @hide
         */
        const String ACTION_SHOW_BRIGHTNESS_DIALOG =
                "android.intent.action.SHOW_BRIGHTNESS_DIALOG";

        /**
         * Broadcast Action:  A global button was pressed.  Includes a single
         * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
         * caused the broadcast.
         * @hide
         */
        const String ACTION_GLOBAL_BUTTON = "android.intent.action.GLOBAL_BUTTON";

        /**
         * Activity Action: Allow the user to select and return one or more existing
         * documents. When invoked, the system will display the various
         * {@link DocumentsProvider} instances installed on the device, letting the
         * user interactively navigate through them. These documents include local
         * media, such as photos and video, and documents provided by installed
         * cloud storage providers.
         * <p>
         * Each document is represented as a {@code content://} URI backed by a
         * {@link DocumentsProvider}, which can be opened as a stream with
         * {@link ContentResolver#openFileDescriptor(Uri, String)}, or queried for
         * {@link android.provider.DocumentsContract.Document} metadata.
         * <p>
         * All selected documents are returned to the calling application with
         * persistable read and write permission grants. If you want to maintain
         * access to the documents across device reboots, you need to explicitly
         * take the persistable permissions using
         * {@link ContentResolver#takePersistableUriPermission(Uri, int)}.
         * <p>
         * Callers must indicate the acceptable document MIME types through
         * {@link #setType(String)}. For example, to select photos, use
         * {@code image/*}. If multiple disjoint MIME types are acceptable, define
         * them in {@link #EXTRA_MIME_TYPES} and {@link #setType(String)} to
         * {@literal *}/*.
         * <p>
         * If the caller can handle multiple returned items (the user performing
         * multiple selection), then you can specify {@link #EXTRA_ALLOW_MULTIPLE}
         * to indicate this.
         * <p>
         * Callers must include {@link #CATEGORY_OPENABLE} in the Intent so that
         * returned URIs can be opened with
         * {@link ContentResolver#openFileDescriptor(Uri, String)}.
         * <p>
         * Output: The URI of the item that was picked, returned in
         * {@link #getData()}. This must be a {@code content://} URI so that any
         * receiver can access it. If multiple documents were selected, they are
         * returned in {@link #getClipData()}.
         *
         * @see DocumentsContract
         * @see #ACTION_OPEN_DOCUMENT_TREE
         * @see #ACTION_CREATE_DOCUMENT
         * @see #FLAG_GRANT_PERSISTABLE_URI_PERMISSION
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_OPEN_DOCUMENT = "android.intent.action.OPEN_DOCUMENT";

        /**
         * Activity Action: Allow the user to create a new document. When invoked,
         * the system will display the various {@link DocumentsProvider} instances
         * installed on the device, letting the user navigate through them. The
         * returned document may be a newly created document with no content, or it
         * may be an existing document with the requested MIME type.
         * <p>
         * Each document is represented as a {@code content://} URI backed by a
         * {@link DocumentsProvider}, which can be opened as a stream with
         * {@link ContentResolver#openFileDescriptor(Uri, String)}, or queried for
         * {@link android.provider.DocumentsContract.Document} metadata.
         * <p>
         * Callers must indicate the concrete MIME type of the document being
         * created by setting {@link #setType(String)}. This MIME type cannot be
         * changed after the document is created.
         * <p>
         * Callers can provide an initial display name through {@link #EXTRA_TITLE},
         * but the user may change this value before creating the file.
         * <p>
         * Callers must include {@link #CATEGORY_OPENABLE} in the Intent so that
         * returned URIs can be opened with
         * {@link ContentResolver#openFileDescriptor(Uri, String)}.
         * <p>
         * Output: The URI of the item that was created. This must be a
         * {@code content://} URI so that any receiver can access it.
         *
         * @see DocumentsContract
         * @see #ACTION_OPEN_DOCUMENT
         * @see #ACTION_OPEN_DOCUMENT_TREE
         * @see #FLAG_GRANT_PERSISTABLE_URI_PERMISSION
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_CREATE_DOCUMENT = "android.intent.action.CREATE_DOCUMENT";

        /**
         * Activity Action: Allow the user to pick a directory subtree. When
         * invoked, the system will display the various {@link DocumentsProvider}
         * instances installed on the device, letting the user navigate through
         * them. Apps can fully manage documents within the returned directory.
         * <p>
         * To gain access to descendant (child, grandchild, etc) documents, use
         * {@link DocumentsContract#buildDocumentUriUsingTree(Uri, String)} and
         * {@link DocumentsContract#buildChildDocumentsUriUsingTree(Uri, String)}
         * with the returned URI.
         * <p>
         * Output: The URI representing the selected directory tree.
         *
         * @see DocumentsContract
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String
                ACTION_OPEN_DOCUMENT_TREE = "android.intent.action.OPEN_DOCUMENT_TREE";

        /** {@hide} */
        const String ACTION_MASTER_CLEAR = "android.intent.action.MASTER_CLEAR";


        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Standard intent categories (see addCategory()).

        /**
         * Set if the activity should be an option for the default action
         * (center press) to perform on a piece of data.  Setting this will
         * hide from the user any activities without it set when performing an
         * action on some data.  Note that this is normal -not- set in the
         * Intent when initiating an action -- it is for use in intent filters
         * specified in packages.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_DEFAULT = "android.intent.category.DEFAULT";

        /**
         * Activities that can be safely invoked from a browser must support this
         * category.  For example, if the user is viewing a web page or an e-mail
         * and clicks on a link in the text, the Intent generated execute that
         * link will require the BROWSABLE category, so that only activities
         * supporting this category will be considered as possible actions.  By
         * supporting this category, you are promising that there is nothing
         * damaging (without user intervention) that can happen by invoking any
         * matching Intent.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_BROWSABLE = "android.intent.category.BROWSABLE";

        /**
         * @hide
         * Categories for activities that can participate in voice interaction.
         * An activity that supports this category must be prepared to run with
         * no UI shown at all (though in some case it may have a UI shown), and
         * rely on {@link android.app.VoiceInteractor} to interact with the user.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        //@SystemApi
        const String CATEGORY_VOICE = "android.intent.category.VOICE";

        /**
         * Set if the activity should be considered as an alternative action to
         * the data the user is currently viewing.  See also
         * {@link #CATEGORY_SELECTED_ALTERNATIVE} for an alternative action that
         * applies to the selection in a list of items.
         *
         * <p>Supporting this category means that you would like your activity to be
         * displayed in the set of alternative things the user can do, usually as
         * part of the current activity's options menu.  You will usually want to
         * include a specific label in the &lt;intent-filter&gt; of this action
         * describing to the user what it does.
         *
         * <p>The action of IntentFilter with this category is important in that it
         * describes the specific action the target will perform.  This generally
         * should not be a generic action (such as {@link #ACTION_VIEW}, but rather
         * a specific name such as "com.android.camera.action.CROP.  Only one
         * alternative of any particular action will be shown to the user, so using
         * a specific action like this makes sure that your alternative will be
         * displayed while also allowing other applications to provide their own
         * overrides of that particular action.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_ALTERNATIVE = "android.intent.category.ALTERNATIVE";

        /**
         * Set if the activity should be considered as an alternative selection
         * action to the data the user has currently selected.  This is like
         * {@link #CATEGORY_ALTERNATIVE}, but is used in activities showing a list
         * of items from which the user can select, giving them alternatives to the
         * default action that will be performed on it.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_SELECTED_ALTERNATIVE = "android.intent.category.SELECTED_ALTERNATIVE";

        /**
         * Intended to be used as a tab inside of a containing TabActivity.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_TAB = "android.intent.category.TAB";

        /**
         * Should be displayed in the top-level launcher.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER";

        /**
         * Indicates an activity optimized for Leanback mode, and that should
         * be displayed in the Leanback launcher.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_LEANBACK_LAUNCHER = "android.intent.category.LEANBACK_LAUNCHER";
        /**
         * Indicates a Leanback settings activity to be displayed in the Leanback launcher.
         * @hide
         */
        //@SystemApi
        const String CATEGORY_LEANBACK_SETTINGS = "android.intent.category.LEANBACK_SETTINGS";

        /**
         * Provides information about the package it is in; typically used if
         * a package does not contain a {@link #CATEGORY_LAUNCHER} to provide
         * a front-door to the user without having to be shown in the all apps list.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_INFO = "android.intent.category.INFO";

        /**
         * This is the home activity, that is the first activity that is displayed
         * when the device boots.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_HOME = "android.intent.category.HOME";

        /**
         * This activity is a preference panel.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_PREFERENCE = "android.intent.category.PREFERENCE";

        /**
         * This activity is a development preference panel.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_DEVELOPMENT_PREFERENCE = "android.intent.category.DEVELOPMENT_PREFERENCE";

        /**
         * Capable of running inside a parent activity container.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_EMBED = "android.intent.category.EMBED";

        /**
         * This activity allows the user to browse and download new applications.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_MARKET = "android.intent.category.APP_MARKET";

        /**
         * This activity may be exercised by the monkey or other automated test tools.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_MONKEY = "android.intent.category.MONKEY";

        /**
         * To be used as a test (not part of the normal user experience).
         */
        const String CATEGORY_TEST = "android.intent.category.TEST";

        /**
         * To be used as a unit test (run through the Test Harness).
         */
        const String CATEGORY_UNIT_TEST = "android.intent.category.UNIT_TEST";

        /**
         * To be used as a sample code example (not part of the normal user
         * experience).
         */
        const String CATEGORY_SAMPLE_CODE = "android.intent.category.SAMPLE_CODE";

        /**
         * Used to indicate that a GET_CONTENT intent only wants URIs that can be opened with
         * ContentResolver.openInputStream. Openable URIs must support the columns in OpenableColumns
         * when queried, though it is allowable for those columns to be blank.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_OPENABLE = "android.intent.category.OPENABLE";

        /**
         * To be used as code under test for framework instrumentation tests.
         */
        const String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST = "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";

        /**
         * An activity to run when device is inserted into a car dock.
         * Used with {@link #ACTION_MAIN} to launch an activity.  For more
         * information, see {@link android.app.UiModeManager}.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_CAR_DOCK = "android.intent.category.CAR_DOCK";

        /**
         * An activity to run when device is inserted into a car dock.
         * Used with {@link #ACTION_MAIN} to launch an activity.  For more
         * information, see {@link android.app.UiModeManager}.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_DESK_DOCK = "android.intent.category.DESK_DOCK";

        /**
         * An activity to run when device is inserted into a analog (low end) dock.
         * Used with {@link #ACTION_MAIN} to launch an activity.  For more
         * information, see {@link android.app.UiModeManager}.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_LE_DESK_DOCK = "android.intent.category.LE_DESK_DOCK";

        /**
         * An activity to run when device is inserted into a digital (high end) dock.
         * Used with {@link #ACTION_MAIN} to launch an activity.  For more
         * information, see {@link android.app.UiModeManager}.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_HE_DESK_DOCK = "android.intent.category.HE_DESK_DOCK";

        /**
         * Used to indicate that the activity can be used in a car environment.
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";

        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Application launch intent categories (see addCategory()).

        /**
         * Used with {@link #ACTION_MAIN} to launch the browser application.
         * The activity should be able to browse the Internet.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_BROWSER = "android.intent.category.APP_BROWSER";

        /**
         * Used with {@link #ACTION_MAIN} to launch the calculator application.
         * The activity should be able to perform standard arithmetic operations.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_CALCULATOR = "android.intent.category.APP_CALCULATOR";

        /**
         * Used with {@link #ACTION_MAIN} to launch the calendar application.
         * The activity should be able to view and manipulate calendar entries.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_CALENDAR = "android.intent.category.APP_CALENDAR";

        /**
         * Used with {@link #ACTION_MAIN} to launch the contacts application.
         * The activity should be able to view and manipulate address book entries.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_CONTACTS = "android.intent.category.APP_CONTACTS";

        /**
         * Used with {@link #ACTION_MAIN} to launch the email application.
         * The activity should be able to send and receive email.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_EMAIL = "android.intent.category.APP_EMAIL";

        /**
         * Used with {@link #ACTION_MAIN} to launch the gallery application.
         * The activity should be able to view and manipulate image and video files
         * stored on the device.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_GALLERY = "android.intent.category.APP_GALLERY";

        /**
         * Used with {@link #ACTION_MAIN} to launch the maps application.
         * The activity should be able to show the user's current location and surroundings.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_MAPS = "android.intent.category.APP_MAPS";

        /**
         * Used with {@link #ACTION_MAIN} to launch the messaging application.
         * The activity should be able to send and receive text messages.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_MESSAGING = "android.intent.category.APP_MESSAGING";

        /**
         * Used with {@link #ACTION_MAIN} to launch the music application.
         * The activity should be able to play, browse, or manipulate music files
         * stored on the device.
         * <p>NOTE: This should not be used as the primary key of an Intent,
         * since it will not result in the app launching with the correct
         * action and category.  Instead, use this with
         * {@link #makeMainSelectorActivity(String, String)} to generate a main
         * Intent with this category in the selector.</p>
         */
        //@SdkConstant(SdkConstantType.INTENT_CATEGORY)
        const String CATEGORY_APP_MUSIC = "android.intent.category.APP_MUSIC";

        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Standard extra data keys.

        /**
         * The initial data to place in a newly created record.  Use with
         * {@link #ACTION_INSERT}.  The data here is a Map containing the same
         * fields as would be given to the underlying ContentProvider.insert()
         * call.
         */
        const String EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";

        /**
         * A constant CharSequence that is associated with the Intent, used with
         * {@link #ACTION_SEND} to supply the literal data to be sent.  Note that
         * this may be a styled CharSequence, so you must use
         * {@link Bundle#getCharSequence(String) Bundle.getCharSequence()} to
         * retrieve it.
         */
        const String EXTRA_TEXT = "android.intent.extra.TEXT";

        /**
         * A constant String that is associated with the Intent, used with
         * {@link #ACTION_SEND} to supply an alternative to {@link #EXTRA_TEXT}
         * as HTML formatted text.  Note that you <em>must</em> also supply
         * {@link #EXTRA_TEXT}.
         */
        const String EXTRA_HTML_TEXT = "android.intent.extra.HTML_TEXT";

        /**
         * A content: URI holding a stream of data associated with the Intent,
         * used with {@link #ACTION_SEND} to supply the data being sent.
         */
        const String EXTRA_STREAM = "android.intent.extra.STREAM";

        /**
         * A String[] holding e-mail addresses that should be delivered to.
         */
        const String EXTRA_EMAIL = "android.intent.extra.EMAIL";

        /**
         * A String[] holding e-mail addresses that should be carbon copied.
         */
        const String EXTRA_CC = "android.intent.extra.CC";

        /**
         * A String[] holding e-mail addresses that should be blind carbon copied.
         */
        const String EXTRA_BCC = "android.intent.extra.BCC";

        /**
         * A constant string holding the desired subject line of a message.
         */
        const String EXTRA_SUBJECT  = "android.intent.extra.SUBJECT";

        /**
         * An Intent describing the choices you would like shown with
         * {@link #ACTION_PICK_ACTIVITY}.
         */
        const String EXTRA_INTENT = "android.intent.extra.INTENT";

        /**
         * A CharSequence dialog title to provide to the user when used with a
         * {@link #ACTION_CHOOSER}.
         */
        const String EXTRA_TITLE = "android.intent.extra.TITLE";

        /**
         * A Parcelable[] of {@link Intent} or
         * {@link android.content.pm.LabeledIntent} objects as set with
         * {@link #putExtra(String, Parcelable[])} of additional activities to place
         * a the front of the list of choices, when shown to the user with a
         * {@link #ACTION_CHOOSER}.
         */
        const String EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";

        /**
         * A Bundle forming a mapping of potential target package names to different extras Bundles
         * to add to the default intent extras in {@link #EXTRA_INTENT} when used with
         * {@link #ACTION_CHOOSER}. Each key should be a package name. The package need not
         * be currently installed on the device.
         *
         * <p>An application may choose to provide alternate extras for the case where a user
         * selects an activity from a predetermined set of target packages. If the activity
         * the user selects from the chooser belongs to a package with its package name as
         * a key in this bundle, the corresponding extras for that package will be merged with
         * the extras already present in the intent at {@link #EXTRA_INTENT}. If a replacement
         * extra has the same key as an extra already present in the intent it will overwrite
         * the extra from the intent.</p>
         *
         * <p><em>Examples:</em>
         * <ul>
         *     <li>An application may offer different {@link #EXTRA_TEXT} to an application
         *     when sharing with it via {@link #ACTION_SEND}, augmenting a link with additional query
         *     parameters for that target.</li>
         *     <li>An application may offer additional metadata for known targets of a given intent
         *     to pass along information only relevant to that target such as account or content
         *     identifiers already known to that application.</li>
         * </ul></p>
         */
        const String EXTRA_REPLACEMENT_EXTRAS =
                "android.intent.extra.REPLACEMENT_EXTRAS";

        /**
         * A {@link android.view.KeyEvent} object containing the event that
         * triggered the creation of the Intent it is in.
         */
        const String EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";

        /**
         * Set to true in {@link #ACTION_REQUEST_SHUTDOWN} to request confirmation from the user
         * before shutting down.
         *
         * {@hide}
         */
        const String EXTRA_KEY_CONFIRM = "android.intent.extra.KEY_CONFIRM";

        /**
         * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
         * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} intents to override the default action
         * of restarting the application.
         */
        const String EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";

        /**
         * A String holding the phone number originally entered in
         * {@link android.content.Intent#ACTION_NEW_OUTGOING_CALL}, or the actual
         * number to call in a {@link android.content.Intent#ACTION_CALL}.
         */
        const String EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";

        /**
         * Used as an int extra field in {@link android.content.Intent#ACTION_UID_REMOVED}
         * intents to supply the uid the package had been assigned.  Also an optional
         * extra in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
         * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} for the same
         * purpose.
         */
        const String EXTRA_UID = "android.intent.extra.UID";

        /**
         * @hide String array of package names.
         */
        const String EXTRA_PACKAGES = "android.intent.extra.PACKAGES";

        /**
         * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
         * intents to indicate whether this represents a full uninstall (removing
         * both the code and its data) or a partial uninstall (leaving its data,
         * implying that this is an update).
         */
        const String EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";

        /**
         * @hide
         * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
         * intents to indicate that at this point the package has been removed for
         * all users on the device.
         */
        const String EXTRA_REMOVED_FOR_ALL_USERS = "android.intent.extra.REMOVED_FOR_ALL_USERS";

        /**
         * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
         * intents to indicate that this is a replacement of the package, so this
         * broadcast will immediately be followed by an add broadcast for a
         * different version of the same package.
         */
        const String EXTRA_REPLACING = "android.intent.extra.REPLACING";

        /**
         * Used as an int extra field in {@link android.app.AlarmManager} intents
         * to tell the application being invoked how many pending alarms are being
         * delievered with the intent.  For one-shot alarms this will always be 1.
         * For recurring alarms, this might be greater than 1 if the device was
         * asleep or powered off at the time an earlier alarm would have been
         * delivered.
         */
        const String EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";

        /**
         * Used as an int extra field in {@link android.content.Intent#ACTION_DOCK_EVENT}
         * intents to request the dock state.  Possible values are
         * {@link android.content.Intent#EXTRA_DOCK_STATE_UNDOCKED},
         * {@link android.content.Intent#EXTRA_DOCK_STATE_DESK}, or
         * {@link android.content.Intent#EXTRA_DOCK_STATE_CAR}, or
         * {@link android.content.Intent#EXTRA_DOCK_STATE_LE_DESK}, or
         * {@link android.content.Intent#EXTRA_DOCK_STATE_HE_DESK}.
         */
        const String EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";

        /**
         * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
         * to represent that the phone is not in any dock.
         */
        const Int32 EXTRA_DOCK_STATE_UNDOCKED = 0;

        /**
         * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
         * to represent that the phone is in a desk dock.
         */
        const Int32 EXTRA_DOCK_STATE_DESK = 1;

        /**
         * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
         * to represent that the phone is in a car dock.
         */
        const Int32 EXTRA_DOCK_STATE_CAR = 2;

        /**
         * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
         * to represent that the phone is in a analog (low end) dock.
         */
        const Int32 EXTRA_DOCK_STATE_LE_DESK = 3;

        /**
         * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
         * to represent that the phone is in a digital (high end) dock.
         */
        const Int32 EXTRA_DOCK_STATE_HE_DESK = 4;

        /**
         * Boolean that can be supplied as meta-data with a dock activity, to
         * indicate that the dock should take over the home key when it is active.
         */
        const String METADATA_DOCK_HOME = "android.dock_home";

        /**
         * Used as a parcelable extra field in {@link #ACTION_APP_ERROR}, containing
         * the bug report.
         */
        const String EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";

        /**
         * Used in the extra field in the remote intent. It's astring token passed with the
         * remote intent.
         */
        const String EXTRA_REMOTE_INTENT_TOKEN = "android.intent.extra.remote_intent_token";

        /**
         * @deprecated See {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST}; this field
         * will contain only the first name in the list.
         */
        //@Deprecated
        const String EXTRA_CHANGED_COMPONENT_NAME = "android.intent.extra.changed_component_name";

        /**
         * This field is part of {@link android.content.Intent#ACTION_PACKAGE_CHANGED},
         * and contains a string array of all of the components that have changed.
         */
        const String EXTRA_CHANGED_COMPONENT_NAME_LIST = "android.intent.extra.changed_component_name_list";

        /**
         * This field is part of
         * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
         * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
         * and contains a string array of all of the components that have changed.
         */
        const String EXTRA_CHANGED_PACKAGE_LIST = "android.intent.extra.changed_package_list";

        /**
         * This field is part of
         * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
         * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
         * and contains an integer array of uids of all of the components
         * that have changed.
         */
        const String EXTRA_CHANGED_UID_LIST = "android.intent.extra.changed_uid_list";

        /**
         * @hide
         * Magic extra system code can use when binding, to give a label for
         * who it is that has bound to a service.  This is an integer giving
         * a framework string resource that can be displayed to the user.
         */
        const String EXTRA_CLIENT_LABEL = "android.intent.extra.client_label";

        /**
         * @hide
         * Magic extra system code can use when binding, to give a PendingIntent object
         * that can be launched for the user to disable the system's use of this
         * service.
         */
        const String EXTRA_CLIENT_INTENT = "android.intent.extra.client_intent";

        /**
         * Used to indicate that a {@link #ACTION_GET_CONTENT} intent should only return
         * data that is on the local device.  This is a boolean extra; the default
         * is false.  If true, an implementation of ACTION_GET_CONTENT should only allow
         * the user to select media that is already on the device, not requiring it
         * be downloaded from a remote service when opened.  Another way to look
         * at it is that such content should generally have a "_data" column to the
         * path of the content on local external storage.
         */
        const String EXTRA_LOCAL_ONLY = "android.intent.extra.LOCAL_ONLY";

        /**
         * Extra used to indicate that an intent can allow the user to select and
         * return multiple items. This is a boolean extra; the default is false. If
         * true, an implementation is allowed to present the user with a UI where
         * they can pick multiple items that are all returned to the caller. When
         * this happens, they should be returned as the {@link #getClipData()} part
         * of the result Intent.
         *
         * @see #ACTION_GET_CONTENT
         * @see #ACTION_OPEN_DOCUMENT
         */
        const String EXTRA_ALLOW_MULTIPLE =
                "android.intent.extra.ALLOW_MULTIPLE";

        /**
         * The userHandle carried with broadcast intents related to addition, removal and switching of users
         * - {@link #ACTION_USER_ADDED}, {@link #ACTION_USER_REMOVED} and {@link #ACTION_USER_SWITCHED}.
         * @hide
         */
        const String EXTRA_USER_HANDLE = "android.intent.extra.user_handle";

        /**
         * The UserHandle carried with broadcasts intents related to addition and removal of managed
         * profiles - {@link #ACTION_MANAGED_PROFILE_ADDED} and {@link #ACTION_MANAGED_PROFILE_REMOVED}.
         */
        const String EXTRA_USER =
                "android.intent.extra.USER";

        /**
         * Extra used in the response from a BroadcastReceiver that handles
         * {@link #ACTION_GET_RESTRICTION_ENTRIES}. The type of the extra is
         * <code>ArrayList&lt;RestrictionEntry&gt;</code>.
         */
        const String EXTRA_RESTRICTIONS_LIST = "android.intent.extra.restrictions_list";

        /**
         * Extra sent in the intent to the BroadcastReceiver that handles
         * {@link #ACTION_GET_RESTRICTION_ENTRIES}. The type of the extra is a Bundle containing
         * the restrictions as key/value pairs.
         */
        const String EXTRA_RESTRICTIONS_BUNDLE =
                "android.intent.extra.restrictions_bundle";

        /**
         * Extra used in the response from a BroadcastReceiver that handles
         * {@link #ACTION_GET_RESTRICTION_ENTRIES}.
         */
        const String EXTRA_RESTRICTIONS_INTENT =
                "android.intent.extra.restrictions_intent";

        /**
         * Extra used to communicate a set of acceptable MIME types. The type of the
         * extra is {@code String[]}. Values may be a combination of concrete MIME
         * types (such as "image/png") and/or partial MIME types (such as
         * "audio/*").
         *
         * @see #ACTION_GET_CONTENT
         * @see #ACTION_OPEN_DOCUMENT
         */
        const String EXTRA_MIME_TYPES = "android.intent.extra.MIME_TYPES";

        /**
         * Optional extra for {@link #ACTION_SHUTDOWN} that allows the sender to qualify that
         * this shutdown is only for the user space of the system, not a complete shutdown.
         * When this is true, hardware devices can use this information to determine that
         * they shouldn't do a complete shutdown of their device since this is not a
         * complete shutdown down to the kernel, but only user space restarting.
         * The default if not supplied is false.
         */
        const String EXTRA_SHUTDOWN_USERSPACE_ONLY
                = "android.intent.extra.SHUTDOWN_USERSPACE_ONLY";

        /**
         * Optional boolean extra for {@link #ACTION_TIME_CHANGED} that indicates the
         * user has set their time format preferences to the 24 hour format.
         *
         * @hide for internal use only.
         */
        const String EXTRA_TIME_PREF_24_HOUR_FORMAT =
                "android.intent.extra.TIME_PREF_24_HOUR_FORMAT";

        /** {@hide} */
        const String EXTRA_REASON = "android.intent.extra.REASON";


        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // Intent flags (see mFlags variable).

        /**
         * If set, the recipient of this Intent will be granted permission to
         * perform read operations on the Uri in the Intent's data and any URIs
         * specified in its ClipData.  When applying to an Intent's ClipData,
         * all URIs as well as recursive traversals through data or other ClipData
         * in Intent items will be granted; only the grant flags of the top-level
         * Intent are used.
         */
        const Int32 FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;

        /**
         * If set, the recipient of this Intent will be granted permission to
         * perform write operations on the Uri in the Intent's data and any URIs
         * specified in its ClipData.  When applying to an Intent's ClipData,
         * all URIs as well as recursive traversals through data or other ClipData
         * in Intent items will be granted; only the grant flags of the top-level
         * Intent are used.
         */
        const Int32 FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002;

        /**
         * Can be set by the caller to indicate that this Intent is coming from
         * a background operation, not from direct user interaction.
         */
        const Int32 FLAG_FROM_BACKGROUND = 0x00000004;

        /**
         * A flag you can enable for debugging: when set, log messages will be
         * printed during the resolution of this intent to show you what has
         * been found to create the final resolved list.
         */
        const Int32 FLAG_DEBUG_LOG_RESOLUTION = 0x00000008;

        /**
         * If set, this intent will not match any components in packages that
         * are currently stopped.  If this is not set, then the default behavior
         * is to include such applications in the result.
         */
        const Int32 FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;

        /**
         * If set, this intent will always match any components in packages that
         * are currently stopped.  This is the default behavior when
         * {@link #FLAG_EXCLUDE_STOPPED_PACKAGES} is not set.  If both of these
         * flags are set, this one wins (it allows overriding of exclude for
         * places where the framework may automatically set the exclude flag).
         */
        const Int32 FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;

        /**
         * When combined with {@link #FLAG_GRANT_READ_URI_PERMISSION} and/or
         * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, the URI permission grant can be
         * persisted across device reboots until explicitly revoked with
         * {@link Context#revokeUriPermission(Uri, int)}. This flag only offers the
         * grant for possible persisting; the receiving application must call
         * {@link ContentResolver#takePersistableUriPermission(Uri, int)} to
         * actually persist.
         *
         * @see ContentResolver#takePersistableUriPermission(Uri, int)
         * @see ContentResolver#releasePersistableUriPermission(Uri, int)
         * @see ContentResolver#getPersistedUriPermissions()
         * @see ContentResolver#getOutgoingPersistedUriPermissions()
         */
        const Int32 FLAG_GRANT_PERSISTABLE_URI_PERMISSION = 0x00000040;

        /**
         * When combined with {@link #FLAG_GRANT_READ_URI_PERMISSION} and/or
         * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, the URI permission grant
         * applies to any URI that is a prefix match against the original granted
         * URI. (Without this flag, the URI must match exactly for access to be
         * granted.) Another URI is considered a prefix match only when scheme,
         * authority, and all path segments defined by the prefix are an exact
         * match.
         */
        const Int32 FLAG_GRANT_PREFIX_URI_PERMISSION = 0x00000080;

        /**
         * If set, the new activity is not kept in the history stack.  As soon as
         * the user navigates away from it, the activity is finished.  This may also
         * be set with the {@link android.R.styleable#AndroidManifestActivity_noHistory
         * noHistory} attribute.
         */
        const Int32 FLAG_ACTIVITY_NO_HISTORY = 0x40000000;

        /**
         * If set, the activity will not be launched if it is already running
         * at the top of the history stack.
         */
        const Int32 FLAG_ACTIVITY_SINGLE_TOP = 0x20000000;

        /**
         * If set, this activity will become the start of a new task on this
         * history stack.  A task (from the activity that started it to the
         * next task activity) defines an atomic group of activities that the
         * user can move to.  Tasks can be moved to the foreground and background;
         * all of the activities inside of a particular task always remain in
         * the same order.  See
         * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
         * Stack</a> for more information about tasks.
         *
         * <p>This flag is generally used by activities that want
         * to present a "launcher" style behavior: they give the user a list of
         * separate things that can be done, which otherwise run completely
         * independently of the activity launching them.
         *
         * <p>When using this flag, if a task is already running for the activity
         * you are now starting, then a new activity will not be started; instead,
         * the current task will simply be brought to the front of the screen with
         * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
         * to disable this behavior.
         *
         * <p>This flag can not be used when the caller is requesting a result from
         * the activity being launched.
         */
        const Int32 FLAG_ACTIVITY_NEW_TASK = 0x10000000;

        /**
         * <strong>Do not use this flag unless you are implementing your own
         * top-level application launcher.</strong>  Used in conjunction with
         * {@link #FLAG_ACTIVITY_NEW_TASK} to disable the
         * behavior of bringing an existing task to the foreground.  When set,
         * a new task is <em>always</em> started to host the Activity for the
         * Intent, regardless of whether there is already an existing task running
         * the same thing.
         *
         * <p><strong>Because the default system does not include graphical task management,
         * you should not use this flag unless you provide some way for a user to
         * return back to the tasks you have launched.</strong>
         *
         * <p>This flag is ignored if
         * {@link #FLAG_ACTIVITY_NEW_TASK} is not set.
         *
         * <p>See
         * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
         * Stack</a> for more information about tasks.
         */
        const Int32 FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;

        /**
         * If set, and the activity being launched is already running in the
         * current task, then instead of launching a new instance of that activity,
         * all of the other activities on top of it will be closed and this Intent
         * will be delivered to the (now on top) old activity as a new Intent.
         *
         * <p>For example, consider a task consisting of the activities: A, B, C, D.
         * If D calls startActivity() with an Intent that resolves to the component
         * of activity B, then C and D will be finished and B receive the given
         * Intent, resulting in the stack now being: A, B.
         *
         * <p>The currently running instance of activity B in the above example will
         * either receive the new intent you are starting here in its
         * onNewIntent() method, or be itself finished and restarted with the
         * new intent.  If it has declared its launch mode to be "multiple" (the
         * default) and you have not set {@link #FLAG_ACTIVITY_SINGLE_TOP} in
         * the same intent, then it will be finished and re-created; for all other
         * launch modes or if {@link #FLAG_ACTIVITY_SINGLE_TOP} is set then this
         * Intent will be delivered to the current instance's onNewIntent().
         *
         * <p>This launch mode can also be used to good effect in conjunction with
         * {@link #FLAG_ACTIVITY_NEW_TASK}: if used to start the root activity
         * of a task, it will bring any currently running instance of that task
         * to the foreground, and then clear it to its root state.  This is
         * especially useful, for example, when launching an activity from the
         * notification manager.
         *
         * <p>See
         * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
         * Stack</a> for more information about tasks.
         */
        const Int32 FLAG_ACTIVITY_CLEAR_TOP = 0x04000000;

        /**
         * If set and this intent is being used to launch a new activity from an
         * existing one, then the reply target of the existing activity will be
         * transfered to the new activity.  This way the new activity can call
         * {@link android.app.Activity#setResult} and have that result sent back to
         * the reply target of the original activity.
         */
        const Int32 FLAG_ACTIVITY_FORWARD_RESULT = 0x02000000;

        /**
         * If set and this intent is being used to launch a new activity from an
         * existing one, the current activity will not be counted as the top
         * activity for deciding whether the new intent should be delivered to
         * the top instead of starting a new one.  The previous activity will
         * be used as the top, with the assumption being that the current activity
         * will finish itself immediately.
         */
        const Int32 FLAG_ACTIVITY_PREVIOUS_IS_TOP = 0x01000000;

        /**
         * If set, the new activity is not kept in the list of recently launched
         * activities.
         */
        const Int32 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 0x00800000;

        /**
         * This flag is not normally set by application code, but set for you by
         * the system as described in the
         * {@link android.R.styleable#AndroidManifestActivity_launchMode
         * launchMode} documentation for the singleTask mode.
         */
        const Int32 FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000;

        /**
         * If set, and this activity is either being started in a new task or
         * bringing to the top an existing task, then it will be launched as
         * the front door of the task.  This will result in the application of
         * any affinities needed to have that task in the proper state (either
         * moving activities to or from it), or simply resetting that task to
         * its initial state if needed.
         */
        const Int32 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 0x00200000;

        /**
         * This flag is not normally set by application code, but set for you by
         * the system if this activity is being launched from history
         * (longpress home key).
         */
        const Int32 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 0x00100000;

        /**
         * If set, this marks a point in the task's activity stack that should
         * be cleared when the task is reset.  That is, the next time the task
         * is brought to the foreground with
         * {@link #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED} (typically as a result of
         * the user re-launching it from home), this activity and all on top of
         * it will be finished so that the user does not return to them, but
         * instead returns to whatever activity preceeded it.
         *
         * <p>This is useful for cases where you have a logical break in your
         * application.  For example, an e-mail application may have a command
         * to view an attachment, which launches an image view activity to
         * display it.  This activity should be part of the e-mail application's
         * task, since it is a part of the task the user is involved in.  However,
         * if the user leaves that task, and later selects the e-mail app from
         * home, we may like them to return to the conversation they were
         * viewing, not the picture attachment, since that is confusing.  By
         * setting this flag when launching the image viewer, that viewer and
         * any activities it starts will be removed the next time the user returns
         * to mail.
         */
        const Int32 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 0x00080000;

        /**
         * This flag is used to open a document into a new task rooted at the activity launched
         * by this Intent. Through the use of this flag, or its equivalent attribute,
         * {@link android.R.attr#documentLaunchMode} multiple instances of the same activity
         * containing different douments will appear in the recent tasks list.
         *
         * <p>The use of the activity attribute form of this,
         * {@link android.R.attr#documentLaunchMode}, is
         * preferred over the Intent flag described here. The attribute form allows the
         * Activity to specify multiple document behavior for all launchers of the Activity
         * whereas using this flag requires each Intent that launches the Activity to specify it.
         *
         * <p>Note that the default semantics of this flag w.r.t. whether the recents entry for
         * it is kept after the activity is finished is different than the use of
         * {@link #FLAG_ACTIVITY_NEW_TASK} and {@link android.R.attr#documentLaunchMode} -- if
         * this flag is being used to create a new recents entry, then by default that entry
         * will be removed once the activity is finished.  You can modify this behavior with
         * {@link #FLAG_ACTIVITY_RETAIN_IN_RECENTS}.
         *
         * <p>FLAG_ACTIVITY_NEW_DOCUMENT may be used in conjunction with {@link
         * #FLAG_ACTIVITY_MULTIPLE_TASK}. When used alone it is the
         * equivalent of the Activity manifest specifying {@link
         * android.R.attr#documentLaunchMode}="intoExisting". When used with
         * FLAG_ACTIVITY_MULTIPLE_TASK it is the equivalent of the Activity manifest specifying
         * {@link android.R.attr#documentLaunchMode}="always".
         *
         * Refer to {@link android.R.attr#documentLaunchMode} for more information.
         *
         * @see android.R.attr#documentLaunchMode
         * @see #FLAG_ACTIVITY_MULTIPLE_TASK
         */
        const Int32 FLAG_ACTIVITY_NEW_DOCUMENT = FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET;

        /**
         * If set, this flag will prevent the normal {@link android.app.Activity#onUserLeaveHint}
         * callback from occurring on the current frontmost activity before it is
         * paused as the newly-started activity is brought to the front.
         *
         * <p>Typically, an activity can rely on that callback to indicate that an
         * explicit user action has caused their activity to be moved out of the
         * foreground. The callback marks an appropriate point in the activity's
         * lifecycle for it to dismiss any notifications that it intends to display
         * "until the user has seen them," such as a blinking LED.
         *
         * <p>If an activity is ever started via any non-user-driven events such as
         * phone-call receipt or an alarm handler, this flag should be passed to {@link
         * Context#startActivity Context.startActivity}, ensuring that the pausing
         * activity does not think the user has acknowledged its notification.
         */
        const Int32 FLAG_ACTIVITY_NO_USER_ACTION = 0x00040000;

        /**
         * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
         * this flag will cause the launched activity to be brought to the front of its
         * task's history stack if it is already running.
         *
         * <p>For example, consider a task consisting of four activities: A, B, C, D.
         * If D calls startActivity() with an Intent that resolves to the component
         * of activity B, then B will be brought to the front of the history stack,
         * with this resulting order:  A, C, D, B.
         *
         * This flag will be ignored if {@link #FLAG_ACTIVITY_CLEAR_TOP} is also
         * specified.
         */
        const Int32 FLAG_ACTIVITY_REORDER_TO_FRONT = 0X00020000;

        /**
         * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
         * this flag will prevent the system from applying an activity transition
         * animation to go to the next activity state.  This doesn't mean an
         * animation will never run -- if another activity change happens that doesn't
         * specify this flag before the activity started here is displayed, then
         * that transition will be used.  This flag can be put to good use
         * when you are going to do a series of activity operations but the
         * animation seen by the user shouldn't be driven by the first activity
         * change but rather a later one.
         */
        const Int32 FLAG_ACTIVITY_NO_ANIMATION = 0X00010000;

        /**
         * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
         * this flag will cause any existing task that would be associated with the
         * activity to be cleared before the activity is started.  That is, the activity
         * becomes the new root of an otherwise empty task, and any old activities
         * are finished.  This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
         */
        const Int32 FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;

        /**
         * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
         * this flag will cause a newly launching task to be placed on top of the current
         * home activity task (if there is one).  That is, pressing back from the task
         * will always return the user to home even if that was not the last activity they
         * saw.   This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
         */
        const Int32 FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;

        /**
         * By default a document created by {@link #FLAG_ACTIVITY_NEW_DOCUMENT} will
         * have its entry in recent tasks removed when the user closes it (with back
         * or however else it may finish()). If you would like to instead allow the
         * document to be kept in recents so that it can be re-launched, you can use
         * this flag. When set and the task's activity is finished, the recents
         * entry will remain in the interface for the user to re-launch it, like a
         * recents entry for a top-level application.
         * <p>
         * The receiving activity can override this request with
         * {@link android.R.attr#autoRemoveFromRecents} or by explcitly calling
         * {@link android.app.Activity#finishAndRemoveTask()
         * Activity.finishAndRemoveTask()}.
         */
        const Int32 FLAG_ACTIVITY_RETAIN_IN_RECENTS = 0x00002000;

        /**
         * If set, when sending a broadcast only registered receivers will be
         * called -- no BroadcastReceiver components will be launched.
         */
        const Int32 FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;

        /**
         * If set, when sending a broadcast the new broadcast will replace
         * any existing pending broadcast that matches it.  Matching is defined
         * by {@link Intent#filterEquals(Intent) Intent.filterEquals} returning
         * true for the intents of the two broadcasts.  When a match is found,
         * the new broadcast (and receivers associated with it) will replace the
         * existing one in the pending broadcast list, remaining at the same
         * position in the list.
         *
         * <p>This flag is most typically used with sticky broadcasts, which
         * only care about delivering the most recent values of the broadcast
         * to their receivers.
         */
        const Int32 FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;

        /**
         * If set, when sending a broadcast the recipient is allowed to run at
         * foreground priority, with a shorter timeout interval.  During normal
         * broadcasts the receivers are not automatically hoisted out of the
         * background priority class.
         */
        const Int32 FLAG_RECEIVER_FOREGROUND = 0x10000000;

        /**
         * If this is an ordered broadcast, don't allow receivers to abort the broadcast.
         * They can still propagate results through to later receivers, but they can not prevent
         * later receivers from seeing the broadcast.
         */
        const Int32 FLAG_RECEIVER_NO_ABORT = 0x08000000;

        /**
         * If set, when sending a broadcast <i>before boot has completed</i> only
         * registered receivers will be called -- no BroadcastReceiver components
         * will be launched.  Sticky intent state will be recorded properly even
         * if no receivers wind up being called.  If {@link #FLAG_RECEIVER_REGISTERED_ONLY}
         * is specified in the broadcast intent, this flag is unnecessary.
         *
         * <p>This flag is only for use by system sevices as a convenience to
         * avoid having to implement a more complex mechanism around detection
         * of boot completion.
         *
         * @hide
         */
        const Int32 FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x04000000;

        /**
         * Set when this broadcast is for a boot upgrade, a special mode that
         * allows the broadcast to be sent before the system is ready and launches
         * the app process with no providers running in it.
         * @hide
         */
        const Int32 FLAG_RECEIVER_BOOT_UPGRADE = 0x02000000;

        /**
         * @hide Flags that can't be changed with PendingIntent.
         */
        const Int32 IMMUTABLE_FLAGS = FLAG_GRANT_READ_URI_PERMISSION
                | FLAG_GRANT_WRITE_URI_PERMISSION
                | FLAG_GRANT_PERSISTABLE_URI_PERMISSION
                | FLAG_GRANT_PREFIX_URI_PERMISSION;

        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // toUri() and parseUri() options.

        /**
         * Flag for use with {@link #toUri} and {@link #parseUri}: the URI string
         * always has the "intent:" scheme.  This syntax can be used when you want
         * to later disambiguate between URIs that are intended to describe an
         * Intent vs. all others that should be treated as raw URIs.  When used
         * with {@link #parseUri}, any other scheme will result in a generic
         * VIEW action for that raw URI.
         */
        const Int32 URI_INTENT_SCHEME = 0x1;

        /**
         * Use with {@link #fillIn} to allow the current action value to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_ACTION = 0x1;

        /**
         * Use with {@link #fillIn} to allow the current data or type value
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_DATA = 0x2;

        /**
         * Use with {@link #fillIn} to allow the current categories to be
         * overwritten, even if they are already set.
         */
        const Int32 FILL_IN_CATEGORIES = 0x4;

        /**
         * Use with {@link #fillIn} to allow the current component value to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_COMPONENT = 0x8;

        /**
         * Use with {@link #fillIn} to allow the current package value to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_PACKAGE = 0x10;

        /**
         * Use with {@link #fillIn} to allow the current bounds rectangle to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_SOURCE_BOUNDS = 0x20;

        /**
         * Use with {@link #fillIn} to allow the current selector to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_SELECTOR = 0x40;

        /**
         * Use with {@link #fillIn} to allow the current ClipData to be
         * overwritten, even if it is already set.
         */
        const Int32 FILL_IN_CLIP_DATA = 0x80;

        /**
         * Make a clone of only the parts of the Intent that are relevant for
         * filter matching: the action, data, type, component, and categories.
         */
        CloneFilter(
            [out] IIntent** intent);

        /**
         * Retrieve the general action to be performed, such as
         * {@link #ACTION_VIEW}.  The action describes the general way the rest of
         * the information in the intent should be interpreted -- most importantly,
         * what to do with the data returned by {@link #getData}.
         *
         * @return The action of this intent or null if none is specified.
         *
         * @see #setAction
         */
        GetAction(
            [out] String* action);

        /**
         * Retrieve data this intent is operating on.  This URI specifies the name
         * of the data; often it uses the content: scheme, specifying data in a
         * content provider.  Other schemes may be handled by specific activities,
         * such as http: by the web browser.
         *
         * @return The URI of the data this intent is targeting or null.
         *
         * @see #getScheme
         * @see #setData
         */
        GetData(
            [out] IUri** data);

        /**
         * The same as {@link #getData()}, but returns the URI as an encoded
         * String.
         */
        GetDataString(
            [out] String* dataString);

        /**
         * Return the scheme portion of the intent's data.  If the data is null or
         * does not include a scheme, null is returned.  Otherwise, the scheme
         * prefix without the final ':' is returned, i.e. "http".
         *
         * <p>This is the same as calling getData().getScheme() (and checking for
         * null data).
         *
         * @return The scheme of this intent.
         *
         * @see #getData
         */
        GetScheme(
            [out] String* scheme);

        /**
         * Retrieve any explicit MIME type included in the intent.  This is usually
         * null, as the type is determined by the intent data.
         *
         * @return If a type was manually set, it is returned; else null is
         *         returned.
         *
         * @see #resolveType(ContentResolver)
         * @see #setType
         */
        GetType(
            [out] String* type);

        /**
         * Return the MIME data type of this intent.  If the type field is
         * explicitly set, that is simply returned.  Otherwise, if the data is set,
         * the type of that data is returned.  If neither fields are set, a null is
         * returned.
         *
         * @return The MIME type of this intent.
         *
         * @see #getType
         * @see #resolveType(ContentResolver)
         */
        ResolveType(
            [in] IContext* ctx,
            [out] String* type);

        /**
         * Return the MIME data type of this intent.  If the type field is
         * explicitly set, that is simply returned.  Otherwise, if the data is set,
         * the type of that data is returned.  If neither fields are set, a null is
         * returned.
         *
         * @param resolver A ContentResolver that can be used to determine the MIME
         *                 type of the intent's data.
         *
         * @return The MIME type of this intent.
         *
         * @see #getType
         * @see #resolveType(Context)
         */
        ResolveType(
            [in] IContentResolver* resolver,
            [out] String* type);

        /**
         * Return the MIME data type of this intent, only if it will be needed for
         * intent resolution.  This is not generally useful for application code;
         * it is used by the frameworks for communicating with back-end system
         * services.
         *
         * @param resolver A ContentResolver that can be used to determine the MIME
         *                 type of the intent's data.
         *
         * @return The MIME type of this intent, or null if it is unknown or not
         *         needed.
         */
        ResolveTypeIfNeeded(
            [in] IContentResolver* resolver,
            [out] String* type);

        /**
         * Check if a category exists in the intent.
         *
         * @param category The category to check.
         *
         * @return boolean True if the intent contains the category, else false.
         *
         * @see #getCategories
         * @see #addCategory
         */
        HasCategory(
            [in] String category,
            [out] Boolean* hasCategory);

        /**
         * Return the set of all categories in the intent.  If there are no categories,
         * returns NULL.
         *
         * @return The set of categories you can examine.  Do not modify!
         *
         * @see #hasCategory
         * @see #addCategory
         */
        GetCategories(
            [out, callee] ArrayOf<String>* categories);

        /**
         * Return the specific selector associated with this Intent.  If there is
         * none, returns null.  See {@link #setSelector} for more information.
         *
         * @see #setSelector
         */
        GetSelector(
            [out] IIntent** intent);

        /**
         * Return the {@link ClipData} associated with this Intent.  If there is
         * none, returns null.  See {@link #setClipData} for more information.
         *
         * @see #setClipData;
         */
        GetClipData(
            [out] IClipData** clipData);

        /**
         * Sets the ClassLoader that will be used when unmarshalling
         * any Parcelable values from the extras of this Intent.
         *
         * @param loader a ClassLoader, or null to use the default loader
         * at the time of unmarshalling.
         */
        //SetExtrasClassLoader(
        //    [in] IClassLoader* loader);

        /**
         * Returns true if an extra value is associated with the given name.
         * @param name the extra's name
         * @return true if the given extra is present.
         */
        HasExtra(
            [in] String name,
            [out] Boolean* hasExtra);

        /**
         * Returns true if the Intent's extras contain a parcelled file descriptor.
         * @return true if the Intent contains a parcelled file descriptor.
         */
        HasFileDescriptors(
            [out] Boolean* hasFileDescriptors);

        /** @hide */
        SetAllowFds(
            [in] Boolean allowFds);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if none was found.
         *
         * @deprecated
         * @hide
         */
        GetExtra(
            [in] String name,
            [out] IInterface** obj);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, boolean)
         */
        GetBooleanExtra(
            [in] String name,
            [in] Boolean defaultValue,
            [out] Boolean* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, byte)
         */
        GetByteExtra(
            [in] String name,
            [in] Byte defaultValue,
            [out] Byte* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, short)
         */
        GetInt16Extra(
            [in] String name,
            [in] Int16 defaultValue,
            [out] Int16* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, char)
         */
        GetCharExtra(
            [in] String name,
            [in] Char32 defaultValue,
            [out] Char32* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, int)
         */
        GetInt32Extra(
            [in] String name,
            [in] Int32 defaultValue,
            [out] Int32* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, long)
         */
        GetInt64Extra(
            [in] String name,
            [in] Int64 defaultValue,
            [out] Int64* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra(),
         * or the default value if no such item is present
         *
         * @see #putExtra(String, float)
         */
        GetFloatExtra(
            [in] String name,
            [in] Float defaultValue,
            [out] Float* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue the value to be returned if no value of the desired
         * type is stored with the given name.
         *
         * @return the value of an item that previously added with putExtra()
         * or the default value if none was found.
         *
         * @see #putExtra(String, double)
         */
        GetDoubleExtra(
            [in] String name,
            [in] Double defaultValue,
            [out] Double* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no String value was found.
         *
         * @see #putExtra(String, String)
         */
        GetStringExtra(
            [in] String name,
            [out] String* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no CharSequence value was found.
         *
         * @see #putExtra(String, CharSequence)
         */
        GetCharSequenceExtra(
            [in] String name,
            [out] ICharSequence** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Parcelable value was found.
         *
         * @see #putExtra(String, Parcelable)
         */
        GetParcelableExtra(
            [in] String name,
            [out] IParcelable** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Parcelable[] value was found.
         *
         * @see #putExtra(String, Parcelable[])
         */
        GetParcelableArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<IParcelable*>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<Parcelable> value was found.
         *
         * @see #putParcelableArrayListExtra(String, ArrayList)
         */
        GetParcelableArrayListExtra(
            [in] String name,
            [out] IArrayList** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Serializable value was found.
         *
         * @see #putExtra(String, Serializable)
         */
        GetSerializableExtra(
            [in] String name,
            [out] ISerializable** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<Integer> value was found.
         *
         * @see #putIntegerArrayListExtra(String, ArrayList)
         */
        GetInteger32ArrayListExtra(
            [in] String name,
            [out] IArrayList** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *a
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<String> value was found.
         *
         * @see #putStringArrayListExtra(String, ArrayList)
         */
        GetStringArrayListExtra(
            [in] String name,
            [out] IArrayList** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no ArrayList<CharSequence> value was found.
         *
         * @see #putCharSequenceArrayListExtra(String, ArrayList)
         */
        GetCharSequenceArrayListExtra(
            [in] String name,
            [out] IArrayList** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no boolean array value was found.
         *
         * @see #putExtra(String, boolean[])
         */
        GetBooleanArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Boolean>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no byte array value was found.
         *
         * @see #putExtra(String, byte[])
         */
        GetByteArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Byte>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no short array value was found.
         *
         * @see #putExtra(String, short[])
         */
        GetInt16ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int16>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no char array value was found.
         *
         * @see #putExtra(String, char[])
         */
        GetCharArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Char32>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no int array value was found.
         *
         * @see #putExtra(String, int[])
         */
        GetInt32ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int32>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no long array value was found.
         *
         * @see #putExtra(String, long[])
         */
        GetInt64ArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Int64>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no float array value was found.
         *
         * @see #putExtra(String, float[])
         */
        GetFloatArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Float>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no double array value was found.
         *
         * @see #putExtra(String, double[])
         */
        GetDoubleArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<Double>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no String array value was found.
         *
         * @see #putExtra(String, String[])
         */
        GetStringArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<String>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no CharSequence array value was found.
         *
         * @see #putExtra(String, CharSequence[])
         */
        GetCharSequenceArrayExtra(
            [in] String name,
            [out, callee] ArrayOf<ICharSequence*>* value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no Bundle value was found.
         *
         * @see #putExtra(String, Bundle)
         */
        GetBundleExtra(
            [in] String name,
            [out] IBundle** value);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         *
         * @return the value of an item that previously added with putExtra()
         * or null if no IBinder value was found.
         *
         * @see #putExtra(String, IBinder)
         *
         * @deprecated
         * @hide
         */
        // TODO
        // public IBinder getIBinderExtra(String name);

        /**
         * Retrieve extended data from the intent.
         *
         * @param name The name of the desired item.
         * @param defaultValue The default value to return in case no item is
         * associated with the key 'name'
         *
         * @return the value of an item that previously added with putExtra()
         * or defaultValue if none was found.
         *
         * @see #putExtra
         *
         * @deprecated
         * @hide
         */
        GetExtra(
            [in] String name,
            [in] IInterface* defaultValue,
            [out] IInterface** obj);

        /**
         * Retrieves a map of extended data from the intent.
         *
         * @return the map of all extras previously added with putExtra(),
         * or null if none have been added.
         */
        GetExtras(
            [out] IBundle** extras);

        /**
         * Retrieve any special flags associated with this intent.  You will
         * normally just set them with {@link #setFlags} and let the system
         * take the appropriate action with them.
         *
         * @return int The currently set flags.
         *
         * @see #setFlags
         */
        GetFlags(
            [out] Int32* flags);

        /** @hide */
        IsExcludingStopped(
            [out] Boolean* isStopped);

        /**
         * Retrieve the application package name this Intent is limited to.  When
         * resolving an Intent, if non-null this limits the resolution to only
         * components in the given application package.
         *
         * @return The name of the application package for the Intent.
         *
         * @see #resolveActivity
         * @see #setPackage
         */
        GetPackage(
            [out] String* packageName);

        /**
         * Retrieve the concrete component associated with the intent.  When receiving
         * an intent, this is the component that was found to best handle it (that is,
         * yourself) and will always be non-null; in all other cases it will be
         * null unless explicitly set.
         *
         * @return The name of the application component to handle the intent.
         *
         * @see #resolveActivity
         * @see #setComponent
         */
        GetComponent(
            [out] IComponentName** componentName);

        /**
         * Get the bounds of the sender of this intent, in screen coordinates.  This can be
         * used as a hint to the receiver for animations and the like.  Null means that there
         * is no source bounds.
         */
        GetSourceBounds(
            [out] IRect** sourceBounds);

        /**
         * Return the Activity component that should be used to handle this intent.
         * The appropriate component is determined based on the information in the
         * intent, evaluated as follows:
         *
         * <p>If {@link #getComponent} returns an explicit class, that is returned
         * without any further consideration.
         *
         * <p>The activity must handle the {@link Intent#CATEGORY_DEFAULT} Intent
         * category to be considered.
         *
         * <p>If {@link #getAction} is non-NULL, the activity must handle this
         * action.
         *
         * <p>If {@link #resolveType} returns non-NULL, the activity must handle
         * this type.
         *
         * <p>If {@link #addCategory} has added any categories, the activity must
         * handle ALL of the categories specified.
         *
         * <p>If {@link #getPackage} is non-NULL, only activity components in
         * that application package will be considered.
         *
         * <p>If there are no activities that satisfy all of these conditions, a
         * null string is returned.
         *
         * <p>If multiple activities are found to satisfy the intent, the one with
         * the highest priority will be used.  If there are multiple activities
         * with the same priority, the system will either pick the best activity
         * based on user preference, or resolve to a system class that will allow
         * the user to pick an activity and forward from there.
         *
         * <p>This method is implemented simply by calling
         * {@link PackageManager#resolveActivity} with the "defaultOnly" parameter
         * true.</p>
         * <p> This API is called for you as part of starting an activity from an
         * intent.  You do not normally need to call it yourself.</p>
         *
         * @param pm The package manager with which to resolve the Intent.
         *
         * @return Name of the component implementing an activity that can
         *         display the intent.
         *
         * @see #setComponent
         * @see #getComponent
         * @see #resolveActivityInfo
         */
        ResolveActivity(
            [in] IPackageManager* pm,
            [out] IComponentName** componentName);

        /**
         * Resolve the Intent into an {@link ActivityInfo}
         * describing the activity that should execute the intent.  Resolution
         * follows the same rules as described for {@link #resolveActivity}, but
         * you get back the completely information about the resolved activity
         * instead of just its class name.
         *
         * @param pm The package manager with which to resolve the Intent.
         * @param flags Addition information to retrieve as per
         * {@link PackageManager#getActivityInfo(ComponentName, int)
         * PackageManager.getActivityInfo()}.
         *
         * @return PackageManager.ActivityInfo
         *
         * @see #resolveActivity
         */
        ResolveActivityInfo(
            [in] IPackageManager* pm,
            [in] Int32 flags,
            [out] IActivityInfo** result);

        /**
         * Special function for use by the system to resolve service
         * intents to system apps.  Throws an exception if there are
         * multiple potential matches to the Intent.  Returns null if
         * there are no matches.
         * @hide
         */
        ResolveSystemService(
            [in] IPackageManager* pm,
            [in] Int32 flags,
            [out] IComponentName** componentName);

        /**
         * Set the general action to be performed.
         *
         * @param action An action name, such as ACTION_VIEW.  Application-specific
         *               actions should be prefixed with the vendor's package name.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getAction
         */
        SetAction(
            [in] String action);

        /**
         * Set the data this intent is operating on.  This method automatically
         * clears any type that was previously set by {@link #setType} or
         * {@link #setTypeAndNormalize}.
         *
         * <p><em>Note: scheme matching in the Android framework is
         * case-sensitive, unlike the formal RFC. As a result,
         * you should always write your Uri with a lower case scheme,
         * or use {@link Uri#normalizeScheme} or
         * {@link #setDataAndNormalize}
         * to ensure that the scheme is converted to lower case.</em>
         *
         * @param data The Uri of the data this intent is now targeting.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getData
         * @see #setDataAndNormalize
         * @see android.net.Intent#normalize
         */
        SetData(
            [in] IUri* data);

        /**
         * Normalize and set the data this intent is operating on.
         *
         * <p>This method automatically clears any type that was
         * previously set (for example, by {@link #setType}).
         *
         * <p>The data Uri is normalized using
         * {@link android.net.Uri#normalizeScheme} before it is set,
         * so really this is just a convenience method for
         * <pre>
         * setData(data.normalize())
         * </pre>
         *
         * @param data The Uri of the data this intent is now targeting.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getData
         * @see #setType
         * @see android.net.Uri#normalizeScheme
         */
        SetDataAndNormalize(
            [in] IUri* data);

        /**
         * Set an explicit MIME data type.
         *
         * <p>This is used to create intents that only specify a type and not data,
         * for example to indicate the type of data to return.
         *
         * <p>This method automatically clears any data that was
         * previously set (for example by {@link #setData}).
         *
         * <p><em>Note: MIME type matching in the Android framework is
         * case-sensitive, unlike formal RFC MIME types.  As a result,
         * you should always write your MIME types with lower case letters,
         * or use {@link #normalizeMimeType} or {@link #setTypeAndNormalize}
         * to ensure that it is converted to lower case.</em>
         *
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getType
         * @see #setTypeAndNormalize
         * @see #setDataAndType
         * @see #normalizeMimeType
         */
        SetType(
            [in] String type);

        /**
         * Normalize and set an explicit MIME data type.
         *
         * <p>This is used to create intents that only specify a type and not data,
         * for example to indicate the type of data to return.
         *
         * <p>This method automatically clears any data that was
         * previously set (for example by {@link #setData}).
         *
         * <p>The MIME type is normalized using
         * {@link #normalizeMimeType} before it is set,
         * so really this is just a convenience method for
         * <pre>
         * setType(Intent.normalizeMimeType(type))
         * </pre>
         *
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getType
         * @see #setData
         * @see #normalizeMimeType
         */
        SetTypeAndNormalize(
            [in] String type);

        /**
         * (Usually optional) Set the data for the intent along with an explicit
         * MIME data type.  This method should very rarely be used -- it allows you
         * to override the MIME type that would ordinarily be inferred from the
         * data with your own type given here.
         *
         * <p><em>Note: MIME type and Uri scheme matching in the
         * Android framework is case-sensitive, unlike the formal RFC definitions.
         * As a result, you should always write these elements with lower case letters,
         * or use {@link #normalizeMimeType} or {@link android.net.Uri#normalizeScheme} or
         * {@link #setDataAndTypeAndNormalize}
         * to ensure that they are converted to lower case.</em>
         *
         * @param data The Uri of the data this intent is now targeting.
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setType
         * @see #setData
         * @see #normalizeMimeType
         * @see android.net.Uri#normalizeScheme
         * @see #setDataAndTypeAndNormalize
         */
        SetDataAndType(
            [in] IUri* data,
            [in] String type);

        /**
         * (Usually optional) Normalize and set both the data Uri and an explicit
         * MIME data type.  This method should very rarely be used -- it allows you
         * to override the MIME type that would ordinarily be inferred from the
         * data with your own type given here.
         *
         * <p>The data Uri and the MIME type are normalize using
         * {@link android.net.Uri#normalizeScheme} and {@link #normalizeMimeType}
         * before they are set, so really this is just a convenience method for
         * <pre>
         * setDataAndType(data.normalize(), Intent.normalizeMimeType(type))
         * </pre>
         *
         * @param data The Uri of the data this intent is now targeting.
         * @param type The MIME type of the data being handled by this intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setType
         * @see #setData
         * @see #setDataAndType
         * @see #normalizeMimeType
         * @see android.net.Uri#normalizeScheme
         */
        SetDataAndTypeAndNormalize(
            [in] IUri* data,
            [in] String type);

        /**
         * Add a new category to the intent.  Categories provide additional detail
         * about the action the intent performs.  When resolving an intent, only
         * activities that provide <em>all</em> of the requested categories will be
         * used.
         *
         * @param category The desired category.  This can be either one of the
         *               predefined Intent categories, or a custom category in your own
         *               namespace.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #hasCategory
         * @see #removeCategory
         */
        AddCategory(
            [in] String category);

        /**
         * Remove a category from an intent.
         *
         * @param category The category to remove.
         *
         * @see #addCategory
         */
        RemoveCategory(
            [in] String category);

        /**
         * Set a selector for this Intent.  This is a modification to the kinds of
         * things the Intent will match.  If the selector is set, it will be used
         * when trying to find entities that can handle the Intent, instead of the
         * main contents of the Intent.  This allows you build an Intent containing
         * a generic protocol while targeting it more specifically.
         *
         * <p>An example of where this may be used is with things like
         * {@link #CATEGORY_APP_BROWSER}.  This category allows you to build an
         * Intent that will launch the Browser application.  However, the correct
         * main entry point of an application is actually {@link #ACTION_MAIN}
         * {@link #CATEGORY_LAUNCHER} with {@link #setComponent(ComponentName)}
         * used to specify the actual Activity to launch.  If you launch the browser
         * with something different, undesired behavior may happen if the user has
         * previously or later launches it the normal way, since they do not match.
         * Instead, you can build an Intent with the MAIN action (but no ComponentName
         * yet specified) and set a selector with {@link #ACTION_MAIN} and
         * {@link #CATEGORY_APP_BROWSER} to point it specifically to the browser activity.
         *
         * <p>Setting a selector does not impact the behavior of
         * {@link #filterEquals(Intent)} and {@link #filterHashCode()}.  This is part of the
         * desired behavior of a selector -- it does not impact the base meaning
         * of the Intent, just what kinds of things will be matched against it
         * when determining who can handle it.</p>
         *
         * <p>You can not use both a selector and {@link #setPackage(String)} on
         * the same base Intent.</p>
         *
         * @param selector The desired selector Intent; set to null to not use
         * a special selector.
         */
        SetSelector(
            [in] IIntent* selector);

        /**
         * Set a {@link ClipData} associated with this Intent.  This replaces any
         * previously set ClipData.
         *
         * <p>The ClipData in an intent is not used for Intent matching or other
         * such operations.  Semantically it is like extras, used to transmit
         * additional data with the Intent.  The main feature of using this over
         * the extras for data is that {@link #FLAG_GRANT_READ_URI_PERMISSION}
         * and {@link #FLAG_GRANT_WRITE_URI_PERMISSION} will operate on any URI
         * items included in the clip data.  This is useful, in particular, if
         * you want to transmit an Intent containing multiple <code>content:</code>
         * URIs for which the recipient may not have global permission to access the
         * content provider.
         *
         * <p>If the ClipData contains items that are themselves Intents, any
         * grant flags in those Intents will be ignored.  Only the top-level flags
         * of the main Intent are respected, and will be applied to all Uri or
         * Intent items in the clip (or sub-items of the clip).
         *
         * <p>The MIME type, label, and icon in the ClipData object are not
         * directly used by Intent.  Applications should generally rely on the
         * MIME type of the Intent itself, not what it may find in the ClipData.
         * A common practice is to construct a ClipData for use with an Intent
         * with a MIME type of "*\/*".
         *
         * @param clip The new clip to set.  May be null to clear the current clip.
         */
        SetClipData(
            [in] IClipData* clip);

        /**
         * This is NOT a secure mechanism to identify the user who sent the intent.
         * When the intent is sent to a different user, it is used to fix uris by adding the userId
         * who sent the intent.
         * @hide
         */
        SetContentUserHint(
            [in] Int32 contentUserHint);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The boolean data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBooleanExtra(String, boolean)
         */
        PutBooleanExtra(
            [in] String name,
            [in] Boolean value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getByteExtra(String, byte)
         */
        PutByteExtra(
            [in] String name,
            [in] Byte value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The char data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharExtra(String, char)
         */
        PutCharExtra(
            [in] String name,
            [in] Char32 value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The short data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getShortExtra(String, short)
         */
        PutExtra(
            [in] String name,
            [in] Int16 value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The integer data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntExtra(String, int)
         */
        PutExtra(
            [in] String name,
            [in] Int32 value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The long data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getLongExtra(String, long)
         */
        PutExtra(
            [in] String name,
            [in] Int64 value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The float data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getFloatExtra(String, float)
         */
        PutExtra(
            [in] String name,
            [in] Float value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The double data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getDoubleExtra(String, double)
         */
        PutExtra(
            [in] String name,
            [in] Double value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The String data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] String value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The CharSequence data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ICharSequence* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Parcelable data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] IParcelable* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Parcelable[] data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<IParcelable*>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<Parcelable> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getParcelableArrayListExtra(String)
         */
        PutParcelableArrayListExtra(
            [in] String name,
            [in] IArrayList* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<Integer> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntegerArrayListExtra(String)
         */
        PutInteger32ArrayListExtra(
            [in] String name,
            [in] IArrayList* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<String> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringArrayListExtra(String)
         */
        PutStringArrayListExtra(
            [in] String name,
            [in] IArrayList* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The ArrayList<CharSequence> data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceArrayListExtra(String)
         */
        PutCharSequenceArrayListExtra(
            [in] String name,
            [in] IArrayList* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Serializable data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getSerializableExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ISerializable* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The boolean array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBooleanArrayExtra(String)
         */
        PutBooleanArrayExtra(
            [in] String name,
            [in] ArrayOf<Boolean>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getByteArrayExtra(String)
         */
        PutByteArrayExtra(
            [in] String name,
            [in] ArrayOf<Byte>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The short array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getShortArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<Int16>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The char array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharArrayExtra(String)
         */
        PutCharArrayExtra(
            [in] String name,
            [in] ArrayOf<Char32>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The int array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIntArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<Int32>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The byte array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getLongArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<Int64>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The float array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getFloatArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<Float>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The double array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getDoubleArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<Double>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The String array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getStringArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<String>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The CharSequence array data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getCharSequenceArrayExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] ArrayOf<ICharSequence*>* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The Bundle data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getBundleExtra(String)
         */
        PutExtra(
            [in] String name,
            [in] IBundle* value);

        /**
         * Add extended data to the intent.  The name must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param name The name of the extra data, with package prefix.
         * @param value The IBinder data value.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #putExtras
         * @see #removeExtra
         * @see #getIBinderExtra(String)
         *
         * @deprecated
         * @hide
         */
        // @Deprecated
        // TODO
        // public Intent putExtra(String name, IBinder value);

        /**
         * Copy all extras in 'src' in to this intent.
         *
         * @param src Contains the extras to copy.
         *
         * @see #putExtra
         */
        PutExtras(
            [in] IIntent* src);

        /**
         * Add a set of extended data to the intent.  The keys must include a package
         * prefix, for example the app com.android.contacts would use names
         * like "com.android.contacts.ShowAll".
         *
         * @param extras The Bundle of extras to add to this intent.
         *
         * @see #putExtra
         * @see #removeExtra
         */
        PutExtras(
            [in] IBundle* extras);

        /**
         * Completely replace the extras in the Intent with the extras in the
         * given Intent.
         *
         * @param src The exact extras contained in this Intent are copied
         * into the target intent, replacing any that were previously there.
         */
        ReplaceExtras(
            [in] IIntent* src);

        /**
         * Completely replace the extras in the Intent with the given Bundle of
         * extras.
         *
         * @param extras The new set of extras in the Intent, or null to erase
         * all extras.
         */
        ReplaceExtras(
            [in] IBundle* extras);

        /**
         * Remove extended data from the intent.
         *
         * @see #putExtra
         */
        RemoveExtra(
            [in] String name);

        /**
         * Set special flags controlling how this intent is handled.  Most values
         * here depend on the type of component being executed by the Intent,
         * specifically the FLAG_ACTIVITY_* flags are all for use with
         * {@link Context#startActivity Context.startActivity()} and the
         * FLAG_RECEIVER_* flags are all for use with
         * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
         *
         * <p>See the
         * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
         * Stack</a> documentation for important information on how some of these options impact
         * the behavior of your application.
         *
         * @param flags The desired flags.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getFlags
         * @see #addFlags
         *
         * @see #FLAG_GRANT_READ_URI_PERMISSION
         * @see #FLAG_GRANT_WRITE_URI_PERMISSION
         * @see #FLAG_DEBUG_LOG_RESOLUTION
         * @see #FLAG_FROM_BACKGROUND
         * @see #FLAG_ACTIVITY_BROUGHT_TO_FRONT
         * @see #FLAG_ACTIVITY_CLEAR_TASK
         * @see #FLAG_ACTIVITY_CLEAR_TOP
         * @see #FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
         * @see #FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
         * @see #FLAG_ACTIVITY_FORWARD_RESULT
         * @see #FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
         * @see #FLAG_ACTIVITY_MULTIPLE_TASK
         * @see #FLAG_ACTIVITY_NEW_TASK
         * @see #FLAG_ACTIVITY_NO_ANIMATION
         * @see #FLAG_ACTIVITY_NO_HISTORY
         * @see #FLAG_ACTIVITY_NO_USER_ACTION
         * @see #FLAG_ACTIVITY_PREVIOUS_IS_TOP
         * @see #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
         * @see #FLAG_ACTIVITY_REORDER_TO_FRONT
         * @see #FLAG_ACTIVITY_SINGLE_TOP
         * @see #FLAG_ACTIVITY_TASK_ON_HOME
         * @see #FLAG_RECEIVER_REGISTERED_ONLY
         */
        SetFlags(
            [in] Int32 flags);

        /**
         * Add additional flags to the intent (or with existing flags
         * value).
         *
         * @param flags The new flags to set.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setFlags
         */
        AddFlags(
            [in] Int32 flags);

        /**
         * (Usually optional) Set an explicit application package name that limits
         * the components this Intent will resolve to.  If left to the default
         * value of null, all components in all applications will considered.
         * If non-null, the Intent can only match the components in the given
         * application package.
         *
         * @param packageName The name of the application package to handle the
         * intent, or null to allow any application package.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #getPackage
         * @see #resolveActivity
         */
        SetPackage(
            [in] String packageName);

        /**
         * (Usually optional) Explicitly set the component to handle the intent.
         * If left with the default value of null, the system will determine the
         * appropriate class to use based on the other fields (action, data,
         * type, categories) in the Intent.  If this class is defined, the
         * specified class will always be used regardless of the other fields.  You
         * should only set this value when you know you absolutely want a specific
         * class to be used; otherwise it is better to let the system find the
         * appropriate class so that you will respect the installed applications
         * and user preferences.
         *
         * @param component The name of the application component to handle the
         * intent, or null to let the system find one for you.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setClass
         * @see #setClassName(Context, String)
         * @see #setClassName(String, String)
         * @see #getComponent
         * @see #resolveActivity
         */
        SetComponent(
            [in] IComponentName* component);

        /**
         * Convenience for calling {@link #setComponent} with an
         * explicit class name.
         *
         * @param packageContext A Context of the application package implementing
         * this class.
         * @param className The name of a class inside of the application package
         * that will be used as the component for this Intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         * @see #setClass
         */
        SetClassName(
            [in] IContext* packageContext,
            [in] String className);

        /**
         * Convenience for calling {@link #setComponent} with an
         * explicit application package name and class name.
         *
         * @param packageName The name of the package implementing the desired
         * component.
         * @param className The name of a class inside of the application package
         * that will be used as the component for this Intent.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         * @see #setClass
         */
        SetClassName(
            [in] String packageName,
            [in] String className);

        /**
         * Convenience for calling {@link #setComponent(ComponentName)} with the
         * name returned by a {@link Class} object.
         *
         * @param packageContext A Context of the application package implementing
         * this class.
         * @param cls The class name to set, equivalent to
         *            <code>setClassName(context, cls.getName())</code>.
         *
         * @return Returns the same Intent object, for chaining multiple calls
         * into a single statement.
         *
         * @see #setComponent
         */

        SetClass(
            [in] IContext* packageContext,
            [in] ClassID clsId);

        /**
         * Set the bounds of the sender of this intent, in screen coordinates.  This can be
         * used as a hint to the receiver for animations and the like.  Null means that there
         * is no source bounds.
         */
        SetSourceBounds(
            [in] IRect* r);

        /**
         * Copy the contents of <var>other</var> in to this object, but only
         * where fields are not defined by this object.  For purposes of a field
         * being defined, the following pieces of data in the Intent are
         * considered to be separate fields:
         *
         * <ul>
         * <li> action, as set by {@link #setAction}.
         * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
         * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
         * <li> categories, as set by {@link #addCategory}.
         * <li> package, as set by {@link #setPackage}.
         * <li> component, as set by {@link #setComponent(ComponentName)} or
         * related methods.
         * <li> source bounds, as set by {@link #setSourceBounds}.
         * <li> selector, as set by {@link #setSelector(Intent)}.
         * <li> clip data, as set by {@link #setClipData(ClipData)}.
         * <li> each top-level name in the associated extras.
         * </ul>
         *
         * <p>In addition, you can use the {@link #FILL_IN_ACTION},
         * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
         * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
         * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
         * the restriction where the corresponding field will not be replaced if
         * it is already set.
         *
         * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
         * is explicitly specified.  The selector will only be copied if
         * {@link #FILL_IN_SELECTOR} is explicitly specified.
         *
         * <p>For example, consider Intent A with {data="foo", categories="bar"}
         * and Intent B with {action="gotit", data-type="some/thing",
         * categories="one","two"}.
         *
         * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
         * containing: {action="gotit", data-type="some/thing",
         * categories="bar"}.
         *
         * @param other Another Intent whose values are to be used to fill in
         * the current one.
         * @param flags Options to control which fields can be filled in.
         *
         * @return Returns a bit mask of {@link #FILL_IN_ACTION},
         * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
         * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
         * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
         */
        FillIn(
            [in] IIntent* other,
            [in] Int32 flags,
            [out] Int32* result);

        /**
         * Determine if two intents are the same for the purposes of intent
         * resolution (filtering). That is, if their action, data, type,
         * class, and categories are the same.  This does <em>not</em> compare
         * any extra data included in the intents.
         *
         * @param other The other Intent to compare against.
         *
         * @return Returns true if action, data, type, class, and categories
         *         are the same.
         */
        FilterEquals(
            [in] IIntent* other,
            [out] Boolean* isEqual);

        /**
         * Generate hash code that matches semantics of filterEquals().
         *
         * @return Returns the hash value of the action, data, type, class, and
         *         categories.
         *
         * @see #filterEquals
         */
        FilterHashCode(
            [out] Int32* result);

        ToString(
            [out] String* str);

        /** @hide */
        ToInsecureString(
            [out] String* str);

        /** @hide */
        ToInsecureStringWithClip(
            [out] String* str);

        /** @hide */
        ToShortString(
            [in] Boolean secure,
            [in] Boolean comp,
            [in] Boolean extras,
            [in] Boolean clip,
            [out] String* str);

        /** @hide */
        ToShortString(
            [in] IStringBuilder* b,
            [in] Boolean secure,
            [in] Boolean comp,
            [in] Boolean extras,
            [in] Boolean clip);

        /**
         * Call {@link #toUri} with 0 flags.
         * @deprecated Use {@link #toUri} instead.
         */
        ToURI(
            [out] String* str);

        /**
         * Convert this Intent into a String holding a URI representation of it.
         * The returned URI string has been properly URI encoded, so it can be
         * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
         * Intent's data as the base URI, with an additional fragment describing
         * the action, categories, type, flags, package, component, and extras.
         *
         * <p>You can convert the returned string back to an Intent with
         * {@link #getIntent}.
         *
         * @param flags Additional operating flags.  Either 0 or
         * {@link #URI_INTENT_SCHEME}.
         *
         * @return Returns a URI encoding URI string describing the entire contents
         * of the Intent.
         */
        ToUri(
            [in] Int32 flags,
            [out] String* str);

        /**
         * @hide
         */
        SaveToXml(
            [in] IXmlSerializer* outXml);

        /**
         * Prepare this {@link Intent} to leave an app process.
         *
         * @hide
         */
        PrepareToLeaveProcess();

        /**
         * @hide
         */
        PrepareToEnterProcess();

        /**
         * @hide
         */
        FixUris(
            [in] Int32 contentUserHint);

        /**
         * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
         * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
         * intents in {@link #ACTION_CHOOSER}.
         *
         * @return Whether any contents were migrated.
         * @hide
         */
        MigrateExtraStreamToClipData(
            [out] Boolean* result);
    }

    [local]
    interface IIntentHelper {
        /**
         * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
         *
         * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
         * target intent, also optionally supplying a title.  If the target
         * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
         * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
         * set in the returned chooser intent, with its ClipData set appropriately:
         * either a direct reflection of {@link #getClipData()} if that is non-null,
         * or a new ClipData build from {@link #getData()}.
         *
         * @param target The Intent that the user will be selecting an activity
         * to perform.
         * @param title Optional title that will be displayed in the chooser.
         * @return Return a new Intent object that you can hand to
         * {@link Context#startActivity(Intent) Context.startActivity()} and
         * related methods.
         */
        CreateChooser(
            [in] IIntent* target,
            [in] ICharSequence* title,
            [out] IIntent** intent);

        /**
         * Create an intent to launch the main (root) activity of a task.  This
         * is the Intent that is started when the application's is launched from
         * Home.  For anything else that wants to launch an application in the
         * same way, it is important that they use an Intent structured the same
         * way, and can use this function to ensure this is the case.
         *
         * <p>The returned Intent has the given Activity component as its explicit
         * component, {@link #ACTION_MAIN} as its action, and includes the
         * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
         * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
         * to do that through {@link #addFlags(int)} on the returned Intent.
         *
         * @param mainActivity The main activity component that this Intent will
         * launch.
         * @return Returns a newly created Intent that can be used to launch the
         * activity as a main application entry.
         *
         * @see #setClass
         * @see #setComponent
         */
        MakeMainActivity(
            [in] IComponentName* mainActivity,
            [out] IIntent** intent);

        /**
         * Make an Intent for the main activity of an application, without
         * specifying a specific activity to run but giving a selector to find
         * the activity.  This results in a final Intent that is structured
         * the same as when the application is launched from
         * Home.  For anything else that wants to launch an application in the
         * same way, it is important that they use an Intent structured the same
         * way, and can use this function to ensure this is the case.
         *
         * <p>The returned Intent has {@link #ACTION_MAIN} as its action, and includes the
         * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
         * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
         * to do that through {@link #addFlags(int)} on the returned Intent.
         *
         * @param selectorAction The action name of the Intent's selector.
         * @param selectorCategory The name of a category to add to the Intent's
         * selector.
         * @return Returns a newly created Intent that can be used to launch the
         * activity as a main application entry.
         *
         * @see #setSelector(Intent)
         */
        MakeMainSelectorActivity(
            [in] String selectorAction,
            [in] String selectorCategory,
            [out] IIntent** intent);

        /**
         * Make an Intent that can be used to re-launch an application's task
         * in its base state.  This is like {@link #makeMainActivity(ComponentName)},
         * but also sets the flags {@link #FLAG_ACTIVITY_NEW_TASK} and
         * {@link #FLAG_ACTIVITY_CLEAR_TASK}.
         *
         * @param mainActivity The activity component that is the root of the
         * task; this is the activity that has been published in the application's
         * manifest as the main launcher icon.
         *
         * @return Returns a newly created Intent that can be used to relaunch the
         * activity's task in its root state.
         */
        MakeRestartActivityTask(
            [in] IComponentName* mainActivity,
            [out] IIntent** intent);

        /**
         * Call {@link #parseUri} with 0 flags.
         * @deprecated Use {@link #parseUri} instead.
         */
        GetIntent(
            [in] String uri,
            [out] IIntent** intent);

        /**
         * Create an intent from a URI.  This URI may encode the action,
         * category, and other intent fields, if it was returned by
         * {@link #toUri}.  If the Intent was not generate by toUri(), its data
         * will be the entire URI and its action will be ACTION_VIEW.
         *
         * <p>The URI given here must not be relative -- that is, it must include
         * the scheme and full path.
         *
         * @param uri The URI to turn into an Intent.
         * @param flags Additional processing flags.  Either 0 or
         * {@link #URI_INTENT_SCHEME}.
         *
         * @return Intent The newly created Intent object.
         *
         * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
         * it bad (as parsed by the Uri class) or the Intent data within the
         * URI is invalid.
         *
         * @see #toUri
         */
        ParseUri(
            [in] String uri,
            [in] Int32 flags,
            [out] IIntent** intent);

        GetIntentOld(
            [in] String uri,
            [out] IIntent** intent);

        /**
         * Parses the "intent" element (and its children) from XML and instantiates
         * an Intent object.  The given XML parser should be located at the tag
         * where parsing should start (often named "intent"), from which the
         * basic action, data, type, and package and class name will be
         * retrieved.  The function will then parse in to any child elements,
         * looking for <category android:name="xxx"> tags to add categories and
         * <extra android:name="xxx" android:value="yyy"> to attach extra data
         * to the intent.
         *
         * @param resources The Resources to use when inflating resources.
         * @param parser The XML parser pointing at an "intent" tag.
         * @param attrs The AttributeSet interface for retrieving extended
         * attribute data at the current <var>parser</var> location.
         * @return An Intent object matching the XML data.
         * @throws XmlPullParserException If there was an XML parsing error.
         * @throws IOException If there was an I/O error.
         */
        ParseIntent(
            [in] IResources* resources,
            [in] IXmlPullParser* parser,
            [in] IAttributeSet* attrs,
            [out] IIntent** intent);

        /** @hide */
        RestoreFromXml(
            [in] IXmlPullParser* parser,
            [out] IIntent** intent);

        /**
         * Normalize a MIME data type.
         *
         * <p>A normalized MIME type has white-space trimmed,
         * content-type parameters removed, and is lower-case.
         * This aligns the type with Android best practices for
         * intent filtering.
         *
         * <p>For example, "text/plain; charset=utf-8" becomes "text/plain".
         * "text/x-vCard" becomes "text/x-vcard".
         *
         * <p>All MIME types received from outside Android (such as user input,
         * or external sources like Bluetooth, NFC, or the Internet) should
         * be normalized before they are used to create an Intent.
         *
         * @param type MIME data type to normalize
         * @return normalized MIME data type, or null if the input was null
         * @see {@link #setType}
         * @see {@link #setTypeAndNormalize}
         */
        NormalizeMimeType(
            [in] String type,
            [out] String* mimeType);
    }

    /**
     * @Involve
     * interface IParcelable;
     * interface ICloneable;
     */
    interface IIntentShortcutIconResource {
        /**
         * The package name of the application containing the icon.
         */
        GetPackageName(
            [out] String* packageName);

        SetPackageName(
            [in] String packageName);

        /**
         * The resource name of the icon, including package, name and type.
         */
        GetResourceName(
            [out] String* resourceName);

        SetResourceName(
            [in] String resourceName);
    }

    [local]
    interface IIntentShortcutIconResourceHelper {
        /**
         * Creates a new ShortcutIconResource for the specified context and resource
         * identifier.
         *
         * @param context The context of the application.
         * @param resourceId The resource idenfitier for the icon.
         * @return A new ShortcutIconResource with the specified's context package name
         *         and icon resource idenfitier.
         */
        FromContext(
            [in] IContext* ctx,
            [in] Int32 resourceId,
            [out] IIntentShortcutIconResource** shortcutIconRes);
    }

    [local]
    interface IIntentFilterComparison {
        /**
         * Return the Intent that this FilterComparison represents.
         * @return Returns the Intent held by the FilterComparison.  Do
         * not modify!
         */
        GetIntent(
            [out] IIntent** intent);

        Equals(
            [in] IInterface* obj,
            [out] Boolean* isEqual);

        GetHashCode(
            [out] Int32* hashCode);
    }

    } // namespace Content
    } // namespace Droid
    } // namespace Elastos
}
