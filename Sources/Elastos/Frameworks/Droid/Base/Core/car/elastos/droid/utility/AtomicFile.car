module
{
    using interface Elastos.IO.IFile;
    using interface Elastos.IO.IFileOutputStream;
    using interface Elastos.IO.IFileInputStream;

    namespace Elastos {
    namespace Droid {
    namespace Utility {

    interface IAtomicFile
    {
        /**
         * Return the path to the base file.  You should not generally use this,
         * as the data at that path may not be valid.
         */
        GetBaseFile(
            [out] IFile** file);

        /**
         * Delete the atomic file.  This deletes both the base and backup files.
         */
        Delete();

        /**
         * Start a new write operation on the file.  This returns a FileOutputStream
         * to which you can write the new file data.  The existing file is replaced
         * with the new data.  You <em>must not</em> directly close the given
         * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
         * or {@link #failWrite(FileOutputStream)}.
         *
         * <p>Note that if another thread is currently performing
         * a write, this will simply replace whatever that thread is writing
         * with the new file being written by this thread, and when the other
         * thread finishes the write the new write operation will no longer be
         * safe (or will be lost).  You must do your own threading protection for
         * access to AtomicFile.
         */
        StartWrite(
            [out] IFileOutputStream** stream);

        /**
         * Call when you have successfully finished writing to the stream
         * returned by {@link #startWrite()}.  This will close, sync, and
         * commit the new data.  The next attempt to read the atomic file
         * will return the new file stream.
         */
        FinishWrite(
            [in] IFileOutputStream* str);

        /**
         * Call when you have failed for some reason at writing to the stream
         * returned by {@link #startWrite()}.  This will close the current
         * write stream, and roll back to the previous state of the file.
         */
        FailWrite(
            [in] IFileOutputStream* str);

        /** @hide
         * @deprecated This is not safe.
         */
        Truncate();

        /** @hide
         * @deprecated This is not safe.
         */
        OpenAppend(
            [out] IFileOutputStream** stream);

        /**
         * Open the atomic file for reading.  If there previously was an
         * incomplete write, this will roll back to the last good data before
         * opening for read.  You should call close() on the FileInputStream when
         * you are done reading from it.
         *
         * <p>Note that if another thread is currently performing
         * a write, this will incorrectly consider it to be in the state of a bad
         * write and roll back, causing the new data currently being written to
         * be dropped.  You must do your own threading protection for access to
         * AtomicFile.
         */
        OpenRead(
            [out] IFileInputStream** stream);

        GetLastModifiedTime(
            [out] Int64* time);

        /**
         * A convenience for {@link #openRead()} that also reads all of the
         * file contents into a byte array which is returned.
         */
        ReadFully(
            [out, callee] ArrayOf<Byte>* data);

        Exists(
            [out] Boolean* result);
    }

    } // namespace Utility
    } // namespace Droid
    } // namespace Elastos
}
