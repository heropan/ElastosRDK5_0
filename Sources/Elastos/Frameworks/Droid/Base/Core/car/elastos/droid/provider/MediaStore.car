module {
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.IContentResolver;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Database.ICursor;
    interface Elastos.Droid.Graphics.IBitmap;
    interface Elastos.Droid.Graphics.IBitmapFactoryOptions;

    namespace Elastos {
    namespace Droid {
    namespace Provider {

    [local]
    interface IMediaStore {
        const String AUTHORITY = "media";

        const String CONTENT_AUTHORITY_SLASH = "content://media/";      // "content://" + AUTHORITY + "/";

       /**
         * Broadcast Action:  A broadcast to indicate the end of an MTP session with the host.
         * This broadcast is only sent if MTP activity has modified the media database during the
         * most recent MTP session.
         *
         * @hide
         */
        const String ACTION_MTP_SESSION_END = "android.provider.action.MTP_SESSION_END";

        /**
         * The method name used by the media scanner and mtp to tell the media provider to
         * rescan and reclassify that have become unhidden because of renaming folders or
         * removing nomedia files
         * @hide
         */
        const String UNHIDE_CALL = "unhide";

        /**
         * This is for internal use by the media scanner only.
         * Name of the (optional) Uri parameter that determines whether to skip deleting
         * the file pointed to by the _data column, when deleting the database entry.
         * The only appropriate value for this parameter is "false", in which case the
         * delete will be skipped. Note especially that setting this to true, or omitting
         * the parameter altogether, will perform the default action, which is different
         * for different types of media.
         * @hide
         */
        const String PARAM_DELETE_DATA = "deletedata";

        /**
         * Activity Action: Launch a music player.
         * The activity should be able to play, browse, or manipulate music files stored on the device.
         *
         * @deprecated Use {@link android.content.Intent#CATEGORY_APP_MUSIC} instead.
         */
        //@Deprecated
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_MUSIC_PLAYER = "android.intent.action.MUSIC_PLAYER";

        /**
         * Activity Action: Perform a search for media.
         * Contains at least the {@link android.app.SearchManager#QUERY} extra.
         * May also contain any combination of the following extras:
         * EXTRA_MEDIA_ARTIST, EXTRA_MEDIA_ALBUM, EXTRA_MEDIA_TITLE, EXTRA_MEDIA_FOCUS
         *
         * @see android.provider.MediaStore#EXTRA_MEDIA_ARTIST
         * @see android.provider.MediaStore#EXTRA_MEDIA_ALBUM
         * @see android.provider.MediaStore#EXTRA_MEDIA_TITLE
         * @see android.provider.MediaStore#EXTRA_MEDIA_FOCUS
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_MEDIA_SEARCH = "android.intent.action.MEDIA_SEARCH";

        /**
         * An intent to perform a search for music media and automatically play content from the
         * result when possible. This can be fired, for example, by the result of a voice recognition
         * command to listen to music.
         * <p>This intent always includes the {@link android.provider.MediaStore#EXTRA_MEDIA_FOCUS}
         * and {@link android.app.SearchManager#QUERY} extras. The
         * {@link android.provider.MediaStore#EXTRA_MEDIA_FOCUS} extra determines the search mode, and
         * the value of the {@link android.app.SearchManager#QUERY} extra depends on the search mode.
         * For more information about the search modes for this intent, see
         * <a href="{@docRoot}guide/components/intents-common.html#PlaySearch">Play music based
         * on a search query</a> in <a href="{@docRoot}guide/components/intents-common.html">Common
         * Intents</a>.</p>
         *
         * <p>This intent makes the most sense for apps that can support large-scale search of music,
         * such as services connected to an online database of music which can be streamed and played
         * on the device.</p>
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH =
                "android.media.action.MEDIA_PLAY_FROM_SEARCH";

        /**
         * An intent to perform a search for readable media and automatically play content from the
         * result when possible. This can be fired, for example, by the result of a voice recognition
         * command to read a book or magazine.
         * <p>
         * Contains the {@link android.app.SearchManager#QUERY} extra, which is a string that can
         * contain any type of unstructured text search, like the name of a book or magazine, an author
         * a genre, a publisher, or any combination of these.
         * <p>
         * Because this intent includes an open-ended unstructured search string, it makes the most
         * sense for apps that can support large-scale search of text media, such as services connected
         * to an online database of books and/or magazines which can be read on the device.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_TEXT_OPEN_FROM_SEARCH =
                "android.media.action.TEXT_OPEN_FROM_SEARCH";

        /**
         * An intent to perform a search for video media and automatically play content from the
         * result when possible. This can be fired, for example, by the result of a voice recognition
         * command to play movies.
         * <p>
         * Contains the {@link android.app.SearchManager#QUERY} extra, which is a string that can
         * contain any type of unstructured video search, like the name of a movie, one or more actors,
         * a genre, or any combination of these.
         * <p>
         * Because this intent includes an open-ended unstructured search string, it makes the most
         * sense for apps that can support large-scale search of video, such as services connected to an
         * online database of videos which can be streamed and played on the device.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH =
                "android.media.action.VIDEO_PLAY_FROM_SEARCH";

        /**
         * The name of the Intent-extra used to define the artist
         */
        const String EXTRA_MEDIA_ARTIST = "android.intent.extra.artist";
        /**
         * The name of the Intent-extra used to define the album
         */
        const String EXTRA_MEDIA_ALBUM = "android.intent.extra.album";
        /**
         * The name of the Intent-extra used to define the song title
         */
        const String EXTRA_MEDIA_TITLE = "android.intent.extra.title";
        /**
         * The name of the Intent-extra used to define the genre.
         */
        const String EXTRA_MEDIA_GENRE = "android.intent.extra.genre";
        /**
         * The name of the Intent-extra used to define the playlist.
         */
        const String EXTRA_MEDIA_PLAYLIST = "android.intent.extra.playlist";
        /**
         * The name of the Intent-extra used to define the radio channel.
         */
        const String EXTRA_MEDIA_RADIO_CHANNEL = "android.intent.extra.radio_channel";
        /**
         * The name of the Intent-extra used to define the search focus. The search focus
         * indicates whether the search should be for things related to the artist, album
         * or song that is identified by the other extras.
         */
        const String EXTRA_MEDIA_FOCUS = "android.intent.extra.focus";

        /**
         * The name of the Intent-extra used to control the orientation of a ViewImage or a MovieView.
         * This is an int property that overrides the activity's requestedOrientation.
         * @see android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
         */
        const String EXTRA_SCREEN_ORIENTATION = "android.intent.extra.screenOrientation";

        /**
         * The name of an Intent-extra used to control the UI of a ViewImage.
         * This is a boolean property that overrides the activity's default fullscreen state.
         */
        const String EXTRA_FULL_SCREEN = "android.intent.extra.fullScreen";

        /**
         * The name of an Intent-extra used to control the UI of a ViewImage.
         * This is a boolean property that specifies whether or not to show action icons.
         */
        const String EXTRA_SHOW_ACTION_ICONS = "android.intent.extra.showActionIcons";

        /**
         * The name of the Intent-extra used to control the onCompletion behavior of a MovieView.
         * This is a boolean property that specifies whether or not to finish the MovieView activity
         * when the movie completes playing. The default value is true, which means to automatically
         * exit the movie player activity when the movie completes playing.
         */
        const String EXTRA_FINISH_ON_COMPLETION = "android.intent.extra.finishOnCompletion";

        /**
         * The name of the Intent action used to launch a camera in still image mode.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_STILL_IMAGE_CAMERA = "android.media.action.STILL_IMAGE_CAMERA";

        /**
         * The name of the Intent action used to launch a camera in still image mode
         * for use when the device is secured (e.g. with a pin, password, pattern,
         * or face unlock). Applications responding to this intent must not expose
         * any personal content like existing photos or videos on the device. The
         * applications should be careful not to share any photo or video with other
         * applications or internet. The activity should use {@link
         * android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED} to display
         * on top of the lock screen while secured. There is no activity stack when
         * this flag is used, so launching more than one activity is strongly
         * discouraged.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE =
                "android.media.action.STILL_IMAGE_CAMERA_SECURE";

        /**
         * The name of the Intent action used to launch a camera in video mode.
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String INTENT_ACTION_VIDEO_CAMERA = "android.media.action.VIDEO_CAMERA";

        /**
         * Standard Intent action that can be sent to have the camera application
         * capture an image and return it.
         * <p>
         * The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.
         * If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap
         * object in the extra field. This is useful for applications that only need a small image.
         * If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri
         * value of EXTRA_OUTPUT.
         * As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be supplied through
         * {@link android.content.Intent#setClipData(ClipData)}. If using this approach, you still must
         * supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
         * If you don't set a ClipData, it will be copied there for you when calling
         * {@link Context#startActivity(Intent)}.
         * @see #EXTRA_OUTPUT
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_IMAGE_CAPTURE = "android.media.action.IMAGE_CAPTURE";

        /**
         * Intent action that can be sent to have the camera application capture an image and return
         * it when the device is secured (e.g. with a pin, password, pattern, or face unlock).
         * Applications responding to this intent must not expose any personal content like existing
         * photos or videos on the device. The applications should be careful not to share any photo
         * or video with other applications or internet. The activity should use {@link
         * android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED} to display on top of the
         * lock screen while secured. There is no activity stack when this flag is used, so
         * launching more than one activity is strongly discouraged.
         * <p>
         * The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.
         * If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap
         * object in the extra field. This is useful for applications that only need a small image.
         * If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri
         * value of EXTRA_OUTPUT.
         * As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be supplied through
         * {@link android.content.Intent#setClipData(ClipData)}. If using this approach, you still must
         * supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
         * If you don't set a ClipData, it will be copied there for you when calling
         * {@link Context#startActivity(Intent)}.
         *
         * @see #ACTION_IMAGE_CAPTURE
         * @see #EXTRA_OUTPUT
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_IMAGE_CAPTURE_SECURE =
                "android.media.action.IMAGE_CAPTURE_SECURE";

        /**
         * Standard Intent action that can be sent to have the camera application
         * capture a video and return it.
         * <p>
         * The caller may pass in an extra EXTRA_VIDEO_QUALITY to control the video quality.
         * <p>
         * The caller may pass in an extra EXTRA_OUTPUT to control
         * where the video is written. If EXTRA_OUTPUT is not present the video will be
         * written to the standard location for videos, and the Uri of that location will be
         * returned in the data field of the Uri.
         * As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be supplied through
         * {@link android.content.Intent#setClipData(ClipData)}. If using this approach, you still must
         * supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
         * If you don't set a ClipData, it will be copied there for you when calling
         * {@link Context#startActivity(Intent)}.
         * @see #EXTRA_OUTPUT
         * @see #EXTRA_VIDEO_QUALITY
         * @see #EXTRA_SIZE_LIMIT
         * @see #EXTRA_DURATION_LIMIT
         */
        //@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
        const String ACTION_VIDEO_CAPTURE = "android.media.action.VIDEO_CAPTURE";

        /**
         * The name of the Intent-extra used to control the quality of a recorded video. This is an
         * integer property. Currently value 0 means low quality, suitable for MMS messages, and
         * value 1 means high quality. In the future other quality levels may be added.
         */
        const String EXTRA_VIDEO_QUALITY = "android.intent.extra.videoQuality";

        /**
         * Specify the maximum allowed size.
         */
        const String EXTRA_SIZE_LIMIT = "android.intent.extra.sizeLimit";

        /**
         * Specify the maximum allowed recording duration in seconds.
         */
        const String EXTRA_DURATION_LIMIT = "android.intent.extra.durationLimit";

        /**
         * The name of the Intent-extra used to indicate a content resolver Uri to be used to
         * store the requested image or video.
         */
        const String EXTRA_OUTPUT = "output";

        /**
          * The string that is used when a media attribute is not known. For example,
          * if an audio file does not have any meta data, the artist and album columns
          * will be set to this value.
          */
        const String UNKNOWN_STRING = "<unknown>";

        /**
         * Name of current volume being scanned by the media scanner.
         */
        const String MEDIA_SCANNER_VOLUME = "volume";

        /**
         * Name of the file signaling the media scanner to ignore media in the containing directory
         * and its subdirectories. Developers should use this to avoid application graphics showing
         * up in the Gallery and likewise prevent application sounds and music from showing up in
         * the Music app.
         */
        const String MEDIA_IGNORE_FILENAME = ".nomedia";

        /**
         * Uri for querying the state of the media scanner.
         */
        GetMediaScannerUri(
            [out] IUri** uri);

        /**
         * Get the media provider's version.
         * Applications that import data from the media provider into their own caches
         * can use this to detect that the media provider changed, and reimport data
         * as needed. No other assumptions should be made about the meaning of the version.
         * @param context Context to use for performing the query.
         * @return A version string, or null if the version could not be determined.
         */
        GetVersion(
            [in] IContext* ctx,
            [out] String* ver);
    }

    /**
     * @Involve
     * interface IBaseColumns
     */
    interface IMediaStoreMediaColumns {
        /**
         * The data stream for the file
         * <P>Type: DATA STREAM</P>
         */
        const String DATA = "_data";

        /**
         * The size of the file in bytes
         * <P>Type: INTEGER (long)</P>
         */
        const String SIZE = "_size";

        /**
         * The display name of the file
         * <P>Type: TEXT</P>
         */
        const String DISPLAY_NAME = "_display_name";

        /**
         * The title of the content
         * <P>Type: TEXT</P>
         */
        const String TITLE = "title";

        /**
         * The time the file was added to the media provider
         * Units are seconds since 1970.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_ADDED = "date_added";

        /**
         * The time the file was last modified
         * Units are seconds since 1970.
         * NOTE: This is for internal use by the media scanner.  Do not modify this field.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_MODIFIED = "date_modified";

        /**
         * The MIME type of the file
         * <P>Type: TEXT</P>
         */
        const String MIME_TYPE = "mime_type";

        /**
         * The MTP object handle of a newly transfered file.
         * Used to pass the new file's object handle through the media scanner
         * from MTP to the media provider
         * For internal use only by MTP, media scanner and media provider.
         * <P>Type: INTEGER</P>
         * @hide
         */
        const String MEDIA_SCANNER_NEW_OBJECT_ID = "media_scanner_new_object_id";

        /**
         * Non-zero if the media file is drm-protected
         * <P>Type: INTEGER (boolean)</P>
         * @hide
         */
        const String IS_DRM = "is_drm";

        /**
         * The width of the image/video in pixels.
         */
        const String WIDTH = "width";

        /**
         * The height of the image/video in pixels.
         */
        const String HEIGHT = "height";
    }

    interface IMediaStoreFiles {
        /**
         * Get the content:// style URI for the files table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the files table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);

        /**
         * Get the content:// style URI for a single row in the files table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @param rowId the file to get the URI for
         * @return the URI to the files table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [in] Int64 rowId,
            [out] IUri** uri);

        /**
         * For use only by the MTP implementation.
         * @hide
         */
        GetMtpObjectsUri(
            [in] String volumeName,
            [out] IUri** uri);

        /**
         * For use only by the MTP implementation.
         * @hide
         */
        GetMtpObjectsUri(
            [in] String volumeName,
            [in] Int64 fileId,
            [out] IUri** uri);

        /**
         * Used to implement the MTP GetObjectReferences and SetObjectReferences commands.
         * @hide
         */
        GetMtpReferencesUri(
            [in] String volumeName,
            [in] Int64 fileId,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IMediaStoreMediaColumns
     */
    interface IMediaStoreFilesFileColumns {
        /**
         * The MTP storage ID of the file
         * <P>Type: INTEGER</P>
         * @hide
         */
        const String STORAGE_ID = "storage_id";

        /**
         * The MTP format code of the file
         * <P>Type: INTEGER</P>
         * @hide
         */
        const String FORMAT = "format";

        /**
         * The index of the parent directory of the file
         * <P>Type: INTEGER</P>
         */
        const String PARENT = "parent";

        /**
         * The MIME type of the file
         * <P>Type: TEXT</P>
         */
        const String MIME_TYPE = "mime_type";

        /**
         * The title of the content
         * <P>Type: TEXT</P>
         */
        const String TITLE = "title";

        /**
         * The media type (audio, video, image or playlist)
         * of the file, or 0 for not a media file
         * <P>Type: TEXT</P>
         */
        const String MEDIA_TYPE = "media_type";

        /**
         * Constant for the {@link #MEDIA_TYPE} column indicating that file
         * is not an audio, image, video or playlist file.
         */
        const Int32 MEDIA_TYPE_NONE = 0;

        /**
         * Constant for the {@link #MEDIA_TYPE} column indicating that file is an image file.
         */
        const Int32 MEDIA_TYPE_IMAGE = 1;

        /**
         * Constant for the {@link #MEDIA_TYPE} column indicating that file is an audio file.
         */
        const Int32 MEDIA_TYPE_AUDIO = 2;

        /**
         * Constant for the {@link #MEDIA_TYPE} column indicating that file is a video file.
         */
        const Int32 MEDIA_TYPE_VIDEO = 3;

        /**
         * Constant for the {@link #MEDIA_TYPE} column indicating that file is a playlist file.
         */
        const Int32 MEDIA_TYPE_PLAYLIST = 4;
    }

    /**
     * This class is used internally by Images.Thumbnails and Video.Thumbnails, it's not intended
     * to be accessed elsewhere.
     */
    interface IMediaStoreInternalThumbnails {

        const Int32 DEFAULT_GROUP_ID = 0;

        /**
         * This method cancels the thumbnail request so clients waiting for getThumbnail will be
         * interrupted and return immediately. Only the original process which made the getThumbnail
         * requests can cancel their own requests.
         *
         * @param cr ContentResolver
         * @param origId original image or video id. use -1 to cancel all requests.
         * @param groupId the same groupId used in getThumbnail
         * @param baseUri the base URI of requested thumbnails
         */
        CancelThumbnailRequest(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] IUri* baseUri,
            [in] Int64 groupId);

        /**
         * This method ensure thumbnails associated with origId are generated and decode the byte
         * stream from database (MICRO_KIND) or file (MINI_KIND).
         *
         * Special optimization has been done to avoid further IPC communication for MICRO_KIND
         * thumbnails.
         *
         * @param cr ContentResolver
         * @param origId original image or video id
         * @param kind could be MINI_KIND or MICRO_KIND
         * @param options this is only used for MINI_KIND when decoding the Bitmap
         * @param baseUri the base URI of requested thumbnails
         * @param groupId the id of group to which this request belongs
         * @return Bitmap bitmap of specified thumbnail kind
         */
        GetThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int64 groupId,
            [in] Int32 kind,
            [in] IBitmapFactoryOptions* options,
            [in] IUri* baseUri,
            [in] Boolean isVideo,
            [out] IBitmap** bitmap);
    }

    /**
     * @Involve
     * interface IMediaStoreMediaColumns
     */
    interface IMediaStoreImagesImageColumns {
        /**
         * The description of the image
         * <P>Type: TEXT</P>
         */
        const String DESCRIPTION = "description";

        /**
         * The picasa id of the image
         * <P>Type: TEXT</P>
         */
        const String PICASA_ID = "picasa_id";

        /**
         * Whether the video should be published as public or private
         * <P>Type: INTEGER</P>
         */
        const String IS_PRIVATE = "isprivate";

        /**
         * The latitude where the image was captured.
         * <P>Type: DOUBLE</P>
         */
        const String LATITUDE = "latitude";

        /**
         * The longitude where the image was captured.
         * <P>Type: DOUBLE</P>
         */
        const String LONGITUDE = "longitude";

        /**
         * The date & time that the image was taken in units
         * of milliseconds since jan 1, 1970.
         * <P>Type: INTEGER</P>
         */
        const String DATE_TAKEN = "datetaken";

        /**
         * The orientation for the image expressed as degrees.
         * Only degrees 0, 90, 180, 270 will work.
         * <P>Type: INTEGER</P>
         */
        const String ORIENTATION = "orientation";

        /**
         * The mini thumb id.
         * <P>Type: INTEGER</P>
         */
        const String MINI_THUMB_MAGIC = "mini_thumb_magic";

        /**
         * The bucket id of the image. This is a read-only property that
         * is automatically computed from the DATA column.
         * <P>Type: TEXT</P>
         */
        const String BUCKET_ID = "bucket_id";

        /**
         * The bucket display name of the image. This is a read-only property that
         * is automatically computed from the DATA column.
         * <P>Type: TEXT</P>
         */
        const String BUCKET_DISPLAY_NAME = "bucket_display_name";
    }

    /**
     * @Involve
     * interface IMediaStoreImagesImageColumns
     */
    [deprecated]
    interface IMediaStoreImagesMedia {

        /**
         * The MIME type of of this directory of
         * images.  Note that each entry in this directory will have a standard
         * image MIME type as appropriate -- for example, image/jpeg.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/image";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "bucket_display_name";  //IMediaStoreImagesImageColumns::BUCKET_DISPLAY_NAME;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        Query(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [out] ICursor** cursor);

        Query(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String where,
            [in] String orderBy,
            [out] ICursor** cursor);

        Query(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [in] String selection,
            [in] ArrayOf<String>* selectionArgs,
            [in] String orderBy,
            [out] ICursor** cursor);

        /**
         * Retrieves an image for the given url as a {@link Bitmap}.
         *
         * @param cr The content resolver to use
         * @param url The url of the image
         * @throws FileNotFoundException
         * @throws IOException
         */
        GetBitmap(
            [in] IContentResolver* cr,
            [in] IUri* url,
            [out] IBitmap** bitmap);

        /**
         * Insert an image and create a thumbnail for it.
         *
         * @param cr The content resolver to use
         * @param imagePath The path to the image to insert
         * @param name The name of the image
         * @param description The description of the image
         * @return The URL to the newly created image
         * @throws FileNotFoundException
         */
        InsertImage(
            [in] IContentResolver* cr,
            [in] String imagePath,
            [in] String name,
            [in] String description,
            [out] String* url);

        /**
         * Insert an image and create a thumbnail for it.
         *
         * @param cr The content resolver to use
         * @param source The stream to use for the image
         * @param title The name of the image
         * @param description The description of the image
         * @return The URL to the newly created image, or <code>null</code> if the image failed to be stored
         *              for any reason.
         */
        InsertImage(
            [in] IContentResolver* cr,
            [in] IBitmap* source,
            [in] String title,
            [in] String description,
            [out] String* urlvalue);

        /**
         * Get the content:// style URI for the image media table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the image media table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IBaseColumns
     */
    [deprecated]
    interface IMediaStoreImagesThumbnails {

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "image_id ASC";

        /**
         * The data stream for the thumbnail
         * <P>Type: DATA STREAM</P>
         */
        const String DATA = "_data";

        /**
         * The original image for the thumbnal
         * <P>Type: INTEGER (ID from Images table)</P>
         */
        const String IMAGE_ID = "image_id";

        /**
         * The kind of the thumbnail
         * <P>Type: INTEGER (One of the values below)</P>
         */
        const String KIND = "kind";

        const Int32 MINI_KIND = 1;
        const Int32 FULL_SCREEN_KIND = 2;
        const Int32 MICRO_KIND = 3;
        /**
         * The blob raw data of thumbnail
         * <P>Type: DATA STREAM</P>
         */
        const String THUMB_DATA = "thumb_data";

        /**
         * The width of the thumbnal
         * <P>Type: INTEGER (long)</P>
         */
        const String WIDTH = "width";

        /**
         * The height of the thumbnail
         * <P>Type: INTEGER (long)</P>
         */
        const String HEIGHT = "height";

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        Query(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [out] ICursor** cursor);

        QueryMiniThumbnails(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] Int32 kind,
            [in] ArrayOf<String>* projection,
            [out] ICursor** cursor);

        QueryMiniThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int32 kind,
            [in] ArrayOf<String>* projection,
            [out] ICursor** cursor);

        /**
         * This method cancels the thumbnail request so clients waiting for getThumbnail will be
         * interrupted and return immediately. Only the original process which made the getThumbnail
         * requests can cancel their own requests.
         *
         * @param cr ContentResolver
         * @param origId original image id
         */
        CancelThumbnailRequest(
            [in] IContentResolver* cr,
            [in] Int64 origId);

        /**
         * This method checks if the thumbnails of the specified image (origId) has been created.
         * It will be blocked until the thumbnails are generated.
         *
         * @param cr ContentResolver used to dispatch queries to MediaProvider.
         * @param origId Original image id associated with thumbnail of interest.
         * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
         * @param options this is only used for MINI_KIND when decoding the Bitmap
         * @return A Bitmap instance. It could be null if the original image
         *         associated with origId doesn't exist or memory is not enough.
         */
        GetThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int32 kind,
            [in] IBitmapFactoryOptions* options,
            [out] IBitmap** bitmap);

        /**
         * This method cancels the thumbnail request so clients waiting for getThumbnail will be
         * interrupted and return immediately. Only the original process which made the getThumbnail
         * requests can cancel their own requests.
         *
         * @param cr ContentResolver
         * @param origId original image id
         * @param groupId the same groupId used in getThumbnail.
         */
        CancelThumbnailRequest(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int64 groupId);

        /**
         * This method checks if the thumbnails of the specified image (origId) has been created.
         * It will be blocked until the thumbnails are generated.
         *
         * @param cr ContentResolver used to dispatch queries to MediaProvider.
         * @param origId Original image id associated with thumbnail of interest.
         * @param groupId the id of group to which this request belongs
         * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
         * @param options this is only used for MINI_KIND when decoding the Bitmap
         * @return A Bitmap instance. It could be null if the original image
         *         associated with origId doesn't exist or memory is not enough.
         */
        GetThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int64 groupId,
            [in] Int32 kind,
            [in] IBitmapFactoryOptions* options,
            [out] IBitmap** bitmap);

        /**
         * Get the content:// style URI for the image media table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the image media table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    interface IMediaStoreAudio {
        /**
         * Converts a name to a "key" that can be used for grouping, sorting
         * and searching.
         * The rules that govern this conversion are:
         * - remove 'special' characters like ()[]'!?.,
         * - remove leading/trailing spaces
         * - convert everything to lowercase
         * - remove leading "the ", "an " and "a "
         * - remove trailing ", the|an|a"
         * - remove accents. This step leaves us with CollationKey data,
         *   which is not human readable
         *
         * @param name The artist or album name to convert
         * @return The "key" for the given name.
         */
        KeyFor(
            [in] String name,
            [out] String* key);
    }

    /**
     * @Involve
     * interface IMediaStoreMediaColumns
     */
    interface IMediaStoreAudioAudioColumns {

        /**
         * A non human readable key calculated from the TITLE, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String TITLE_KEY = "title_key";

        /**
         * The duration of the audio file, in ms
         * <P>Type: INTEGER (long)</P>
         */
        const String DURATION = "duration";

        /**
         * The position, in ms, playback was at when playback for this file
         * was last stopped.
         * <P>Type: INTEGER (long)</P>
         */
        const String BOOKMARK = "bookmark";

        /**
         * The id of the artist who created the audio file, if any
         * <P>Type: INTEGER (long)</P>
         */
        const String ARTIST_ID = "artist_id";

        /**
         * The artist who created the audio file, if any
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";

        /**
         * The artist credited for the album that contains the audio file
         * <P>Type: TEXT</P>
         * @hide
         */
        const String ALBUM_ARTIST = "album_artist";

        /**
         * Whether the song is part of a compilation
         * <P>Type: TEXT</P>
         * @hide
         */
        const String COMPILATION = "compilation";

        /**
         * A non human readable key calculated from the ARTIST, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ARTIST_KEY = "artist_key";

        /**
         * The composer of the audio file, if any
         * <P>Type: TEXT</P>
         */
        const String COMPOSER = "composer";

        /**
         * The id of the album the audio file is from, if any
         * <P>Type: INTEGER (long)</P>
         */
        const String ALBUM_ID = "album_id";

        /**
         * The album the audio file is from, if any
         * <P>Type: TEXT</P>
         */
        const String ALBUM = "album";

        /**
         * A non human readable key calculated from the ALBUM, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ALBUM_KEY = "album_key";

        /**
         * The track number of this song on the album, if any.
         * This number encodes both the track number and the
         * disc number. For multi-disc sets, this number will
         * be 1xxx for tracks on the first disc, 2xxx for tracks
         * on the second disc, etc.
         * <P>Type: INTEGER</P>
         */
        const String TRACK = "track";

        /**
         * The year the audio file was recorded, if any
         * <P>Type: INTEGER</P>
         */
        const String YEAR = "year";

        /**
         * Non-zero if the audio file is music
         * <P>Type: INTEGER (boolean)</P>
         */
        const String IS_MUSIC = "is_music";

        /**
         * Non-zero if the audio file is a podcast
         * <P>Type: INTEGER (boolean)</P>
         */
        const String IS_PODCAST = "is_podcast";

        /**
         * Non-zero if the audio file may be a ringtone
         * <P>Type: INTEGER (boolean)</P>
         */
        const String IS_RINGTONE = "is_ringtone";

        /**
         * Non-zero if the audio file may be an alarm
         * <P>Type: INTEGER (boolean)</P>
         */
        const String IS_ALARM = "is_alarm";

        /**
         * Non-zero if the audio file may be a notification sound
         * <P>Type: INTEGER (boolean)</P>
         */
        const String IS_NOTIFICATION = "is_notification";

        /**
         * The genre of the audio file, if any
         * <P>Type: TEXT</P>
         * Does not exist in the database - only used by the media scanner for inserts.
         * @hide
         */
        const String GENRE = "genre";
    }

    /**
     * @Involve
     * interface IMediaStoreAudioAudioColumns
     */
    interface IMediaStoreAudioMedia {

        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/audio";

        /**
         * The MIME type for an audio track.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/audio";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "title_key";    // IMediaStoreAudioAudioColumns::TITLE_KEY;

        /**
         * Activity Action: Start SoundRecorder application.
         * <p>Input: nothing.
         * <p>Output: An uri to the recorded sound stored in the Media Library
         * if the recording was successful.
         * May also contain the extra EXTRA_MAX_BYTES.
         * @see #EXTRA_MAX_BYTES
         */
        const String RECORD_SOUND_ACTION =
                "android.provider.MediaStore.RECORD_SOUND";

        /**
         * The name of the Intent-extra used to define a maximum file size for
         * a recording made by the SoundRecorder application.
         *
         * @see #RECORD_SOUND_ACTION
         */
        const String EXTRA_MAX_BYTES =
                "android.provider.MediaStore.extra.MAX_BYTES";

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the audio media table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the audio media table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);

        GetContentUriForPath(
            [in] String path,
            [out] IUri** uri);
    }

    interface IMediaStoreAudioGenresColumns {
        /**
         * The name of the genre
         * <P>Type: TEXT</P>
         */
        const String NAME = "name";
    }

    /**
     * @Involve
     * interface IBaseColumns
     * interface IMediaStoreAudioGenresColumns
     */
    interface IMediaStoreAudioGenres {
        /**
         * The name of the genre
         * <P>Type: TEXT</P>
         */
        const String NAME = "name";     //from IMediaStoreAudioGenresColumns

        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/genre";

        /**
         * The MIME type for entries in this table.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/genre";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "name";       // IMediaStoreAudioGenresColumns::NAME;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the audio genres table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the audio genres table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);

        /**
         * Get the content:// style URI for querying the genres of an audio file.
         *
         * @param volumeName the name of the volume to get the URI for
         * @param audioId the ID of the audio file for which to retrieve the genres
         * @return the URI to for querying the genres for the audio file
         * with the given the volume and audioID
         */
        GetContentUriForAudioId(
            [in] String volumeName,
            [in] Int32 audioId,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IMediaStoreAudioAudioColumns
     */
    interface IMediaStoreAudioGenresMembers {
        /**
         * A subdirectory of each genre containing all member audio files.
         */
        const String CONTENT_DIRECTORY = "members";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "title_key";   //TITLE_KEY;

        /**
         * The ID of the audio file
         * <P>Type: INTEGER (long)</P>
         */
        const String AUDIO_ID = "audio_id";

        /**
         * The ID of the genre
         * <P>Type: INTEGER (long)</P>
         */
        const String GENRE_ID = "genre_id";

        GetContentUri(
            [in] String volumeName,
            [in] Int64 genreId,
            [out] IUri** uri);
    }

    interface IMediaStoreAudioPlaylistsColumns {
        /**
         * The name of the playlist
         * <P>Type: TEXT</P>
         */
        const String NAME = "name";

        /**
         * The data stream for the playlist file
         * <P>Type: DATA STREAM</P>
         */
        const String DATA = "_data";

        /**
         * The time the file was added to the media provider
         * Units are seconds since 1970.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_ADDED = "date_added";

        /**
         * The time the file was last modified
         * Units are seconds since 1970.
         * NOTE: This is for internal use by the media scanner.  Do not modify this field.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_MODIFIED = "date_modified";
    }

    /**
     * @Involve
     * interface IBaseColumns;
     * interface IMediaStoreAudioPlaylistsColumns;
     */
    interface IMediaStoreAudioPlaylists {
        /**
         * The name of the playlist
         * <P>Type: TEXT</P>
         */
        const String NAME = "name";     // from IMediaStoreAudioPlaylistsColumns

        /**
         * The data stream for the playlist file
         * <P>Type: DATA STREAM</P>
         */
        const String DATA = "_data";     // from IMediaStoreAudioPlaylistsColumns

        /**
         * The time the file was added to the media provider
         * Units are seconds since 1970.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_ADDED = "date_added";     // from IMediaStoreAudioPlaylistsColumns

        /**
         * The time the file was last modified
         * Units are seconds since 1970.
         * NOTE: This is for internal use by the media scanner.  Do not modify this field.
         * <P>Type: INTEGER (long)</P>
         */
        const String DATE_MODIFIED = "date_modified";     // from IMediaStoreAudioPlaylistsColumns

        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/playlist";

        /**
         * The MIME type for entries in this table.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/playlist";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "name";       // IMediaStoreAudioPlaylistsColumns::NAME;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the audio playlists table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the audio playlists table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IMediaStoreAudioAudioColumns
     */
    interface IMediaStoreAudioPlaylistsMembers {
        /**
         * The ID within the playlist.
         */
        const String ID = "_id";

        /**
         * A subdirectory of each playlist containing all member audio
         * files.
         */
        const String CONTENT_DIRECTORY = "members";

        /**
         * The ID of the audio file
         * <P>Type: INTEGER (long)</P>
         */
        const String AUDIO_ID = "audio_id";

        /**
         * The ID of the playlist
         * <P>Type: INTEGER (long)</P>
         */
        const String PLAYLIST_ID = "playlist_id";

        /**
         * The order of the songs in the playlist
         * <P>Type: INTEGER (long)></P>
         */
        const String PLAY_ORDER = "play_order";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "play_order";     //PLAY_ORDER;

        GetContentUri(
            [in] String volumeName,
            [in] Int64 playlistId,
            [out] IUri** uri);

        /**
         * Convenience method to move a playlist item to a new location
         * @param res The content resolver to use
         * @param playlistId The numeric id of the playlist
         * @param from The position of the item to move
         * @param to The position to move the item to
         * @return true on success
         */
        MoveItem(
            [in] IContentResolver* res,
            [in] Int64 playlistId,
            [in] Int32 from,
            [in] Int32 to,
            [out] Boolean* result);
    }

    interface IMediaStoreAudioArtistColumns {
        /**
         * The artist who created the audio file, if any
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";

        /**
         * A non human readable key calculated from the ARTIST, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ARTIST_KEY = "artist_key";

        /**
         * The number of albums in the database for this artist
         */
        const String NUMBER_OF_ALBUMS = "number_of_albums";

        /**
         * The number of albums in the database for this artist
         */
        const String NUMBER_OF_TRACKS = "number_of_tracks";
    }

    /**
     * @Involve
     * interface IBaseColumns;
     * interface IMediaStoreAudioArtistColumns;
     */
    interface IMediaStoreAudioArtists {
        /**
         * The artist who created the audio file, if any
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";     //from IMediaStoreAudioArtistColumns

        /**
         * A non human readable key calculated from the ARTIST, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ARTIST_KEY = "artist_key";     //from IMediaStoreAudioArtistColumns

        /**
         * The number of albums in the database for this artist
         */
        const String NUMBER_OF_ALBUMS = "number_of_albums";     //from IMediaStoreAudioArtistColumns

        /**
         * The number of albums in the database for this artist
         */
        const String NUMBER_OF_TRACKS = "number_of_tracks";     //from IMediaStoreAudioArtistColumns

        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/artists";

        /**
         * The MIME type for entries in this table.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/artist";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "artist_key";     // IMediaStoreAudioArtistColumns::ARTIST_KEY;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the artists table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the audio artists table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    interface IMediaStoreAudioAlbumColumns {
        /**
         * The id for the album
         * <P>Type: INTEGER</P>
         */
        const String ALBUM_ID = "album_id";

        /**
         * The album on which the audio file appears, if any
         * <P>Type: TEXT</P>
         */
        const String ALBUM = "album";

        /**
         * The artist whose songs appear on this album
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";

        /**
         * The number of songs on this album
         * <P>Type: INTEGER</P>
         */
        const String NUMBER_OF_SONGS = "numsongs";

        /**
         * This column is available when getting album info via artist,
         * and indicates the number of songs on the album by the given
         * artist.
         * <P>Type: INTEGER</P>
         */
        const String NUMBER_OF_SONGS_FOR_ARTIST = "numsongs_by_artist";

        /**
         * The year in which the earliest songs
         * on this album were released. This will often
         * be the same as {@link #LAST_YEAR}, but for compilation albums
         * they might differ.
         * <P>Type: INTEGER</P>
         */
        const String FIRST_YEAR = "minyear";

        /**
         * The year in which the latest songs
         * on this album were released. This will often
         * be the same as {@link #FIRST_YEAR}, but for compilation albums
         * they might differ.
         * <P>Type: INTEGER</P>
         */
        const String LAST_YEAR = "maxyear";

        /**
         * A non human readable key calculated from the ALBUM, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ALBUM_KEY = "album_key";

        /**
         * Cached album art.
         * <P>Type: TEXT</P>
         */
        const String ALBUM_ART = "album_art";
    }

    /**
     * @Involve
     * interface IMediaStoreAudioAlbumColumns
     */
    interface IMediaStoreAudioArtistsAlbums {
        GetContentUri(
            [in] String volumeName,
            [in] Int64 artistId,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IBaseColumns;
     * interface IMediaStoreAudioAlbumColumns;
     */
    interface IMediaStoreAudioAlbums {
        /**
         * The id for the album
         * <P>Type: INTEGER</P>
         */
        const String ALBUM_ID = "album_id";     // from IMediaStoreAudioAlbumColumns

        /**
         * The album on which the audio file appears, if any
         * <P>Type: TEXT</P>
         */
        const String ALBUM = "album";     // from IMediaStoreAudioAlbumColumns

        /**
         * The artist whose songs appear on this album
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";     // from IMediaStoreAudioAlbumColumns

        /**
         * The number of songs on this album
         * <P>Type: INTEGER</P>
         */
        const String NUMBER_OF_SONGS = "numsongs";     // from IMediaStoreAudioAlbumColumns

        /**
         * This column is available when getting album info via artist,
         * and indicates the number of songs on the album by the given
         * artist.
         * <P>Type: INTEGER</P>
         */
        const String NUMBER_OF_SONGS_FOR_ARTIST = "numsongs_by_artist";     // from IMediaStoreAudioAlbumColumns

        /**
         * The year in which the earliest songs
         * on this album were released. This will often
         * be the same as {@link #LAST_YEAR}, but for compilation albums
         * they might differ.
         * <P>Type: INTEGER</P>
         */
        const String FIRST_YEAR = "minyear";     // from IMediaStoreAudioAlbumColumns

        /**
         * The year in which the latest songs
         * on this album were released. This will often
         * be the same as {@link #FIRST_YEAR}, but for compilation albums
         * they might differ.
         * <P>Type: INTEGER</P>
         */
        const String LAST_YEAR = "maxyear";     // from IMediaStoreAudioAlbumColumns

        /**
         * A non human readable key calculated from the ALBUM, used for
         * searching, sorting and grouping
         * <P>Type: TEXT</P>
         */
        const String ALBUM_KEY = "album_key";     // from IMediaStoreAudioAlbumColumns

        /**
         * Cached album art.
         * <P>Type: TEXT</P>
         */
        const String ALBUM_ART = "album_art";     // from IMediaStoreAudioAlbumColumns

        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/albums";

        /**
         * The MIME type for entries in this table.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/album";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "album_key";      //IMediaStoreAudioAlbumColumns::ALBUM_KEY;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the albums table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the audio albums table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    interface IMediaStoreAudioRadio {
        /**
         * The MIME type for entries in this table.
         */
        const String ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/radio";
    }

    [deprecated]
    interface IMediaStoreVideo {
        /**
         * The default sort order for this table.
         */
        const String DEFAULT_SORT_ORDER = "_display_name";       //IMediaStoreMediaColumns::DISPLAY_NAME;

        Query(
            [in] IContentResolver* cr,
            [in] IUri* uri,
            [in] ArrayOf<String>* projection,
            [out] ICursor** cursor);
    }

    /**
     * @Involve
     * interface IMediaStoreMediaColumns
     */
    interface IMediaStoreVideoVideoColumns {
        /**
         * The duration of the video file, in ms
         * <P>Type: INTEGER (long)</P>
         */
        const String DURATION = "duration";

        /**
         * The artist who created the video file, if any
         * <P>Type: TEXT</P>
         */
        const String ARTIST = "artist";

        /**
         * The album the video file is from, if any
         * <P>Type: TEXT</P>
         */
        const String ALBUM = "album";

        /**
         * The resolution of the video file, formatted as "XxY"
         * <P>Type: TEXT</P>
         */
        const String RESOLUTION = "resolution";

        /**
         * The description of the video recording
         * <P>Type: TEXT</P>
         */
        const String DESCRIPTION = "description";

        /**
         * Whether the video should be published as public or private
         * <P>Type: INTEGER</P>
         */
        const String IS_PRIVATE = "isprivate";

        /**
         * The user-added tags associated with a video
         * <P>Type: TEXT</P>
         */
        const String TAGS = "tags";

        /**
         * The YouTube category of the video
         * <P>Type: TEXT</P>
         */
        const String CATEGORY = "category";

        /**
         * The language of the video
         * <P>Type: TEXT</P>
         */
        const String LANGUAGE = "language";

        /**
         * The latitude where the video was captured.
         * <P>Type: DOUBLE</P>
         */
        const String LATITUDE = "latitude";

        /**
         * The longitude where the video was captured.
         * <P>Type: DOUBLE</P>
         */
        const String LONGITUDE = "longitude";

        /**
         * The date & time that the video was taken in units
         * of milliseconds since jan 1, 1970.
         * <P>Type: INTEGER</P>
         */
        const String DATE_TAKEN = "datetaken";

        /**
         * The mini thumb id.
         * <P>Type: INTEGER</P>
         */
        const String MINI_THUMB_MAGIC = "mini_thumb_magic";

        /**
         * The bucket id of the video. This is a read-only property that
         * is automatically computed from the DATA column.
         * <P>Type: TEXT</P>
         */
        const String BUCKET_ID = "bucket_id";

        /**
         * The bucket display name of the video. This is a read-only property that
         * is automatically computed from the DATA column.
         * <P>Type: TEXT</P>
         */
        const String BUCKET_DISPLAY_NAME = "bucket_display_name";

        /**
         * The bookmark for the video. Time in ms. Represents the location in the video that the
         * video should start playing at the next time it is opened. If the value is null or
         * out of the range 0..DURATION-1 then the video should start playing from the
         * beginning.
         * <P>Type: INTEGER</P>
         */
        const String BOOKMARK = "bookmark";
    }

    /**
     * @Involve
     * interface IMediaStoreVideoVideoColumns
     */
    interface IMediaStoreVideoMedia {
        /**
         * The MIME type for this table.
         */
        const String CONTENT_TYPE = "vnd.android.cursor.dir/video";

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "title";      // IMediaStoreMediaColumns::TITLE;

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * Get the content:// style URI for the video media table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the video media table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    /**
     * @Involve
     * interface IBaseColumns
     */
    interface IMediaStoreVideoThumbnails {

        /**
         * The default sort order for this table
         */
        const String DEFAULT_SORT_ORDER = "video_id ASC";

        /**
         * The data stream for the thumbnail
         * <P>Type: DATA STREAM</P>
         */
        const String DATA = "_data";

        /**
         * The original image for the thumbnal
         * <P>Type: INTEGER (ID from Video table)</P>
         */
        const String VIDEO_ID = "video_id";

        /**
         * The kind of the thumbnail
         * <P>Type: INTEGER (One of the values below)</P>
         */
        const String KIND = "kind";

        const Int32 MINI_KIND = 1;
        const Int32 FULL_SCREEN_KIND = 2;
        const Int32 MICRO_KIND = 3;

        /**
         * The width of the thumbnal
         * <P>Type: INTEGER (long)</P>
         */
        const String WIDTH = "width";

        /**
         * The height of the thumbnail
         * <P>Type: INTEGER (long)</P>
         */
        const String HEIGHT = "height";

        /**
         * The content:// style URI for the internal storage.
         */
        GetINTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * The content:// style URI for the "primary" external storage
         * volume.
         */
        GetEXTERNAL_CONTENT_URI(
            [out] IUri** uri);

        /**
         * This method cancels the thumbnail request so clients waiting for getThumbnail will be
         * interrupted and return immediately. Only the original process which made the getThumbnail
         * requests can cancel their own requests.
         *
         * @param cr ContentResolver
         * @param origId original video id
         */
        CancelThumbnailRequest(
            [in] IContentResolver* cr,
            [in] Int64 origId);

        /**
         * This method checks if the thumbnails of the specified image (origId) has been created.
         * It will be blocked until the thumbnails are generated.
         *
         * @param cr ContentResolver used to dispatch queries to MediaProvider.
         * @param origId Original image id associated with thumbnail of interest.
         * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
         * @param options this is only used for MINI_KIND when decoding the Bitmap
         * @return A Bitmap instance. It could be null if the original image
         *         associated with origId doesn't exist or memory is not enough.
         */
        GetThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int32 kind,
            [in] IBitmapFactoryOptions* options,
            [out] IBitmap** bitmap);

        /**
         * This method checks if the thumbnails of the specified image (origId) has been created.
         * It will be blocked until the thumbnails are generated.
         *
         * @param cr ContentResolver used to dispatch queries to MediaProvider.
         * @param origId Original image id associated with thumbnail of interest.
         * @param groupId the id of group to which this request belongs
         * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND
         * @param options this is only used for MINI_KIND when decoding the Bitmap
         * @return A Bitmap instance. It could be null if the original image associated with
         *         origId doesn't exist or memory is not enough.
         */
        GetThumbnail(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int64 groupId,
            [in] Int32 kind,
            [in] IBitmapFactoryOptions* options,
            [out] IBitmap** bitmap);

        /**
         * This method cancels the thumbnail request so clients waiting for getThumbnail will be
         * interrupted and return immediately. Only the original process which made the getThumbnail
         * requests can cancel their own requests.
         *
         * @param cr ContentResolver
         * @param origId original video id
         * @param groupId the same groupId used in getThumbnail.
         */
        CancelThumbnailRequest(
            [in] IContentResolver* cr,
            [in] Int64 origId,
            [in] Int64 groupId);

        /**
         * Get the content:// style URI for the image media table on the
         * given volume.
         *
         * @param volumeName the name of the volume to get the URI for
         * @return the URI to the image media table on the given volume
         */
        GetContentUri(
            [in] String volumeName,
            [out] IUri** uri);
    }

    } // namespace Provider
    } // namespace Droid
    } // namespace Elastos

}
