
module
{
    using interface Elastos.Core.ICharSequence;
    using interface Elastos.Utility.IList;

    interface Elastos.Droid.Os.IUserHandle;
    interface Elastos.Droid.Content.Pm.IPackageInfo;
    interface Elastos.Droid.Content.Pm.IPermissionInfo;
    interface Elastos.Droid.Content.Pm.IPermissionGroupInfo;
    interface Elastos.Droid.Content.Pm.IApplicationInfo;
    interface Elastos.Droid.Content.Pm.IActivityInfo;
    interface Elastos.Droid.Content.Pm.IServiceInfo;
    interface Elastos.Droid.Content.Pm.IProviderInfo;
    interface Elastos.Droid.Content.Pm.IFeatureInfo;
    interface Elastos.Droid.Content.Pm.IResolveInfo;
    interface Elastos.Droid.Content.Pm.IInstrumentationInfo;
    interface Elastos.Droid.Content.Pm.IIPackageDataObserver;
    interface Elastos.Droid.Content.Pm.IIPackageDeleteObserver;
    interface Elastos.Droid.Content.Pm.IIPackageInstallObserver;
    interface Elastos.Droid.Content.Pm.IIPackageMoveObserver;
    interface Elastos.Droid.Content.Pm.IIPackageStatsObserver;
    interface Elastos.Droid.Content.Pm.IManifestDigest;
    interface Elastos.Droid.Content.Pm.IContainerEncryptionParams;
    interface Elastos.Droid.Content.Pm.IVerificationParams;
    interface Elastos.Droid.Content.Pm.IVerifierDeviceIdentity;
    interface Elastos.Droid.Content.Res.IXmlResourceParser;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Content.IIntent;
    interface Elastos.Droid.Content.IComponentName;
    interface Elastos.Droid.Content.IIntentSender;
    interface Elastos.Droid.Content.IIntentFilter;
    interface Elastos.Droid.Graphics.IRect;
    interface Elastos.Droid.Graphics.Drawable.IDrawable;
    interface Elastos.Droid.Net.IUri;

    namespace Elastos {
    namespace Droid {
    namespace Content {
    namespace Pm {

    /**
     * Class for retrieving various kinds of information related to the
     * application packages that are currently installed on the device. You can
     * find this class through getPackageManager().
     *
     * @sa getPackageManager()
     */

    [deprecated, local]
    interface IPackageManager {

        /**
         * {@link PackageInfo} flag: return information about
         * activities in the package in {@link PackageInfo#activities}.
         */
        const Int32 GET_ACTIVITIES              = 0x00000001;

        /**
         * {@link PackageInfo} flag: return information about
         * intent receivers in the package in
         * {@link PackageInfo#receivers}.
         */
        const Int32 GET_RECEIVERS               = 0x00000002;

        /**
         * {@link PackageInfo} flag: return information about
         * services in the package in {@link PackageInfo#services}.
         */
        const Int32 GET_SERVICES                = 0x00000004;

        /**
         * {@link PackageInfo} flag: return information about
         * content providers in the package in
         * {@link PackageInfo#providers}.
         */
        const Int32 GET_PROVIDERS               = 0x00000008;

        /**
         * {@link PackageInfo} flag: return information about
         * instrumentation in the package in
         * {@link PackageInfo#instrumentation}.
         */
        const Int32 GET_INSTRUMENTATION         = 0x00000010;

        /**
         * {@link PackageInfo} flag: return information about the
         * intent filters supported by the activity.
         */
        const Int32 GET_INTENT_FILTERS          = 0x00000020;

        /**
         * {@link PackageInfo} flag: return information about the
         * signatures included in the package.
         */
        const Int32 GET_SIGNATURES          = 0x00000040;

        /**
         * {@link ResolveInfo} flag: return the IntentFilter that
         * was matched for a particular ResolveInfo in
         * {@link ResolveInfo#filter}.
         */
        const Int32 GET_RESOLVED_FILTER         = 0x00000040;

        /**
         * {@link ComponentInfo} flag: return the {@link ComponentInfo#metaData}
         * data {@link android.os.Bundle}s that are associated with a component.
         * This applies for any API returning a ComponentInfo subclass.
         */
        const Int32 GET_META_DATA               = 0x00000080;

        /**
         * {@link PackageInfo} flag: return the
         * {@link PackageInfo#gids group ids} that are associated with an
         * application.
         * This applies for any API returning a PackageInfo class, either
         * directly or nested inside of another.
         */
        const Int32 GET_GIDS                    = 0x00000100;

        /**
         * {@link PackageInfo} flag: include disabled components in the returned info.
         */
        const Int32 GET_DISABLED_COMPONENTS     = 0x00000200;

        /**
         * {@link ApplicationInfo} flag: return the
         * {@link ApplicationInfo#sharedLibraryFiles paths to the shared libraries}
         * that are associated with an application.
         * This applies for any API returning an ApplicationInfo class, either
         * directly or nested inside of another.
         */
        const Int32 GET_SHARED_LIBRARY_FILES    = 0x00000400;

        /**
         * {@link ProviderInfo} flag: return the
         * {@link ProviderInfo#uriPermissionPatterns URI permission patterns}
         * that are associated with a content provider.
         * This applies for any API returning a ProviderInfo class, either
         * directly or nested inside of another.
         */
        const Int32 GET_URI_PERMISSION_PATTERNS  = 0x00000800;
        /**
         * {@link PackageInfo} flag: return information about
         * permissions in the package in
         * {@link PackageInfo#permissions}.
         */
        const Int32 GET_PERMISSIONS               = 0x00001000;

        /**
         * Flag parameter to retrieve some information about all applications (even
         * uninstalled ones) which have data directories. This state could have
         * resulted if applications have been deleted with flag
         * {@code DONT_DELETE_DATA} with a possibility of being replaced or
         * reinstalled in future.
         * <p>
         * Note: this flag may cause less information about currently installed
         * applications to be returned.
         */
        const Int32 GET_UNINSTALLED_PACKAGES = 0x00002000;

        /**
         * {@link PackageInfo} flag: return information about
         * hardware preferences in
         * {@link PackageInfo#configPreferences PackageInfo.configPreferences},
         * and requested features in {@link PackageInfo#reqFeatures} and
         * {@link PackageInfo#featureGroups}.
         */
        const Int32 GET_CONFIGURATIONS = 0x00004000;

        /**
         * {@link PackageInfo} flag: include disabled components which are in
         * that state only because of {@link #COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED}
         * in the returned info.  Note that if you set this flag, applications
         * that are in this disabled state will be reported as enabled.
         */
        const Int32 GET_DISABLED_UNTIL_USED_COMPONENTS = 0x00008000;

        /**
         * Resolution and querying flag: if set, only filters that support the
         * {@link android.content.Intent#CATEGORY_DEFAULT} will be considered for
         * matching.  This is a synonym for including the CATEGORY_DEFAULT in your
         * supplied Intent.
         */
        const Int32 MATCH_DEFAULT_ONLY   = 0x00010000;

        /**
         * Flag for {@link addCrossProfileIntentFilter}: if this flag is set:
         * when resolving an intent that matches the {@link CrossProfileIntentFilter}, the current
         * profile will be skipped.
         * Only activities in the target user can respond to the intent.
         * @hide
         */
        const Int32 SKIP_CURRENT_PROFILE = 0x00000002;

        /**
         * Permission check result: this is returned by {@link #checkPermission}
         * if the permission has been granted to the given package.
         */
        const Int32 PERMISSION_GRANTED = 0;

        /**
         * Permission check result: this is returned by {@link #checkPermission}
         * if the permission has not been granted to the given package.
         */
        const Int32 PERMISSION_DENIED = -1;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if all signatures on the two packages match.
         */
        const Int32 SIGNATURE_MATCH = 0;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if neither of the two packages is signed.
         */
        const Int32 SIGNATURE_NEITHER_SIGNED = 1;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if the first package is not signed but the second is.
         */
        const Int32 SIGNATURE_FIRST_NOT_SIGNED = -1;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if the second package is not signed but the first is.
         */
        const Int32 SIGNATURE_SECOND_NOT_SIGNED = -2;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if not all signatures on both packages match.
         */
        const Int32 SIGNATURE_NO_MATCH = -3;

        /**
         * Signature check result: this is returned by {@link #checkSignatures}
         * if either of the packages are not valid.
         */
        const Int32 SIGNATURE_UNKNOWN_PACKAGE = -4;

        /**
         * Flag for {@link #setApplicationEnabledSetting(String, int, int)}
         * and {@link #setComponentEnabledSetting(ComponentName, int, int)}: This
         * component or application is in its default enabled state (as specified
         * in its manifest).
         */
        const Int32 COMPONENT_ENABLED_STATE_DEFAULT = 0;

        /**
         * Flag for {@link #setApplicationEnabledSetting(String, int, int)}
         * and {@link #setComponentEnabledSetting(ComponentName, int, int)}: This
         * component or application has been explictily enabled, regardless of
         * what it has specified in its manifest.
         */
        const Int32 COMPONENT_ENABLED_STATE_ENABLED = 1;

        /**
         * Flag for {@link #setApplicationEnabledSetting(String, int, int)}
         * and {@link #setComponentEnabledSetting(ComponentName, int, int)}: This
         * component or application has been explicitly disabled, regardless of
         * what it has specified in its manifest.
         */
        const Int32 COMPONENT_ENABLED_STATE_DISABLED = 2;

        /**
         * Flag for {@link #setApplicationEnabledSetting(String, int, int)} only: The
         * user has explicitly disabled the application, regardless of what it has
         * specified in its manifest.  Because this is due to the user's request,
         * they may re-enable it if desired through the appropriate system UI.  This
         * option currently <strong>cannot</strong> be used with
         * {@link #setComponentEnabledSetting(ComponentName, int, int)}.
         */
        const Int32 COMPONENT_ENABLED_STATE_DISABLED_USER = 3;

        /**
         * Flag for {@link #setApplicationEnabledSetting(String, int, int)} only: This
         * application should be considered, until the point where the user actually
         * wants to use it.  This means that it will not normally show up to the user
         * (such as in the launcher), but various parts of the user interface can
         * use {@link #GET_DISABLED_UNTIL_USED_COMPONENTS} to still see it and allow
         * the user to select it (as for example an IME, device admin, etc).  Such code,
         * once the user has selected the app, should at that point also make it enabled.
         * This option currently <strong>can not</strong> be used with
         * {@link #setComponentEnabledSetting(ComponentName, int, int)}.
         */
        const Int32 COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED = 4;

        /**
         * Flag parameter for {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} to
         * indicate that this package should be installed as forward locked, i.e. only the app itself
         * should have access to its code and non-resource assets.
         * @hide
         */
        const Int32 INSTALL_FORWARD_LOCK = 0x00000001;

        /**
         * Flag parameter for {@link #installPackage} to indicate that you want to replace an already
         * installed package, if one exists.
         * @hide
         */
        const Int32 INSTALL_REPLACE_EXISTING = 0x00000002;

        /**
         * Flag parameter for {@link #installPackage} to indicate that you want to
         * allow test packages (those that have set android:testOnly in their
         * manifest) to be installed.
         * @hide
         */
        const Int32 INSTALL_ALLOW_TEST = 0x00000004;

        /**
         * Flag parameter for {@link #installPackage} to indicate that this
         * package has to be installed on the sdcard.
         * @hide
         */
        const Int32 INSTALL_EXTERNAL = 0x00000008;

        /**
         * Flag parameter for {@link #installPackage} to indicate that this package
         * has to be installed on the sdcard.
         * @hide
         */
        const Int32 INSTALL_INTERNAL = 0x00000010;

        /**
         * Flag parameter for {@link #installPackage} to indicate that this install
         * was initiated via ADB.
         *
         * @hide
         */
        const Int32 INSTALL_FROM_ADB = 0x00000020;

        /**
         * Flag parameter for {@link #installPackage} to indicate that this install
         * should immediately be visible to all users.
         *
         * @hide
         */
        const Int32 INSTALL_ALL_USERS = 0x00000040;

        /**
         * Flag parameter for {@link #installPackage} to indicate that it is okay
         * to install an update to an app where the newly installed app has a lower
         * version code than the currently installed app.
         *
         * @hide
         */
        const Int32 INSTALL_ALLOW_DOWNGRADE = 0x00000080;

        /**
         * Flag parameter for
         * {@link #setComponentEnabledSetting(android.content.ComponentName, int, int)} to indicate
         * that you don't want to kill the app containing the component.  Be careful when you set this
         * since changing component states can make the containing application's behavior unpredictable.
         */
        const Int32 DONT_KILL_APP = 0x00000001;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} on success.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_SUCCEEDED = 1;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if the package is
         * already installed.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_ALREADY_EXISTS = -1;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if the package archive
         * file is invalid.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_INVALID_APK = -2;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if the URI passed in
         * is invalid.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_INVALID_URI = -3;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if the package manager
         * service found that the device didn't have enough storage space to install the app.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_INSUFFICIENT_STORAGE = -4;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if a
         * package is already installed with the same name.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_DUPLICATE_PACKAGE = -5;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the requested shared user does not exist.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_NO_SHARED_USER = -6;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * a previously installed package of the same name has a different signature
         * than the new package (and the old package's data was not removed).
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_UPDATE_INCOMPATIBLE = -7;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package is requested a shared user which is already installed on the
         * device and does not have matching signature.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE = -8;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package uses a shared library that is not available.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_MISSING_SHARED_LIBRARY = -9;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package uses a shared library that is not available.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_REPLACE_COULDNT_DELETE = -10;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package failed while optimizing and validating its dex files,
         * either because there was not enough storage or the validation failed.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_DEXOPT = -11;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package failed because the current SDK version is older than
         * that required by the package.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_OLDER_SDK = -12;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package failed because it contains a content provider with the
         * same authority as a provider already installed in the system.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_CONFLICTING_PROVIDER = -13;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package failed because the current SDK version is newer than
         * that required by the package.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_NEWER_SDK = -14;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package failed because it has specified that it is a test-only
         * package and the caller has not supplied the {@link #INSTALL_ALLOW_TEST}
         * flag.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_TEST_ONLY = -15;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the package being installed contains native code, but none that is
         * compatible with the device's CPU_ABI.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -16;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package uses a feature that is not available.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_MISSING_FEATURE = -17;

        // ------ Errors related to sdcard
        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * a secure container mount point couldn't be accessed on external media.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_CONTAINER_ERROR = -18;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package couldn't be installed in the specified install
         * location.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_INVALID_INSTALL_LOCATION = -19;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package couldn't be installed in the specified install
         * location because the media is not available.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_MEDIA_UNAVAILABLE = -20;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package couldn't be installed because the verification timed out.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_VERIFICATION_TIMEOUT = -21;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package couldn't be installed because the verification did not succeed.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_VERIFICATION_FAILURE = -22;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the package changed from what the calling program expected.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_PACKAGE_CHANGED = -23;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package is assigned a different UID than it previously held.
         * @hide
         */
        const Int32 INSTALL_FAILED_UID_CHANGED = -24;

        /**
         * Installation return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)} if
         * the new package has an older version code than the currently installed package.
         * @hide
         */
        const Int32 INSTALL_FAILED_VERSION_DOWNGRADE = -25;

        /**
         * Installation parse return code: this is passed to the {@link IIPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IIPackageInstallObserver, int)}
         * if the parser was given a path that is not a file, or does not end with the expected
         * '.apk' extension.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_NOT_APK = -100;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser was unable to retrieve the AndroidManifest.xml file.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_BAD_MANIFEST = -101;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser encountered an unexpected exception.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION = -102;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser did not find any certificates in the .apk.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_NO_CERTIFICATES = -103;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser found inconsistent certificates on the files in the .apk.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES = -104;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser encountered a CertificateEncodingException in one of the
         * files in the .apk.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING = -105;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser encountered a bad or missing package name in the manifest.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME = -106;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser encountered a bad shared user id name in the manifest.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID = -107;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser encountered some structural problem in the manifest.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_MANIFEST_MALFORMED = -108;

        /**
         * Installation parse return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the parser did not find any actionable tags (instrumentation or application)
         * in the manifest.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_PARSE_FAILED_MANIFEST_EMPTY = -109;

        /**
         * Installation failed return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the system failed to install the package because of system issues.
         * @hide
         */
        //@SystemApi
        const Int32 INSTALL_FAILED_INTERNAL_ERROR = -110;

        /**
         * Installation failed return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the system failed to install the package because the user is restricted from installing
         * apps.
         * @hide
         */
        const Int32 INSTALL_FAILED_USER_RESTRICTED = -111;

        /**
         * Installation failed return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the system failed to install the package because it is attempting to define a
         * permission that is already defined by some existing package.
         *
         * <p>The package name of the app which has already defined the permission is passed to
         * a {@link PackageInstallObserver}, if any, as the {@link #EXTRA_EXISTING_PACKAGE}
         * string extra; and the name of the permission being redefined is passed in the
         * {@link #EXTRA_EXISTING_PERMISSION} string extra.
         * @hide
         */
        const Int32 INSTALL_FAILED_DUPLICATE_PERMISSION = -112;

        /**
         * Installation failed return code: this is passed to the {@link IPackageInstallObserver} by
         * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)}
         * if the system failed to install the package because its packaged native code did not
         * match any of the ABIs supported by the system.
         *
         * @hide
         */
        const Int32 INSTALL_FAILED_NO_MATCHING_ABIS = -113;

        /**
         * Internal return code for NativeLibraryHelper methods to indicate that the package
         * being processed did not contain any native code. This is placed here only so that
         * it can belong to the same value space as the other install failure codes.
         *
         * @hide
         */
        const Int32 NO_NATIVE_LIBRARIES = -114;

        /** {@hide} */
        const Int32 INSTALL_FAILED_ABORTED = -115;

        /**
         * Flag parameter for {@link #deletePackage} to indicate that you don't want to delete the
         * package's data directory.
         *
         * @hide
         */
        const Int32 DELETE_KEEP_DATA = 0x00000001;

        /**
         * Flag parameter for {@link #deletePackage} to indicate that you want the
         * package deleted for all users.
         *
         * @hide
         */
        const Int32 DELETE_ALL_USERS = 0x00000002;

        /**
         * Flag parameter for {@link #deletePackage} to indicate that, if you are calling
         * uninstall on a system that has been updated, then don't do the normal process
         * of uninstalling the update and rolling back to the older system version (which
         * needs to happen for all users); instead, just mark the app as uninstalled for
         * the current user.
         *
         * @hide
         */
        const Int32 DELETE_SYSTEM_APP = 0x00000004;

        /**
         * Return code for when package deletion succeeds. This is passed to the
         * {@link IPackageDeleteObserver} by {@link #deletePackage()} if the system
         * succeeded in deleting the package.
         *
         * @hide
         */
        const Int32 DELETE_SUCCEEDED = 1;

        /**
         * Deletion failed return code: this is passed to the
         * {@link IPackageDeleteObserver} by {@link #deletePackage()} if the system
         * failed to delete the package for an unspecified reason.
         *
         * @hide
         */
        const Int32 DELETE_FAILED_INTERNAL_ERROR = -1;

        /**
         * Deletion failed return code: this is passed to the
         * {@link IPackageDeleteObserver} by {@link #deletePackage()} if the system
         * failed to delete the package because it is the active DevicePolicy
         * manager.
         *
         * @hide
         */
        const Int32 DELETE_FAILED_DEVICE_POLICY_MANAGER = -2;

        /**
         * Deletion failed return code: this is passed to the
         * {@link IPackageDeleteObserver} by {@link #deletePackage()} if the system
         * failed to delete the package since the user is restricted.
         *
         * @hide
         */
        const Int32 DELETE_FAILED_USER_RESTRICTED = -3;

        /**
         * Deletion failed return code: this is passed to the
         * {@link IPackageDeleteObserver} by {@link #deletePackage()} if the system
         * failed to delete the package because a profile
         * or device owner has marked the package as uninstallable.
         *
         * @hide
         */
        const Int32 DELETE_FAILED_OWNER_BLOCKED = -4;

        /** {@hide} */
        const Int32 DELETE_FAILED_ABORTED = -5;

        /**
         * Return code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)} when the
         * package has been successfully moved by the system.
         *
         * @hide
         */
        const Int32 MOVE_SUCCEEDED = 1;
        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * when the package hasn't been successfully moved by the system
         * because of insufficient memory on specified media.
         * @hide
         */
        const Int32 MOVE_FAILED_INSUFFICIENT_STORAGE = -1;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * if the specified package doesn't exist.
         * @hide
         */
        const Int32 MOVE_FAILED_DOESNT_EXIST = -2;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * if the specified package cannot be moved since its a system package.
         * @hide
         */
        const Int32 MOVE_FAILED_SYSTEM_PACKAGE = -3;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * if the specified package cannot be moved since its forward locked.
         * @hide
         */
        const Int32 MOVE_FAILED_FORWARD_LOCKED = -4;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * if the specified package cannot be moved to the specified location.
         * @hide
         */
        const Int32 MOVE_FAILED_INVALID_LOCATION = -5;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)}
         * if the specified package cannot be moved to the specified location.
         * @hide
         */
        const Int32 MOVE_FAILED_INTERNAL_ERROR = -6;

        /**
         * Error code that is passed to the {@link IPackageMoveObserver} by
         * {@link #movePackage(android.net.Uri, IPackageMoveObserver)} if the
         * specified package already has an operation pending in the
         * {@link PackageHandler} queue.
         *
         * @hide
         */
        const Int32 MOVE_FAILED_OPERATION_PENDING = -7;

        /**
         * Flag parameter for {@link #movePackage} to indicate that
         * the package should be moved to internal storage if its
         * been installed on external media.
         * @hide
         */
        const Int32 MOVE_INTERNAL = 0x00000001;

        /**
         * Flag parameter for {@link #movePackage} to indicate that
         * the package should be moved to external media.
         * @hide
         */
        const Int32 MOVE_EXTERNAL_MEDIA = 0x00000002;

        /**
         * Usable by the required verifier as the {@code verificationCode} argument
         * for {@link PackageManager#verifyPendingInstall} to indicate that it will
         * allow the installation to proceed without any of the optional verifiers
         * needing to vote.
         *
         * @hide
         */
        const Int32 VERIFICATION_ALLOW_WITHOUT_SUFFICIENT = 2;

        /**
         * Used as the {@code verificationCode} argument for
         * {@link PackageManager#verifyPendingInstall} to indicate that the calling
         * package verifier allows the installation to proceed.
         */
        const Int32 VERIFICATION_ALLOW = 1;

        /**
         * Used as the {@code verificationCode} argument for
         * {@link PackageManager#verifyPendingInstall} to indicate the calling
         * package verifier does not vote to allow the installation to proceed.
         */
        const Int32 VERIFICATION_REJECT = -1;

        /**
         * Can be used as the {@code millisecondsToDelay} argument for
         * {@link PackageManager#extendVerificationTimeout}. This is the
         * maximum time {@code PackageManager} waits for the verification
         * agent to return (in milliseconds).
         */
        const Int64 MAXIMUM_VERIFICATION_TIMEOUT = 60*60*1000;

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: The device's
         * audio pipeline is low-latency, more suitable for audio applications sensitive to delays or
         * lag in sound input or output.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_AUDIO_LOW_LATENCY = "android.hardware.audio.low_latency";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes at least one form of audio
         * output, such as speakers, audio jack or streaming over bluetooth
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_AUDIO_OUTPUT = "android.hardware.audio.output";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device is capable of communicating with
         * other devices via Bluetooth.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_BLUETOOTH = "android.hardware.bluetooth";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device is capable of communicating with
         * other devices via Bluetooth Low Energy radio.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_BLUETOOTH_LE = "android.hardware.bluetooth_le";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a camera facing away
         * from the screen.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA = "android.hardware.camera";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's camera supports auto-focus.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_AUTOFOCUS = "android.hardware.camera.autofocus";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has at least one camera pointing in
         * some direction, or can support an external camera being connected to it.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_ANY = "android.hardware.camera.any";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device can support having an external camera connected to it.
         * The external camera may not always be connected or available to applications to use.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_EXTERNAL = "android.hardware.camera.external";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's camera supports flash.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_FLASH = "android.hardware.camera.flash";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a front facing camera.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_FRONT = "android.hardware.camera.front";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: At least one
         * of the cameras on the device supports the
         * {@link android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL full hardware}
         * capability level.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_LEVEL_FULL = "android.hardware.camera.level.full";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: At least one
         * of the cameras on the device supports the
         * {@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR manual sensor}
         * capability level.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR =
                "android.hardware.camera.capability.manual_sensor";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: At least one
         * of the cameras on the device supports the
         * {@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING manual post-processing}
         * capability level.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING =
                "android.hardware.camera.capability.manual_post_processing";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}: At least one
         * of the cameras on the device supports the
         * {@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW}
         * capability level.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CAMERA_CAPABILITY_RAW =
                "android.hardware.camera.capability.raw";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device is capable of communicating with
         * consumer IR devices.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CONSUMER_IR = "android.hardware.consumerir";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports one or more methods of
         * reporting current location.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LOCATION = "android.hardware.location";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a Global Positioning System
         * receiver and can report precise location.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LOCATION_GPS = "android.hardware.location.gps";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device can report location with coarse
         * accuracy using a network-based geolocation system.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LOCATION_NETWORK = "android.hardware.location.network";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device can record audio via a
         * microphone.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_MICROPHONE = "android.hardware.microphone";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device can communicate using Near-Field
         * Communications (NFC).
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_NFC = "android.hardware.nfc";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports host-
         * based NFC card emulation.
         *
         * TODO remove when depending apps have moved to new constant.
         * @hide
         * @deprecated
         */
        //@Deprecated
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_NFC_HCE = "android.hardware.nfc.hce";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports host-
         * based NFC card emulation.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_NFC_HOST_CARD_EMULATION = "android.hardware.nfc.hce";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports the OpenGL ES
         * <a href="http://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt">
         * Android Extension Pack</a>.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_OPENGLES_EXTENSION_PACK = "android.hardware.opengles.aep";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes an accelerometer.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_ACCELEROMETER = "android.hardware.sensor.accelerometer";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a barometer (air
         * pressure sensor.)
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_BAROMETER = "android.hardware.sensor.barometer";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a magnetometer (compass).
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_COMPASS = "android.hardware.sensor.compass";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a gyroscope.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_GYROSCOPE = "android.hardware.sensor.gyroscope";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a light sensor.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_LIGHT = "android.hardware.sensor.light";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a proximity sensor.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_PROXIMITY = "android.hardware.sensor.proximity";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a hardware step counter.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_STEP_COUNTER = "android.hardware.sensor.stepcounter";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a hardware step detector.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_STEP_DETECTOR = "android.hardware.sensor.stepdetector";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a heart rate monitor.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_HEART_RATE = "android.hardware.sensor.heartrate";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The heart rate sensor on this device is an Electrocargiogram.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_HEART_RATE_ECG =
                "android.hardware.sensor.heartrate.ecg";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes a relative humidity sensor.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_RELATIVE_HUMIDITY =
                "android.hardware.sensor.relative_humidity";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device includes an ambient temperature sensor.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SENSOR_AMBIENT_TEMPERATURE =
                "android.hardware.sensor.ambient_temperature";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a telephony radio with data
         * communication support.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TELEPHONY = "android.hardware.telephony";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a CDMA telephony stack.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TELEPHONY_CDMA = "android.hardware.telephony.cdma";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device has a GSM telephony stack.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TELEPHONY_GSM = "android.hardware.telephony.gsm";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports connecting to USB devices
         * as the USB host.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_USB_HOST = "android.hardware.usb.host";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports connecting to USB accessories.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_USB_ACCESSORY = "android.hardware.usb.accessory";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The SIP API is enabled on the device.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SIP = "android.software.sip";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports SIP-based VOIP.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SIP_VOIP = "android.software.sip.voip";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The Connection Service API is enabled on the device.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_CONNECTION_SERVICE = "android.software.connectionservice";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's display has a touch screen.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TOUCHSCREEN = "android.hardware.touchscreen";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's touch screen supports
         * multitouch sufficient for basic two-finger gesture detection.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TOUCHSCREEN_MULTITOUCH = "android.hardware.touchscreen.multitouch";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's touch screen is capable of
         * tracking two or more fingers fully independently.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT = "android.hardware.touchscreen.multitouch.distinct";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device's touch screen is capable of
         * tracking a full hand of fingers fully independently -- that is, 5 or
         * more simultaneous independent pointers.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND = "android.hardware.touchscreen.multitouch.jazzhand";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device does not have a touch screen, but
         * does support touch emulation for basic events. For instance, the
         * device might use a mouse or remote control to drive a cursor, and
         * emulate basic touch pointer events like down, up, drag, etc. All
         * devices that support android.hardware.touchscreen or a sub-feature are
         * presumed to also support faketouch.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_FAKETOUCH = "android.hardware.faketouch";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device does not have a touch screen, but
         * does support touch emulation for basic events that supports distinct
         * tracking of two or more fingers.  This is an extension of
         * {@link #FEATURE_FAKETOUCH} for input devices with this capability.  Note
         * that unlike a distinct multitouch screen as defined by
         * {@link #FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT}, these kinds of input
         * devices will not actually provide full two-finger gestures since the
         * input is being transformed to cursor movement on the screen.  That is,
         * single finger gestures will move a cursor; two-finger swipes will
         * result in single-finger touch events; other two-finger gestures will
         * result in the corresponding two-finger touch event.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT = "android.hardware.faketouch.multitouch.distinct";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device does not have a touch screen, but
         * does support touch emulation for basic events that supports tracking
         * a hand of fingers (5 or more fingers) fully independently.
         * This is an extension of
         * {@link #FEATURE_FAKETOUCH} for input devices with this capability.  Note
         * that unlike a multitouch screen as defined by
         * {@link #FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND}, not all two finger
         * gestures can be detected due to the limitations described for
         * {@link #FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT}.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND = "android.hardware.faketouch.multitouch.jazzhand";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports portrait orientation
         * screens.  For backwards compatibility, you can assume that if neither
         * this nor {@link #FEATURE_SCREEN_LANDSCAPE} is set then the device supports
         * both portrait and landscape.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports landscape orientation
         * screens.  For backwards compatibility, you can assume that if neither
         * this nor {@link #FEATURE_SCREEN_PORTRAIT} is set then the device supports
         * both portrait and landscape.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports live wallpapers.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LIVE_WALLPAPER = "android.software.live_wallpaper";
        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports app widgets.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_APP_WIDGETS = "android.software.app_widgets";

        /**
         * @hide
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports
         * {@link android.service.voice.VoiceInteractionService} and
         * {@link android.app.VoiceInteractor}.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_VOICE_RECOGNIZERS = "android.software.voice_recognizers";


        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports a home screen that is replaceable
         * by third party applications.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_HOME_SCREEN = "android.software.home_screen";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports adding new input methods implemented
         * with the {@link android.inputmethodservice.InputMethodService} API.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_INPUT_METHODS = "android.software.input_methods";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports device policy enforcement via device admins.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_DEVICE_ADMIN = "android.software.device_admin";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports leanback UI. This is
         * typically used in a living room television experience, but is a software
         * feature unlike {@link #FEATURE_TELEVISION}. Devices running with this
         * feature will use resources associated with the "television" UI mode.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LEANBACK = "android.software.leanback";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports only leanback UI. Only
         * applications designed for this experience should be run, though this is
         * not enforced by the system.
         * @hide
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LEANBACK_ONLY = "android.software.leanback_only";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports live TV and can display
         * contents from TV inputs implemented with the
         * {@link android.media.tv.TvInputService} API.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_LIVE_TV = "android.software.live_tv";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports WiFi (802.11) networking.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_WIFI = "android.hardware.wifi";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: The device supports Wi-Fi Direct networking.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_WIFI_DIRECT = "android.hardware.wifi.direct";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: This is a device dedicated to showing UI
         * on a television.  Television here is defined to be a typical living
         * room television experience: displayed on a big screen, where the user
         * is sitting far away from it, and the dominant form of input will be
         * something like a DPAD, not through touch or mouse.
         * @deprecated use {@link #FEATURE_LEANBACK} instead.
         */
        //@Deprecated
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_TELEVISION = "android.hardware.type.television";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: This is a device dedicated to showing UI
         * on a watch. A watch here is defined to be a device worn on the body, perhaps on
         * the wrist. The user is very close when interacting with the device.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_WATCH = "android.hardware.type.watch";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device supports printing.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_PRINTING = "android.software.print";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device can perform backup and restore operations on installed applications.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_BACKUP = "android.software.backup";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device supports creating secondary users and managed profiles via
         * {@link DevicePolicyManager}.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_MANAGED_USERS = "android.software.managed_users";

        /**
         * @hide
         * TODO: Remove after dependencies updated b/17392243
         */
        const String FEATURE_MANAGED_PROFILES = "android.software.managed_users";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device supports verified boot.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_VERIFIED_BOOT = "android.software.verified_boot";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device supports secure removal of users. When a user is deleted the data associated
         * with that user is securely deleted and no longer available.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_SECURELY_REMOVES_USERS
                = "android.software.securely_removes_users";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device has a full implementation of the android.webkit.* APIs. Devices
         * lacking this feature will not have a functioning WebView implementation.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_WEBVIEW = "android.software.webview";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: This device supports ethernet.
         * @hide
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_ETHERNET = "android.hardware.ethernet";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and
         * {@link #hasSystemFeature}: This device supports HDMI-CEC.
         * @hide
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_HDMI_CEC = "android.hardware.hdmi.cec";

        /**
         * Feature for {@link #getSystemAvailableFeatures} and {@link #hasSystemFeature}:
         * The device has all of the inputs necessary to be considered a compatible game controller, or
         * includes a compatible game controller in the box.
         */
        //@SdkConstant(SdkConstantType.FEATURE)
        const String FEATURE_GAMEPAD = "android.hardware.gamepad";


        /**
         * Action to external storage service to clean out removed apps.
         * @hide
         */
        const String ACTION_CLEAN_EXTERNAL_STORAGE
                = "android.content.pm.CLEAN_EXTERNAL_STORAGE";

        /**
         * Extra field name for the URI to a verification file. Passed to a package
         * verifier.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_URI = "android.content.pm.extra.VERIFICATION_URI";

        /**
         * Extra field name for the ID of a package pending verification. Passed to
         * a package verifier and is used to call back to
         * {@link PackageManager#verifyPendingInstall(int, int)}
         */
        const String EXTRA_VERIFICATION_ID = "android.content.pm.extra.VERIFICATION_ID";

        /**
         * Extra field name for the package identifier which is trying to install
         * the package.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_INSTALLER_PACKAGE
                = "android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE";

        /**
         * Extra field name for the requested install flags for a package pending
         * verification. Passed to a package verifier.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_INSTALL_FLAGS
                = "android.content.pm.extra.VERIFICATION_INSTALL_FLAGS";

        /**
         * Extra field name for the uid of who is requesting to install
         * the package.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_INSTALLER_UID
                = "android.content.pm.extra.VERIFICATION_INSTALLER_UID";

        /**
         * Extra field name for the package name of a package pending verification.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_PACKAGE_NAME
                = "android.content.pm.extra.VERIFICATION_PACKAGE_NAME";
        /**
         * Extra field name for the result of a verification, either
         * {@link #VERIFICATION_ALLOW}, or {@link #VERIFICATION_REJECT}.
         * Passed to package verifiers after a package is verified.
         */
        const String EXTRA_VERIFICATION_RESULT
                = "android.content.pm.extra.VERIFICATION_RESULT";

        /**
         * Extra field name for the version code of a package pending verification.
         *
         * @hide
         */
        const String EXTRA_VERIFICATION_VERSION_CODE
                = "android.content.pm.extra.VERIFICATION_VERSION_CODE";

        /**
         * The action used to request that the user approve a permission request
         * from the application.
         *
         * @hide
         */
        const String ACTION_REQUEST_PERMISSION
                = "android.content.pm.action.REQUEST_PERMISSION";

        /**
         * Extra field name for the list of permissions, which the user must approve.
         *
         * @hide
         */
        const String EXTRA_REQUEST_PERMISSION_PERMISSION_LIST
                = "android.content.pm.extra.PERMISSION_LIST";

        /**
         * String extra for {@link PackageInstallObserver} in the 'extras' Bundle in case of
         * {@link #INSTALL_FAILED_DUPLICATE_PERMISSION}.  This extra names the package which provides
         * the existing definition for the permission.
         * @hide
         */
        const String EXTRA_FAILURE_EXISTING_PACKAGE
                = "android.content.pm.extra.FAILURE_EXISTING_PACKAGE";

        /**
         * String extra for {@link PackageInstallObserver} in the 'extras' Bundle in case of
         * {@link #INSTALL_FAILED_DUPLICATE_PERMISSION}.  This extra names the permission that is
         * being redundantly defined by the package being installed.
         * @hide
         */
        const String EXTRA_FAILURE_EXISTING_PERMISSION
                = "android.content.pm.extra.FAILURE_EXISTING_PERMISSION";

        /**
         * Retrieve overall information about an application package that is
         * installed on the system.
         * <p>
         * Throws NameNotFoundException if a package with the given name can
         * not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of the
         *            desired package.
         * @param flags Additional option flags. Use any combination of
         *            #GET_ACTIVITIES, #GET_GIDS,
         *            #GET_CONFIGURATIONS, #GET_INSTRUMENTATION,
         *            #GET_PERMISSIONS, #GET_PROVIDERS,
         *            #GET_RECEIVERS, #GET_SERVICES,
         *            #GET_SIGNATURES, #GET_UNINSTALLED_PACKAGES to
         *            modify the data returned.
         *
         * @sa #GET_ACTIVITIES
         * @sa #GET_GIDS
         * @sa #GET_CONFIGURATIONS
         * @sa #GET_INSTRUMENTATION
         * @sa #GET_PERMISSIONS
         * @sa #GET_PROVIDERS
         * @sa #GET_RECEIVERS
         * @sa #GET_SERVICES
         * @sa #GET_SIGNATURES
         * @sa #GET_UNINSTALLED_PACKAGES
         * @return Returns a PackageInfo object containing information about the
         *         package. If flag GET_UNINSTALLED_PACKAGES is set and if the
         *         package is not found in the list of installed applications, the
         *         package information is retrieved from the list of uninstalled
         *         applications(which includes installed applications as well as
         *         applications with data directory ie applications which had been
         *         deleted with DONT_DELTE_DATA flag set).
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetPackageInfo(
            [in] String packageName,
            [in] Int32 flags,
            [out] IPackageInfo** info);

        /**
         * Map from the current package names in use on the device to whatever
         * the current canonical name of that package is.
         * @param names Array of current names to be mapped.
         * @return Returns an array of the same size as the original, containing
         * the canonical name for each package.
         */
        CurrentToCanonicalPackageNames(
            [in] ArrayOf<String> cuNames,
            [out, callee] ArrayOf<String>* caNames);

        /**
         * Map from a packages canonical name to the current name in use on the device.
         * @param names Array of new names to be mapped.
         * @return Returns an array of the same size as the original, containing
         * the current name for each package.
         */
        CanonicalToCurrentPackageNames(
            [in] ArrayOf<String> caNames,
            [out, callee] ArrayOf<String>* cuNames);

        /**
         * Return a "good" intent to launch a front-door activity in a package,
         * for use for example to implement an "open" button when browsing through
         * packages.  The current implementation will look first for a main
         * activity in the category Intent#CATEGORY_INFO, next for a
         * main activity in the category Intent#CATEGORY_LAUNCHER, or return
         * null if neither are found.
         *
         * @sa Intent#CATEGORY_INFO
         * @sa Intent#CATEGORY_LAUNCHER
         *
         * <p>Throws NameNotFoundException if a package with the given
         * name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param packageName The name of the package to inspect.
         *
         * @return Returns either a fully-qualified Intent that can be used to
         * launch the main activity in the package, or null if the package does
         * not contain such an activity.
         */
        GetLaunchIntentForPackage(
            [in] String packageName,
            [out] IIntent** intent);

        /**
         * Return a "good" intent to launch a front-door Leanback activity in a
         * package, for use for example to implement an "open" button when browsing
         * through packages. The current implementation will look for a main
         * activity in the category {@link Intent#CATEGORY_LEANBACK_LAUNCHER}, or
         * return null if no main leanback activities are found.
         * <p>
         * Throws {@link NameNotFoundException} if a package with the given name
         * cannot be found on the system.
         *
         * @param packageName The name of the package to inspect.
         * @return Returns either a fully-qualified Intent that can be used to launch
         *         the main Leanback activity in the package, or null if the package
         *         does not contain such an activity.
         */
        GetLeanbackLaunchIntentForPackage(
            [in] String packageName,
            [out] IIntent** intent);

        /**
         * Return an array of all of the secondary group-ids that have been
         * assigned to a package.
         *
         * <p>Throws NameNotFoundException if a package with the given
         * name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of the
         *                    desired package.
         *
         * @return Returns an int array of the assigned gids, or null if there
         * are none.
         */
        GetPackageGids(
            [in] String packageName,
            [out, callee] ArrayOf<Int32>* gids);

        /**
         * @hide Return the uid associated with the given package name for the
         * given user.
         *
         * <p>Throws {@link NameNotFoundException} if a package with the given
         * name can not be found on the system.
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of the
         *                    desired package.
         * @param userHandle The user handle identifier to look up the package under.
         *
         * @return Returns an integer uid who owns the given package name.
         */
        GetPackageUid(
            [in] String packageName,
            [in] Int32 userHandle,
            [out] Int32* id);

        /**
         * Retrieve all of the information we know about a particular permission.
         *
         * <p>Throws NameNotFoundException if a permission with the given
         * name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param name The fully qualified name (i.e. com.google.permission.LOGIN)
         *             of the permission you are interested in.
         * @param flags Additional option flags.  Use #GET_META_DATA to
         * retrieve any meta-data associated with the permission.
         *
         * @sa #GET_META_DATA
         *
         * @return Returns a PermissionInfo containing information about the
         *         permission.
         *
         * @sa PermissionInfo
         */
        GetPermissionInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionInfo** info);

        /**
         * Query for all of the permissions associated with a particular group.
         *
         * <p>Throws NameNotFoundException if the given group does not
         * exist.
         *
         * @sa NameNotFoundException
         *
         * @param group The fully qualified name (i.e. com.google.permission.LOGIN)
         *             of the permission group you are interested in.  Use null to
         *             find all of the permissions not associated with a group.
         * @param flags Additional option flags.  Use #GET_META_DATA to
         * retrieve any meta-data associated with the permissions.
         *
         * @sa #GET_META_DATA
         *
         * @return Returns a list of PermissionInfo containing information
         * about all of the permissions in the given group.
         *
         * @sa PermissionInfo
         */
        QueryPermissionsByGroup(
            [in] String group,
            [in] Int32 flags,
            [out] IList** permissions);

        /**
         * Retrieve all of the information we know about a particular group of
         * permissions.
         *
         * <p>Throws NameNotFoundException if a permission group with the given
         * name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param name The fully qualified name (i.e. com.google.permission_group.APPS)
         *             of the permission you are interested in.
         * @param flags Additional option flags.  Use #GET_META_DATA to
         * retrieve any meta-data associated with the permission group.
         *
         * @sa #GET_META_DATA
         *
         * @return Returns a PermissionGroupInfo containing information
         * about the permission.
         *
         * @sa PermissionGroupInfo
         */
        GetPermissionGroupInfo(
            [in] String name,
            [in] Int32 flags,
            [out] IPermissionGroupInfo** info);

        /**
         * Retrieve all of the known permission groups in the system.
         *
         * @param flags Additional option flags.  Use #GET_META_DATA to
         * retrieve any meta-data associated with the permission group.
         *
         * @sa #GET_META_DATA
         *
         * @return Returns a list of PermissionGroupInfo containing
         * information about all of the known permission groups.
         *
         * @sa PermissionGroupInfo
         */
        GetAllPermissionGroups(
            [in] Int32 flags,
            [out] IList** groups);

        /**
         * Retrieve all of the information we know about a particular
         * package/application.
         *
         * <p>Throws NameNotFoundException if an application with the given
         * package name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param packageName The full name (i.e. com.google.apps.contacts) of an
         *                    application.
         * @param flags Additional option flags. Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * #GET_UNINSTALLED_PACKAGES to modify the data returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES
         * @sa #GET_UNINSTALLED_PACKAGES
         *
         * @return  ApplicationInfo Returns ApplicationInfo object containing
         *         information about the package.
         *         If flag GET_UNINSTALLED_PACKAGES is set and  if the package is not
         *         found in the list of installed applications,
         *         the application information is retrieved from the
         *         list of uninstalled applications(which includes
         *         installed applications as well as applications
         *         with data directory ie applications which had been
         *         deleted with DONT_DELTE_DATA flag set).
         *
         * @sa ApplicationInfo
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetApplicationInfo(
            [in] String packageName,
            [in] Int32 flags,
            [out] IApplicationInfo** info);

        /**
         * Retrieve all of the information we know about a particular activity
         * class.
         *
         * <p>Throws NameNotFoundException if an activity with the given
         * class name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param component The full component name (i.e.
         * com.google.apps.contacts/com.google.apps.contacts.ContactsList) of an Activity
         * class.
         * @param flags Additional option flags. Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * to modify the data (in ApplicationInfo) returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES
         *
         * @return ActivityInfo containing information about the activity.
         *
         * @sa ActivityInfo
         * @see #GET_INTENT_FILTERS
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetActivityInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** info);

        /**
         * Retrieve all of the information we know about a particular receiver
         * class.
         *
         * <p>Throws NameNotFoundException if a receiver with the given
         * class name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param component The full component name (i.e.
         * com.google.apps.calendar/com.google.apps.calendar.CalendarAlarm) of a Receiver
         * class.
         * @param flags Additional option flags.  Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * to modify the data returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES
         *
         * @return ActivityInfo containing information about the receiver.
         *
         * @sa ActivityInfo
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetReceiverInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IActivityInfo** info);

        /**
         * Retrieve all of the information we know about a particular service
         * class.
         *
         * <p>Throws NameNotFoundException if a service with the given
         * class name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param component The full component name (i.e.
         * com.google.apps.media/com.google.apps.media.BackgroundPlayback) of a Service
         * class.
         * @param flags Additional option flags.  Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * to modify the data returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES
         *
         * @return ServiceInfo containing information about the service.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetServiceInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IServiceInfo** info);

        /**
         * Retrieve all of the information we know about a particular content
         * provider class.
         *
         * <p>Throws NameNotFoundException if a provider with the given
         * class name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param component The full component name (i.e.
         * com.google.providers.media/com.google.providers.media.MediaProvider) of a
         * ContentProvider class.
         * @param flags Additional option flags.  Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * to modify the data returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES

         *
         * @return ProviderInfo containing information about the service.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         */
        GetProviderInfo(
            [in] IComponentName* component,
            [in] Int32 flags,
            [out] IProviderInfo** info);

        /**
         * Return a List of all packages that are installed
         * on the device.
         *
         * @param flags Additional option flags. Use any combination of
         * #GET_ACTIVITIES,
         * #GET_GIDS,
         * #GET_CONFIGURATIONS,
         * #GET_INSTRUMENTATION,
         * #GET_PERMISSIONS,
         * #GET_PROVIDERS,
         * #GET_RECEIVERS,
         * #GET_SERVICES,
         * #GET_SIGNATURES,
         * #GET_UNINSTALLED_PACKAGES to modify the data returned.
         *
         * @sa #GET_ACTIVITIES
         * @sa #GET_GIDS
         * @sa #GET_CONFIGURATIONS
         * @sa #GET_INSTRUMENTATION
         * @sa #GET_PERMISSIONS
         * @sa #GET_PROVIDERS
         * @sa #GET_RECEIVERS
         * @sa #GET_SERVICES
         * @sa #GET_SIGNATURES
         * @sa #GET_UNINSTALLED_PACKAGES
         *
         * @return A List of PackageInfo objects, one for each package that is
         *         installed on the device.  In the unlikely case of there being no
         *         installed packages, an empty list is returned.
         *         If flag GET_UNINSTALLED_PACKAGES is set, a list of all
         *         applications including those deleted with DONT_DELETE_DATA
         *         (partially installed apps with data directory) will be returned.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         *
         */
        GetInstalledPackages(
            [in] Int32 flags,
            [out] IList** infos);

        /**
         * Return a List of all installed packages that are currently
         * holding any of the given permissions.
         *
         * @param flags Additional option flags. Use any combination of
         * {@link #GET_ACTIVITIES},
         * {@link #GET_GIDS},
         * {@link #GET_CONFIGURATIONS},
         * {@link #GET_INSTRUMENTATION},
         * {@link #GET_PERMISSIONS},
         * {@link #GET_PROVIDERS},
         * {@link #GET_RECEIVERS},
         * {@link #GET_SERVICES},
         * {@link #GET_SIGNATURES},
         * {@link #GET_UNINSTALLED_PACKAGES} to modify the data returned.
         *
         * @return Returns a List of PackageInfo objects, one for each installed
         * application that is holding any of the permissions that were provided.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetPackagesHoldingPermissions(
            [in] ArrayOf<String>* permissions,
            [in] Int32 flags,
            [out] IList** infos);

        /**
         * Return a List of all packages that are installed on the device, for a specific user.
         * Requesting a list of installed packages for another user
         * will require the permission INTERACT_ACROSS_USERS_FULL.
         * @param flags Additional option flags. Use any combination of
         * #GET_ACTIVITIES,
         * #GET_GIDS,
         * #GET_CONFIGURATIONS,
         * #GET_INSTRUMENTATION,
         * #GET_PERMISSIONS,
         * #GET_PROVIDERS,
         * #GET_RECEIVERS,
         * #GET_SERVICES,
         * #GET_SIGNATURES,
         * #GET_UNINSTALLED_PACKAGES to modify the data returned.
         *
         * @sa #GET_ACTIVITIES
         * @sa #GET_GIDS
         * @sa #GET_CONFIGURATIONS
         * @sa #GET_INSTRUMENTATION
         * @sa #GET_PERMISSIONS
         * @sa #GET_PROVIDERS
         * @sa #GET_RECEIVERS
         * @sa #GET_SERVICES
         * @sa #GET_SIGNATURES
         * @sa #GET_UNINSTALLED_PACKAGES
         * @param userId The user for whom the installed packages are to be listed
         *
         * @return A List of PackageInfo objects, one for each package that is
         *         installed on the device.  In the unlikely case of there being no
         *         installed packages, an empty list is returned.
         *         If flag GET_UNINSTALLED_PACKAGES is set, a list of all
         *         applications including those deleted with DONT_DELETE_DATA
         *         (partially installed apps with data directory) will be returned.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         * @see #GET_UNINSTALLED_PACKAGES
         *
         * @hide
         */
        GetInstalledPackages(
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IList** infos);

        /**
         * Check whether a particular package has been granted a particular
         * permission.
         *
         * @param permName The name of the permission you are checking for,
         * @param pkgName The name of the package you are checking against.
         *
         * @return If the package has the permission, PERMISSION_GRANTED is
         * returned.  If it does not have the permission, PERMISSION_DENIED
         * is returned.
         *
         * @see #PERMISSION_GRANTED
         * @see #PERMISSION_DENIED
         */
        CheckPermission(
            [in] String permName,
            [in] String pkgName,
            [out] Int32* result);

        /**
         * Add a new dynamic permission to the system.  For this to work, your
         * package must have defined a permission tree through the
         * android.R.styleable#AndroidManifestPermissionTree &lt;permission-tree&gt;
         *  tag in its manifest.  A package can only add
         * permissions to trees that were defined by either its own package or
         * another with the same user id; a permission is in a tree if it
         * matches the name of the permission tree + ".": for example,
         * "com.foo.bar" is a member of the permission tree "com.foo".
         *
         * @sa android.R.styleable#AndroidManifestPermissionTree &lt;permission-tree&gt;
         *
         * <p>It is good to make your permission tree name descriptive, because you
         * are taking possession of that entire set of permission names.  Thus, it
         * must be under a domain you control, with a suffix that will not match
         * any normal permissions that may be declared in any applications that
         * are part of that domain.
         *
         * <p>New permissions must be added before
         * any .apks are installed that use those permissions.  Permissions you
         * add through this method are remembered across reboots of the device.
         * If the given permission already exists, the info you supply here
         * will be used to update it.
         *
         * @param info Description of the permission to be added.
         *
         * @return Returns true if a new permission was created, false if an
         * existing one was updated.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * SecurityException | if you are not allowed to add the given permission name.
         *
         * @see #removePermission(String)
         */
        AddPermission(
            [in] IPermissionInfo* info,
            [out] Boolean* result);

        /**
         * Like #addPermission(PermissionInfo) but asynchronously
         * persists the package manager state after returning from the call,
         * allowing it to return quicker and batch a series of adds at the
         * expense of no guarantee the added permission will be retained if
         * the device is rebooted before it is written.
         *
         * @sa #addPermission(PermissionInfo)
         */
        AddPermissionAsync(
            [in] IPermissionInfo* info,
            [out] Boolean* result);

        /**
         * Removes a permission that was previously added with
         * #addPermission(PermissionInfo).  The same ownership rules apply
         * -- you are only allowed to remove permissions that you are allowed
         * to add.
         *
         * @sa #addPermission(PermissionInfo)
         *
         * @param name The name of the permission to remove.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * SecurityException | if you are not allowed to remove the given permission name.
         *
         * @see #addPermission(PermissionInfo)
         */
        RemovePermission(
            [in] String name);

        /**
         * Returns an {@link Intent} suitable for passing to {@code startActivityForResult}
         * which prompts the user to grant {@code permissions} to this application.
         * @hide
         *
         * @throws NullPointerException if {@code permissions} is {@code null}.
         * @throws IllegalArgumentException if {@code permissions} contains {@code null}.
         */
        BuildPermissionRequestIntent(
            [in] ArrayOf<String>* permissions,
            [out] IIntent** intent);

        /**
         * Grant a permission to an application which the application does not
         * already have.  The permission must have been requested by the application,
         * but as an optional permission.  If the application is not allowed to
         * hold the permission, a SecurityException is thrown.
         * @hide
         *
         * @param packageName The name of the package that the permission will be
         * granted to.
         * @param permissionName The name of the permission.
         */
        GrantPermission(
            [in] String packageName,
            [in] String permissionName);

        /**
         * Revoke a permission that was previously granted by #grantPermission.
         *
         * @sa #grantPermission
         * @hide
         *
         * @param packageName The name of the package that the permission will be
         * granted to.
         * @param permissionName The name of the permission.
         */
        RevokePermission(
            [in] String packageName,
            [in] String permissionName);

        /**
         * Compare the signatures of two packages to determine if the same
         * signature appears in both of them.  If they do contain the same
         * signature, then they are allowed special privileges when working
         * with each other: they can share the same user-id, run instrumentation
         * against each other, etc.
         *
         * @param pkg1 First package name whose signature will be compared.
         * @param pkg2 Second package name whose signature will be compared.
         *
         * @return Returns an integer indicating whether all signatures on the
         * two packages match. The value is >= 0 (#SIGNATURE_MATCH) if
         * all signatures match or < 0 if there is not a match (
         * #SIGNATURE_NO_MATCH or #SIGNATURE_UNKNOWN_PACKAGE).
         *
         * @sa #SIGNATURE_MATCH
         * @sa #SIGNATURE_NO_MATCH
         * @sa #SIGNATURE_UNKNOWN_PACKAGE
         *
         * @see #checkSignatures(int, int)
         * @see #SIGNATURE_MATCH
         * @see #SIGNATURE_NO_MATCH
         * @see #SIGNATURE_UNKNOWN_PACKAGE
         */
        CheckSignatures(
            [in] String pkg1,
            [in] String pkg2,
            [out] Int32* result);

        /**
         * Like #checkSignatures(String, String), but takes UIDs of
         * the two packages to be checked.  This can be useful, for example,
         * when doing the check in an IPC, where the UID is the only identity
         * available.  It is functionally identical to determining the package
         * associated with the UIDs and checking their signatures.
         *
         * @sa #checkSignatures(String, String)
         *
         * @param uid1 First UID whose signature will be compared.
         * @param uid2 Second UID whose signature will be compared.
         *
         * @return Returns an integer indicating whether all signatures on the
         * two packages match. The value is >= 0 (#SIGNATURE_MATCH) if
         * all signatures match or < 0 if there is not a match (
         * #SIGNATURE_NO_MATCH or #SIGNATURE_UNKNOWN_PACKAGE).
         *
         * @sa #SIGNATURE_MATCH
         * @sa #SIGNATURE_NO_MATCH
         * @sa #SIGNATURE_UNKNOWN_PACKAGE
         *
         * @see #checkSignatures(String, String)
         * @see #SIGNATURE_MATCH
         * @see #SIGNATURE_NO_MATCH
         * @see #SIGNATURE_UNKNOWN_PACKAGE
         */
        CheckSignatures(
            [in] Int32 uid1,
            [in] Int32 uid2,
            [out] Int32* result);

        /**
         * Retrieve the names of all packages that are associated with a particular
         * user id.  In most cases, this will be a single package name, the package
         * that has been assigned that user id.  Where there are multiple packages
         * sharing the same user id through the "sharedUserId" mechanism, all
         * packages with that id will be returned.
         *
         * @param uid The user id for which you would like to retrieve the
         * associated packages.
         *
         * @return Returns an array of one or more packages assigned to the user
         * id, or null if there are no known packages with the given id.
         */
        GetPackagesForUid(
            [in] Int32 uid,
            [out, callee] ArrayOf<String>* packages);

        /**
         * Retrieve the official name associated with a user id.  This name is
         * guaranteed to never change, though it is possibly for the underlying
         * user id to be changed.  That is, if you are storing information about
         * user ids in persistent storage, you should use the string returned
         * by this function instead of the raw user-id.
         *
         * @param uid The user id for which you would like to retrieve a name.
         * @return Returns a unique name for the given user id, or null if the
         * user id is not currently assigned.
         */
        GetNameForUid(
            [in] Int32 uid,
            [out] String* name);

        /**
         * Return the user id associated with a shared user name. Multiple
         * applications can specify a shared user name in their manifest and thus
         * end up using a common uid. This might be used for new applications
         * that use an existing shared user name and need to know the uid of the
         * shared user.
         *
         * @param sharedUserName The shared user name whose uid is to be retrieved.
         * @return Returns the uid associated with the shared user, or  NameNotFoundException
         * if the shared user name is not being used by any installed packages
         * @hide
         */
        GetUidForSharedUser(
            [in] String sharedUserName,
            [out] Int32* uid);

        /**
         * Return a List of all application packages that are installed on the
         * device. If flag GET_UNINSTALLED_PACKAGES has been set, a list of all
         * applications including those deleted with DONT_DELETE_DATA(partially
         * installed apps with data directory) will be returned.
         *
         * @param flags Additional option flags. Use any combination of
         * #GET_META_DATA, #GET_SHARED_LIBRARY_FILES,
         * #GET_UNINSTALLED_PACKAGES to modify the data returned.
         *
         * @sa #GET_META_DATA
         * @sa #GET_SHARED_LIBRARY_FILES
         * @sa #GET_UNINSTALLED_PACKAGES
         *
         * @return A List of ApplicationInfo objects, one for each application that
         *         is installed on the device.  In the unlikely case of there being
         *         no installed applications, an empty list is returned.
         *         If flag GET_UNINSTALLED_PACKAGES is set, a list of all
         *         applications including those deleted with DONT_DELETE_DATA
         *         (partially installed apps with data directory) will be returned.
         *
         * @see #GET_META_DATA
         * @see #GET_SHARED_LIBRARY_FILES
         * @see #GET_UNINSTALLED_PACKAGES
         */
        GetInstalledApplications(
            [in] Int32 flags,
            [out] IList** apps);

        /**
         * Get a list of shared libraries that are available on the
         * system.
         *
         * @return An array of shared library names that are
         * available on the system, or null if none are installed.
         *
         */
        GetSystemSharedLibraryNames(
            [out, callee] ArrayOf<String>* names);

        /**
         * Get a list of features that are available on the
         * system.
         *
         * @return An array of FeatureInfo classes describing the features
         * that are available on the system, or null if there are none(!!).
         */
        GetSystemAvailableFeatures(
            [out, callee] ArrayOf<IFeatureInfo*>* features);

        /**
         * Check whether the given feature name is one of the available
         * features as returned by #getSystemAvailableFeatures().
         *
         * @sa #getSystemAvailableFeatures()
         *
         * @return Returns true if the devices supports the feature, else
         * false.
         */
        HasSystemFeature(
            [in] String name,
            [out] Boolean* result);

        /**
         * Determine the best action to perform for a given Intent.  This is how
         * Intent#resolveActivity finds an activity if a class has not
         * been explicitly specified.
         *
         * <p><em>Note:</em> if using an implicit Intent (without an explicit ComponentName
         * specified), be sure to consider whether to set the #MATCH_DEFAULT_ONLY
         * only flag.  You need to do so to resolve the activity in the same way
         * that android.content.Context#startActivity(Intent) and
         * android.content.Intent#resolveActivity(PackageManager)
         * Intent.resolveActivity(PackageManager) do.</p>
         *
         * @param intent An intent containing all of the desired specification
         *               (action, data, type, category, and/or component).
         * @param flags Additional option flags.  The most important is
         * #MATCH_DEFAULT_ONLY, to limit the resolution to only
         * those activities that support the android.content.Intent#CATEGORY_DEFAULT.
         *
         * @sa Intent#resolveActivity
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Context#startActivity(Intent)
         * @sa android.content.Intent#resolveActivity(PackageManager)
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Intent#CATEGORY_DEFAULT}.
         *
         * @return Returns a ResolveInfo containing the final activity intent that
         *         was determined to be the best action.  Returns null if no
         *         matching activity was found. If multiple matching activities are
         *         found and there is no default set, returns a ResolveInfo
         *         containing something else, such as the activity resolver.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        ResolveActivity(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IResolveInfo** resolve);

        /**
         * Determine the best action to perform for a given Intent for a given user. This
         * is how Intent#resolveActivity finds an activity if a class has not
         * been explicitly specified.
         *
         * <p><em>Note:</em> if using an implicit Intent (without an explicit ComponentName
         * specified), be sure to consider whether to set the #MATCH_DEFAULT_ONLY
         * only flag.  You need to do so to resolve the activity in the same way
         * that android.content.Context#startActivity(Intent) and
         * android.content.Intent#resolveActivity(PackageManager)
         * Intent.resolveActivity(PackageManager) do.</p>
         *
         * @sa Intent#resolveActivity
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Context#startActivity(Intent)
         * @sa android.content.Intent#resolveActivity(PackageManager) Intent.resolveActivity(PackageManager)
         *
         * @param intent An intent containing all of the desired specification
         *               (action, data, type, category, and/or component).
         * @param flags Additional option flags.  The most important is
         * #MATCH_DEFAULT_ONLY, to limit the resolution to only
         * those activities that support the android.content.Intent#CATEGORY_DEFAULT.
         *
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Intent#CATEGORY_DEFAULT
         * @param userId The user id.
         *
         * @return Returns a ResolveInfo containing the final activity intent that
         *         was determined to be the best action.  Returns null if no
         *         matching activity was found. If multiple matching activities are
         *         found and there is no default set, returns a ResolveInfo
         *         containing something else, such as the activity resolver.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         *
         * @hide
         */
        ResolveActivityAsUser(
            [in] IIntent* intent,
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IResolveInfo** resolve);

        /**
         * Retrieve all activities that can be performed for the given intent.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.  The most important is
         * #MATCH_DEFAULT_ONLY, to limit the resolution to only
         * those activities that support the android.content.Intent#CATEGORY_DEFAULT.
         *
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Intent#CATEGORY_DEFAULT
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Activity. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         #resolveActivity.  If there are no matching activities, an empty
         *         list is returned.
         *
         * @sa #resolveActivity
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentActivities(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IList** resolves);

        /**
         * Retrieve all activities that can be performed for the given intent, for a specific user.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.  The most important is
         * #MATCH_DEFAULT_ONLY, to limit the resolution to only
         * those activities that support the android.content.Intent#CATEGORY_DEFAULT.
         *
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Intent#CATEGORY_DEFAULT
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Activity. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         #resolveActivity.  If there are no matching activities, an empty
         *         list is returned.
         *
         * @sa #resolveActivity
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         * @hide
         */
        QueryIntentActivitiesAsUser(
            [in] IIntent* intent,
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IList** resolves);

        /**
         * Retrieve a set of activities that should be presented to the user as
         * similar options.  This is like #queryIntentActivities, except it
         * also allows you to supply a list of more explicit Intents that you would
         * like to resolve to particular options, and takes care of returning the
         * final ResolveInfo list in a reasonable order, with no duplicates, based
         * on those inputs.
         *
         * @sa #queryIntentActivities
         *
         * @param caller The class name of the activity that is making the
         *               request.  This activity will never appear in the output
         *               list.  Can be null.
         * @param specifics An array of Intents that should be resolved to the
         *                  first specific results.  Can be null.
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.  The most important is
         * #MATCH_DEFAULT_ONLY, to limit the resolution to only
         * those activities that support the android.content.Intent#CATEGORY_DEFAULT.
         *
         * @sa #MATCH_DEFAULT_ONLY
         * @sa android.content.Intent#CATEGORY_DEFAULT
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Activity. These are ordered first by all of the intents resolved
         *         in <var>specifics</var> and then any additional activities that
         *         can handle <var>intent</var> but did not get included by one of
         *         the <var>specifics</var> intents.  If there are no matching
         *         activities, an empty list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentActivityOptions(
            [in] IComponentName* caller,
            [in] ArrayOf<IIntent*>* specifics,
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IList** resolves);

        /**
         * Retrieve all receivers that can handle a broadcast of the given intent.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Receiver. These are ordered from first to last in priority.  If
         *         there are no matching receivers, an empty list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryBroadcastReceivers(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IList** resolves);

        /**
         * Retrieve all receivers that can handle a broadcast of the given intent, for a specific
         * user.
         *
         * @param intent The desired intent as per resolveActivity().
         * @param flags Additional option flags.
         * @param userId The userId of the user being queried.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         Receiver. These are ordered from first to last in priority.  If
         *         there are no matching receivers, an empty list is returned.
         *
         * @see #MATCH_DEFAULT_ONLY
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         * @hide
         */
        QueryBroadcastReceivers(
            [in] IIntent* intent,
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IList** resolves);

        /**
         * Determine the best service to handle for a given Intent.
         *
         * @param intent An intent containing all of the desired specification
         *               (action, data, type, category, and/or component).
         * @param flags Additional option flags.
         *
         * @return Returns a ResolveInfo containing the final service intent that
         *         was determined to be the best action.  Returns null if no
         *         matching service was found.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        ResolveService(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IResolveInfo** resolve);

        /**
         * Retrieve all services that can match the given intent.
         *
         * @param intent The desired intent as per resolveService().
         * @param flags Additional option flags.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         ServiceInfo. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         resolveService().  If there are no matching services, an empty
         *         list is returned.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         */
        QueryIntentServices(
            [in] IIntent* intent,
            [in] Int32 flags,
            [out] IList** resolves);

        /**
         * Retrieve all services that can match the given intent for a given user.
         *
         * @param intent The desired intent as per resolveService().
         * @param flags Additional option flags.
         * @param userId The user id.
         *
         * @return A List&lt;ResolveInfo&gt; containing one entry for each matching
         *         ServiceInfo. These are ordered from best to worst match -- that
         *         is, the first item in the list is what is returned by
         *         resolveService().  If there are no matching services, an empty
         *         list is returned.
         *
         * @see #GET_INTENT_FILTERS
         * @see #GET_RESOLVED_FILTER
         *
         * @hide
         */
        QueryIntentServicesAsUser(
            [in] IIntent* intent,
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IList** resolves);

        /** {@hide} */
        QueryIntentContentProvidersAsUser(
            [in] IIntent* intent,
            [in] Int32 flags,
            [in] Int32 userId,
            [out] IList** resolves);

        /**
         * Find a single content provider by its base path name.
         *
         * @param name The name of the provider to find.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return ContentProviderInfo Information about the provider, if found,
         *         else null.
         */
        ResolveContentProvider(
            [in] String name,
            [in] Int32 flags,
            [out] IProviderInfo** provider);

        /**
         * Retrieve content provider information.
         *
         * <p><em>Note: unlike most other methods, an empty result set is indicated
         * by a null return instead of an empty list.</em>
         *
         * @param processName If non-null, limits the returned providers to only
         *                    those that are hosted by the given process.  If null,
         *                    all content providers are returned.
         * @param uid If <var>processName</var> is non-null, this is the required
         *        uid owning the requested content providers.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return A List&lt;ContentProviderInfo&gt; containing one entry for each
         *         content provider either patching <var>processName</var> or, if
         *         <var>processName</var> is null, all known content providers.
         *         <em>If there are no matching providers, null is returned.</em>
         */
        QueryContentProviders(
            [in] String processName,
            [in] Int32 uid,
            [in] Int32 flags,
            [out] IList** providers);

        /**
         * Retrieve all of the information we know about a particular
         * instrumentation class.
         *
         * <p>Throws NameNotFoundException if instrumentation with the
         * given class name can not be found on the system.
         *
         * @sa NameNotFoundException
         *
         * @param className The full name (i.e.
         *                  com.google.apps.contacts.InstrumentList) of an
         *                  Instrumentation class.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return InstrumentationInfo containing information about the
         *         instrumentation.
         */
        GetInstrumentationInfo(
            [in] IComponentName* className,
            [in] Int32 flags,
            [out] IInstrumentationInfo** instrumentation);

        /**
         * Retrieve information about available instrumentation code.  May be used
         * to retrieve either all instrumentation code, or only the code targeting
         * a particular package.
         *
         * @param targetPackage If null, all instrumentation is returned; only the
         *                      instrumentation targeting this package name is
         *                      returned.
         * @param flags Additional option flags.  Currently should always be 0.
         *
         * @return A List&lt;InstrumentationInfo&gt; containing one entry for each
         *         matching available Instrumentation.  Returns an empty list if
         *         there is no instrumentation available for the given package.
         */
        QueryInstrumentation(
            [in] String targetPackage,
            [in] Int32 flags,
            [out] IList** instrumentations);

        /**
         * Retrieve an image from a package.  This is a low-level API used by
         * the various package manager info structures (such as
         * ComponentInfo to implement retrieval of their associated
         * icon.
         *
         * @sa ComponentInfo
         *
         * @param packageName The name of the package that this icon is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired image.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns a Drawable holding the requested image.  Returns null if
         * an image could not be found for any reason.
         */
        GetDrawable(
            [in] String packageName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] IDrawable** drawable);

        /**
         * Retrieve the icon associated with an activity.  Given the full name of
         * an activity, retrieves the information about it and calls
         * ComponentInfo#loadIcon ComponentInfo.loadIcon() to return its icon.
         *
         * @sa ComponentInfo#loadIcon ComponentInfo.loadIcon()
         * If the activity can not be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose icon is to be retrieved.
         *
         * @return Returns the image of the icon, or the default activity icon if
         * it could not be found.  Does not return null.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given activity could not be loaded.
         *
         * @see #getActivityIcon(Intent)
         */
        GetActivityIcon(
            [in] IComponentName* activityName,
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an Intent.  If intent.getClassName() is
         * set, this simply returns the result of
         * getActivityIcon(intent.getClassName()).  Otherwise it resolves the intent's
         * component and returns the icon associated with the resolved component.
         * If intent.getClassName() can not be found or the Intent can not be resolved
         * to a component, NameNotFoundException is thrown.
         *
         * @param intent The intent for which you would like to retrieve an icon.
         *
         * @return Returns the image of the icon, or the default activity icon if
         * it could not be found.  Does not return null.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for application matching the given intent could not be loaded.
         *
         * @see #getActivityIcon(ComponentName)
         */
        GetActivityIcon(
            [in] IIntent* intent,
            [out] IDrawable** icon);

        /**
         * Retrieve the banner associated with an activity. Given the full name of
         * an activity, retrieves the information about it and calls
         * {@link ComponentInfo#loadIcon ComponentInfo.loadIcon()} to return its
         * banner. If the activity cannot be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose banner is to be retrieved.
         * @return Returns the image of the banner, or null if the activity has no
         *         banner specified.
         * @throws NameNotFoundException Thrown if the resources for the given
         *             activity could not be loaded.
         * @see #getActivityBanner(Intent)
         */
        GetActivityBanner(
            [in] IComponentName* activityName,
            [out] IDrawable** icon);

        /**
         * Retrieve the banner associated with an Intent. If intent.getClassName()
         * is set, this simply returns the result of
         * getActivityBanner(intent.getClassName()). Otherwise it resolves the
         * intent's component and returns the banner associated with the resolved
         * component. If intent.getClassName() cannot be found or the Intent cannot
         * be resolved to a component, NameNotFoundException is thrown.
         *
         * @param intent The intent for which you would like to retrieve a banner.
         * @return Returns the image of the banner, or null if the activity has no
         *         banner specified.
         * @throws NameNotFoundException Thrown if the resources for application
         *             matching the given intent could not be loaded.
         * @see #getActivityBanner(ComponentName)
         */
        GetActivityBanner(
            [in] IIntent* intent,
            [out] IDrawable** icon);

        /**
         * Return the generic icon for an activity that is used when no specific
         * icon is defined.
         *
         * @return Drawable Image of the icon.
         */
        GetDefaultActivityIcon(
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an application.  If it has not defined
         * an icon, the default app icon is returned.  Does not return null.
         *
         * @param info Information about application being queried.
         *
         * @return Returns the image of the icon, or the default application icon
         * if it could not be found.
         *
         * @see #getApplicationIcon(String)
         */
        GetApplicationIcon(
            [in] IApplicationInfo* info,
            [out] IDrawable** icon);

        /**
         * Retrieve the icon associated with an application.  Given the name of the
         * application's package, retrieves the information about it and calls
         * getApplicationIcon() to return its icon. If the application can not be
         * found, NameNotFoundException is thrown.
         *
         * @param packageName Name of the package whose application icon is to be
         *                    retrieved.
         *
         * @return Returns the image of the icon, or the default application icon
         * if it could not be found.  Does not return null.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given application could not be loaded.
         *
         * @see #getApplicationIcon(ApplicationInfo)
         */
        GetApplicationIcon(
            [in] String packageName,
            [out] IDrawable** icon);

        /**
         * Retrieve the banner associated with an application.
         *
         * @param info Information about application being queried.
         * @return Returns the image of the banner or null if the application has no
         *         banner specified.
         * @see #getApplicationBanner(String)
         */
        GetApplicationBanner(
            [in] IApplicationInfo* info,
            [out] IDrawable** icon);

        /**
         * Retrieve the banner associated with an application. Given the name of the
         * application's package, retrieves the information about it and calls
         * getApplicationIcon() to return its banner. If the application cannot be
         * found, NameNotFoundException is thrown.
         *
         * @param packageName Name of the package whose application banner is to be
         *            retrieved.
         * @return Returns the image of the banner or null if the application has no
         *         banner specified.
         * @throws NameNotFoundException Thrown if the resources for the given
         *             application could not be loaded.
         * @see #getApplicationBanner(ApplicationInfo)
         */
        GetApplicationBanner(
            [in] String packageName,
            [out] IDrawable** icon);

        /**
         * Retrieve the logo associated with an activity.  Given the full name of
         * an activity, retrieves the information about it and calls
         * ComponentInfo#loadLogo ComponentInfo.loadLogo() to return its logo.
         * If the activity can not be found, NameNotFoundException is thrown.
         *
         * @sa ComponentInfo#loadLogo ComponentInfo.loadLogo()
         * @param activityName Name of the activity whose logo is to be retrieved.
         *
         * @return Returns the image of the logo or null if the activity has no
         * logo specified.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given activity could not be loaded.
         *
         * @see #getActivityLogo(Intent)
         */
        GetActivityLogo(
            [in] IComponentName* activityName,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an Intent.  If intent.getClassName() is
         * set, this simply returns the result of
         * getActivityLogo(intent.getClassName()).  Otherwise it resolves the intent's
         * component and returns the logo associated with the resolved component.
         * If intent.getClassName() can not be found or the Intent can not be resolved
         * to a component, NameNotFoundException is thrown.
         *
         * @param intent The intent for which you would like to retrieve a logo.
         *
         * @return Returns the image of the logo, or null if the activity has no
         * logo specified.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for application
         * matching the given intent could not be loaded.
         *
         * @see #getActivityLogo(ComponentName)
         */
        GetActivityLogo(
            [in] IIntent* intent,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an application.  If it has not specified
         * a logo, this method returns null.
         *
         * @param info Information about application being queried.
         *
         * @return Returns the image of the logo, or null if no logo is specified
         * by the application.
         *
         * @see #getApplicationLogo(String)
         */
        GetApplicationLogo(
            [in] IApplicationInfo* info,
            [out] IDrawable** logo);

        /**
         * Retrieve the logo associated with an application.  Given the name of the
         * application's package, retrieves the information about it and calls
         * getApplicationLogo() to return its logo. If the application can not be
         * found, NameNotFoundException is thrown.
         *
         * @param packageName Name of the package whose application logo is to be
         *                    retrieved.
         *
         * @return Returns the image of the logo, or null if no application logo
         * has been specified.
         *
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given application could not be loaded.
         *
         * @see #getApplicationLogo(ApplicationInfo)
         */
        GetApplicationLogo(
            [in] String packageName,
            [out] IDrawable** logo);

        /**
         * If the target user is a managed profile of the calling user or the caller
         * is itself a managed profile, then this returns a badged copy of the given
         * icon to be able to distinguish it from the original icon. For badging an
         * arbitrary drawable use {@link #getUserBadgedDrawableForDensity(
         * android.graphics.drawable.Drawable, UserHandle, android.graphics.Rect, int)}.
         * <p>
         * If the original drawable is a BitmapDrawable and the backing bitmap is
         * mutable as per {@link android.graphics.Bitmap#isMutable()}, the badging
         * is performed in place and the original drawable is returned.
         * </p>
         *
         * @param icon The icon to badge.
         * @param user The target user.
         * @return A drawable that combines the original icon and a badge as
         *         determined by the system.
         */
        GetUserBadgedIcon(
            [in] IDrawable* drawable,
            [in] IUserHandle* user,
            [out] IDrawable** icon);

        /**
         * If the target user is a managed profile of the calling user or the caller
         * is itself a managed profile, then this returns a badged copy of the given
         * drawable allowing the user to distinguish it from the original drawable.
         * The caller can specify the location in the bounds of the drawable to be
         * badged where the badge should be applied as well as the density of the
         * badge to be used.
         * <p>
         * If the original drawable is a BitmapDrawable and the backing bitmap is
         * mutable as per {@link android.graphics.Bitmap#isMutable()}, the bading
         * is performed in place and the original drawable is returned.
         * </p>
         *
         * @param drawable The drawable to badge.
         * @param user The target user.
         * @param badgeLocation Where in the bounds of the badged drawable to place
         *         the badge. If not provided, the badge is applied on top of the entire
         *         drawable being badged.
         * @param badgeDensity The optional desired density for the badge as per
         *         {@link android.util.DisplayMetrics#densityDpi}. If not provided,
         *         the density of the display is used.
         * @return A drawable that combines the original drawable and a badge as
         *         determined by the system.
         */
        GetUserBadgedDrawableForDensity(
            [in] IDrawable* drawable,
            [in] IUserHandle* user,
            [in] IRect* badgeLocation,
            [in] Int32 badgeDensity,
            [out] IDrawable** icon);

        /**
         * If the target user is a managed profile of the calling user or the caller
         * is itself a managed profile, then this returns a drawable to use as a small
         * icon to include in a view to distinguish it from the original icon.
         *
         * @param user The target user.
         * @param density The optional desired density for the badge as per
         *         {@link android.util.DisplayMetrics#densityDpi}. If not provided
         *         the density of the current display is used.
         * @return the drawable or null if no drawable is required.
         * @hide
         */
        GetUserBadgeForDensity(
            [in] IUserHandle* user,
            [in] Int32 density,
            [out] IDrawable** icon);

        /**
         * If the target user is a managed profile of the calling user or the caller
         * is itself a managed profile, then this returns a copy of the label with
         * badging for accessibility services like talkback. E.g. passing in "Email"
         * and it might return "Work Email" for Email in the work profile.
         *
         * @param label The label to change.
         * @param user The target user.
         * @return A label that combines the original label and a badge as
         *         determined by the system.
         */
        GetUserBadgedLabel(
            [in] ICharSequence* label,
            [in] IUserHandle* user,
            [out] ICharSequence** seq);

        /**
         * Retrieve text from a package.  This is a low-level API used by
         * the various package manager info structures (such as
         * ComponentInfo to implement retrieval of their associated
         * labels and other text.
         *
         * @sa ComponentInfo
         *
         * @param packageName The name of the package that this text is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired text.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns a CharSequence holding the requested text.  Returns null
         * if the text could not be found for any reason.
         */
        GetText(
            [in] String packageName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] ICharSequence** text);

        /**
         * Retrieve an XML file from a package.  This is a low-level API used to
         * retrieve XML meta data.
         *
         * @param packageName The name of the package that this xml is coming from.
         * Can not be null.
         * @param resid The resource identifier of the desired xml.  Can not be 0.
         * @param appInfo Overall information about <var>packageName</var>.  This
         * may be null, in which case the application information will be retrieved
         * for you if needed; if you already have this information around, it can
         * be much more efficient to supply it here.
         *
         * @return Returns an XmlPullParser allowing you to parse out the XML
         * data.  Returns null if the xml resource could not be found for any
         * reason.
         */
        GetXml(
            [in] String packageName,
            [in] Int32 resid,
            [in] IApplicationInfo* appInfo,
            [out] IXmlResourceParser** parser);

        /**
         * Return the label to use for this application.
         *
         * @return Returns the label associated with this application, or null if
         * it could not be found for any reason.
         * @param info The application to get the label of
         */
        GetApplicationLabel(
            [in] IApplicationInfo* info,
            [out] ICharSequence** label);

        /**
         * Retrieve the resources associated with an activity.  Given the full
         * name of an activity, retrieves the information about it and calls
         * getResources() to return its application's resources.  If the activity
         * can not be found, NameNotFoundException is thrown.
         *
         * @param activityName Name of the activity whose resources are to be
         *                     retrieved.
         *
         * @return Returns the application's Resources.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given application could not be loaded.
         *
         * @see #getResourcesForApplication(ApplicationInfo)
         */
        GetResourcesForActivity(
            [in] IComponentName* activityName,
            [out] IResources** res);

        /**
         * Retrieve the resources for an application.  Throws NameNotFoundException
         * if the package is no longer installed.
         *
         * @param app Information about the desired application.
         *
         * @return Returns the application's Resources.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given application could not be loaded (most likely because it was uninstalled).
         */
        GetResourcesForApplication(
            [in] IApplicationInfo* app,
            [out] IResources** res);

        /**
         * Retrieve the resources associated with an application.  Given the full
         * package name of an application, retrieves the information about it and
         * calls getResources() to return its application's resources.  If the
         * appPackageName can not be found, NameNotFoundException is thrown.
         *
         * @param appPackageName Package name of the application whose resources
         *                       are to be retrieved.
         *
         * @return Returns the application's Resources.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * NameNotFoundException Thrown | if the resources for the given application could not be loaded.
         *
         * @see #getResourcesForApplication(ApplicationInfo)
         */
        GetResourcesForApplication(
            [in] String appPackageName,
            [out] IResources** res);

        /** @hide */
        GetResourcesForApplicationAsUser(
            [in] String appPackageName,
            [in] Int32 userId,
            [out] IResources** res);

        /**
         * Retrieve overall information about an application package defined
         * in a package archive file
         *
         * @param archiveFilePath The path to the archive file
         * @param flags Additional option flags. Use any combination of
         * #GET_ACTIVITIES,
         * #GET_GIDS,
         * #GET_CONFIGURATIONS,
         * #GET_INSTRUMENTATION,
         * #GET_PERMISSIONS,
         * #GET_PROVIDERS,
         * #GET_RECEIVERS,
         * #GET_SERVICES,
         * #GET_SIGNATURES, to modify the data returned.
         *
         * @sa #GET_ACTIVITIES
         * @sa #GET_GIDS
         * @sa #GET_CONFIGURATIONS
         * @sa #GET_INSTRUMENTATION
         * @sa #GET_PERMISSIONS
         * @sa #GET_PROVIDERS
         * @sa #GET_RECEIVERS
         * @sa #GET_SERVICES
         * @sa #GET_SIGNATURES
         *
         * @return Returns the information about the package. Returns
         * null if the package could not be successfully parsed.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         *
         */
        GetPackageArchiveInfo(
            [in] String archiveFilePath,
            [in] Int32 flags,
            [out] IPackageInfo** info);

        /**
         * @hide
         *
         * Install a package. Since this may take a little while, the result will
         * be posted back to the given observer.  An installation will fail if the calling context
         * lacks the android.Manifest.permission#INSTALL_PACKAGES permission, if the
         * package named in the package file's manifest is already installed, or if there's no space
         * available on the device.
         *
         * @sa android.Manifest.permission#INSTALL_PACKAGES
         *
         * @param packageURI The location of the package file to install.  This can be a 'file:' or a
         * 'content:' URI.
         * @param observer An observer callback to get notified when the package installation is
         * complete. IPackageInstallObserver#packageInstalled(String, int) will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         *
         * @sa IPackageInstallObserver#packageInstalled(String, int)
         * @param flags - possible values: #INSTALL_FORWARD_LOCK,
         * #INSTALL_REPLACE_EXISTING, #INSTALL_ALLOW_TEST.
         *
         * @sa #INSTALL_FORWARD_LOCK
         * @sa #INSTALL_REPLACE_EXISTING
         * @sa #INSTALL_ALLOW_TEST
         * @param installerPackageName Optional package name of the application that is performing the
         * installation. This identifies which market the package came from.
         */
        InstallPackage(
            [in] IUri* packageURI,
            [in] IIPackageInstallObserver* observer,
            [in] Int32 flags,
            [in] String installerPackageName);

        /**
         * Similar to
         * #installPackage(Uri, IPackageInstallObserver, int, String) but
         * with an extra verification information provided.
         *
         * @param packageURI The location of the package file to install. This can
         *            be a 'file:' or a 'content:' URI.
         * @param observer An observer callback to get notified when the package
         *            installation is complete.
         *            IPackageInstallObserver#packageInstalled(String, int)
         *            will be called when that happens. observer may be null to
         *            indicate that no callback is desired.
         * @param flags - possible values: #INSTALL_FORWARD_LOCK,
         *            #INSTALL_REPLACE_EXISTING, #INSTALL_ALLOW_TEST
         *
         * @sa #installPackage(Uri, IPackageInstallObserver, int, String)
         * @sa IPackageInstallObserver#packageInstalled(String, int)
         * @sa #INSTALL_FORWARD_LOCK
         * @sa #INSTALL_REPLACE_EXISTING
         * @sa #INSTALL_ALLOW_TEST
         *            .
         * @param installerPackageName Optional package name of the application that
         *            is performing the installation. This identifies which market
         *            the package came from.
         * @param verificationParams an object that holds signal information to
         *            assist verification. May be {null}.
         * @param encryptionParams if the package to be installed is encrypted,
         *            these parameters describing the encryption and authentication
         *            used. May be {null}.
         *
         * @hide
         */
        InstallPackageWithVerification(
            [in] IUri* packageURI,
            [in] IIPackageInstallObserver* observer,
            [in] Int32 flags,
            [in] String installerPackageName,
            [in] IUri* verificationURI,
            [in] IManifestDigest* manifestDigest,
            [in] IContainerEncryptionParams* encryptionParams);

        /**
         * Similar to
         * #installPackage(Uri, IPackageInstallObserver, int, String) but
         * with an extra verification information provided.
         *
         * @param packageURI The location of the package file to install. This can
         *            be a 'file:' or a 'content:' URI.
         * @param observer An observer callback to get notified when the package
         *            installation is complete.
         *            IPackageInstallObserver#packageInstalled(String, int)
         *            will be called when that happens. observer may be null to
         *            indicate that no callback is desired.
         * @param flags - possible values: #INSTALL_FORWARD_LOCK,
         *            #INSTALL_REPLACE_EXISTING, #INSTALL_ALLOW_TEST
         *
         * @sa #installPackage(Uri, IPackageInstallObserver, int, String)
         * @sa IPackageInstallObserver#packageInstalled(String, int)
         * @sa #INSTALL_FORWARD_LOCK
         * @sa #INSTALL_REPLACE_EXISTING
         * @sa #INSTALL_ALLOW_TEST
         *            .
         * @param installerPackageName Optional package name of the application that
         *            is performing the installation. This identifies which market
         *            the package came from.
         * @param verificationParams an object that holds signal information to
         *            assist verification. May be {null}.
         * @param encryptionParams if the package to be installed is encrypted,
         *            these parameters describing the encryption and authentication
         *            used. May be {null}.
         *
         * @hide
         */
        InstallPackageWithVerificationAndEncryption(
            [in] IUri* packageURI,
            [in] IIPackageInstallObserver* observer,
            [in] Int32 flags,
            [in] String installerPackageName,
            [in] IVerificationParams* verificationParams,
            [in] IContainerEncryptionParams* encryptionParams);

        /**
         * If there is already an application with the given package name installed
         * on the system for other users, also install it for the calling user.
         * @hide
         */
        InstallExistingPackage(
            [in] String packageName,
            [out] Int32* result);

        /**
         * Allows a package listening to the
         * Intent#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
         * broadcast to respond to the package manager. The response must include
         * the {verificationCode} which is one of
         * PackageManager#VERIFICATION_ALLOW or
         * PackageManager#VERIFICATION_REJECT.
         *
         * @param id pending package identifier as passed via the
         *            PackageManager#EXTRA_VERIFICATION_ID Intent extra
         * @param verificationCode either PackageManager#VERIFICATION_ALLOW
         *            or PackageManager#VERIFICATION_REJECT.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * SecurityException | if the caller does not have the PACKAGE_VERIFICATION_AGENT permission.
         *
         * @sa Intent#ACTION_PACKAGE_NEEDS_VERIFICATION package verification broadcast
         * @sa PackageManager#VERIFICATION_ALLOW
         * @sa PackageManager#VERIFICATION_REJECT
         * @sa PackageManager#EXTRA_VERIFICATION_ID
         * @sa PackageManager#VERIFICATION_ALLOW
         * @sa PackageManager#VERIFICATION_REJECT
         */
        VerifyPendingInstall(
            [in] Int32 id,
            [in] Int32 verificationCode);

        /**
         * Allows a package listening to the
         * Intent#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
         * broadcast to extend the default timeout for a response and declare what
         * action to perform after the timeout occurs. The response must include
         * the {verificationCodeAtTimeout} which is one of
         * PackageManager#VERIFICATION_ALLOW or
         * PackageManager#VERIFICATION_REJECT.
         *
         * This method may only be called once per package id. Additional calls
         * will have no effect.
         *
         * @param id pending package identifier as passed via the
         *            PackageManager#EXTRA_VERIFICATION_ID Intent extra
         * @param verificationCodeAtTimeout either
         *            PackageManager#VERIFICATION_ALLOW or
         *            PackageManager#VERIFICATION_REJECT. If
         *            {verificationCodeAtTimeout} is neither
         *            PackageManager#VERIFICATION_ALLOW or
         *            PackageManager#VERIFICATION_REJECT, then
         *            {verificationCodeAtTimeout} will default to
         *            PackageManager#VERIFICATION_REJECT.
         * @param millisecondsToDelay the amount of time requested for the timeout.
         *            Must be positive and less than
         *            PackageManager#MAXIMUM_VERIFICATION_TIMEOUT. If
         *            {millisecondsToDelay} is out of bounds,
         *            {millisecondsToDelay} will be set to the closest in
         *            bounds value; namely, 0 or
         *            PackageManager#MAXIMUM_VERIFICATION_TIMEOUT.
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * SecurityException | if the caller does not have the
         *            PACKAGE_VERIFICATION_AGENT permission.
         *
         * @sa Intent#ACTION_PACKAGE_NEEDS_VERIFICATION package verification broadcast
         * @sa PackageManager#VERIFICATION_ALLOW
         * @sa PackageManager#VERIFICATION_REJECT
         * @sa PackageManager#EXTRA_VERIFICATION_ID
         * @sa PackageManager#VERIFICATION_ALLOW
         * @sa PackageManager#VERIFICATION_REJECT
         * @sa PackageManager#VERIFICATION_ALLOW
         * @sa PackageManager#VERIFICATION_REJECT
         * @sa PackageManager#VERIFICATION_REJECT
         * @sa PackageManager#MAXIMUM_VERIFICATION_TIMEOUT
         * @sa PackageManager#MAXIMUM_VERIFICATION_TIMEOUT
         */
        ExtendVerificationTimeout(
            [in] Int32 id,
            [in] Int32 verificationCodeAtTimeout,
            [in] Int64 millisecondsToDelay);

        /**
         * Change the installer associated with a given package.  There are limitations
         * on how the installer package can be changed; in particular:
         * <ul>
         * <li> A SecurityException will be thrown if <var>installerPackageName</var>
         * is not signed with the same certificate as the calling application.
         * <li> A SecurityException will be thrown if <var>targetPackage</var> already
         * has an installer package, and that installer package is not signed with
         * the same certificate as the calling application.
         * </ul>
         *
         * @param targetPackage The installed package whose installer will be changed.
         * @param installerPackageName The package name of the new installer.  May be
         * null to clear the association.
         */
        SetInstallerPackageName(
            [in] String targetPackage,
            [in] String installerPackageName);

        /**
         * Attempts to delete a package.  Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the calling context
         * lacks the android.Manifest.permission#DELETE_PACKAGES permission, if the
         * named package cannot be found, or if the named package is a "system package".
         * (TODO: include pointer to documentation on "system packages")
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the package deletion is
         * complete. android.content.pm.IPackageDeleteObserver#packageDeleted(boolean) will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         * @param flags - possible values: #DELETE_KEEP_DATA,
         * #DELETE_ALL_USERS.
         *
         * @sa android.Manifest.permission#DELETE_PACKAGES
         * @sa android.content.pm.IPackageDeleteObserver#packageDeleted(boolean)
         * @sa #DELETE_KEEP_DATA
         * @sa #DELETE_ALL_USERS
         *
         * @hide
         */
        DeletePackage(
            [in] String packageName,
            [in] IIPackageDeleteObserver* observer,
            [in] Int32 flags);

        /**
         * Retrieve the package name of the application that installed a package. This identifies
         * which market the package came from.
         *
         * @param packageName The name of the package to query
         */
        GetInstallerPackageName(
            [in] String packageName,
            [out] String* name);

        /**
         * Attempts to clear the user data directory of an application.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @param packageName The name of the package
         * @param observer An observer callback to get notified when the operation is finished
         * android.content.pm.IIPackageDataObserver#onRemoveCompleted(String, boolean)
         * will be called when that happens.  observer may be null to indicate that
         * no callback is desired.
         *
         * @sa android.content.pm.IIPackageDataObserver#onRemoveCompleted(String, boolean)
         *
         * @hide
         */
        ClearApplicationUserData(
            [in] String packageName,
            [in] IIPackageDataObserver* observer);

        /**
         * Attempts to delete the cache files associated with an application.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  A deletion will fail if the calling context
         * lacks the android.Manifest.permission#DELETE_CACHE_FILES permission, if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the cache file deletion
         * is complete.
         * android.content.pm.IIPackageDataObserver#onRemoveCompleted(String, boolean)
         * will be called when that happens.  observer may be null to indicate that
         * no callback is desired.
         *
         * @sa android.Manifest.permission#DELETE_CACHE_FILES
         * @sa android.content.pm.IIPackageDataObserver#onRemoveCompleted(String, boolean)
         *
         * @hide
         */
        DeleteApplicationCacheFiles(
            [in] String packageName,
            [in] IIPackageDataObserver* observer);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param observer call back used to notify when
         * the operation is completed
         *
         * @hide
         */
        FreeStorageAndNotify(
            [in] Int64 freeStorageSize,
            [in] IIPackageDataObserver* observer);

        /**
         * Free storage by deleting LRU sorted list of cache files across
         * all applications. If the currently available free storage
         * on the device is greater than or equal to the requested
         * free storage, no cache files are cleared. If the currently
         * available storage on the device is less than the requested
         * free storage, some or all of the cache files across
         * all applications are deleted (based on last accessed time)
         * to increase the free storage space on the device to
         * the requested value. There is no guarantee that clearing all
         * the cache files from all applications will clear up
         * enough storage to achieve the desired value.
         * @param freeStorageSize The number of bytes of storage to be
         * freed by the system. Say if freeStorageSize is XX,
         * and the current free storage is YY,
         * if XX is less than YY, just return. if not free XX-YY number
         * of bytes if possible.
         * @param pi IntentSender call back used to
         * notify when the operation is completed.May be null
         * to indicate that no call back is desired.
         *
         * @hide
         */
        FreeStorage(
            [in] Int64 freeStorageSize,
            [in] IIntentSender* pi);

        /**
         * Retrieve the size information for a package.
         * Since this may take a little while, the result will
         * be posted back to the given observer.  The calling context
         * should have the android.Manifest.permission#GET_PACKAGE_SIZE permission.
         *
         * @param packageName The name of the package whose size information is to be retrieved
         * @param userHandle The user whose size information should be retrieved.
         * @param observer An observer callback to get notified when the operation
         * is complete.
         * android.content.pm.IIPackageStatsObserver#onGetStatsCompleted(PackageStats, boolean)
         * The observer's callback is invoked with a PackageStats object(containing the
         * code, data and cache sizes of the package) and a boolean value representing
         * the status of the operation. observer may be null to indicate that
         * no callback is desired.
         *
         * @sa android.Manifest.permission#GET_PACKAGE_SIZE
         * @sa android.content.pm.IIPackageStatsObserver#onGetStatsCompleted(PackageStats, boolean)
         *
         * @hide
         */
        GetPackageSizeInfo(
            [in] String packageName,
            [in] Int32 userHandle,
            [in] IIPackageStatsObserver* observer);

        /**
         * Like #getPackageSizeInfo(String, int, IIPackageStatsObserver), but
         * returns the size for the calling user.
         *
         * @sa #getPackageSizeInfo(String, int, IIPackageStatsObserver)
         *
         * @hide
         */
        GetPackageSizeInfo(
            [in] String packageName,
            [in] IIPackageStatsObserver* observer);

        /**
         * @deprecated This function no longer does anything; it was an old
         * approach to managing preferred activities, which has been superceeded
         * (and conflicts with) the modern activity-based preferences.
         */
        //@Deprecated
        AddPackageToPreferred(
            [in] String packageName);

        /**
         * @deprecated This function no longer does anything; it was an old
         * approach to managing preferred activities, which has been superceeded
         * (and conflicts with) the modern activity-based preferences.
         */
        //@Deprecated
        RemovePackageFromPreferred(
            [in] String packageName);

        /**
         * Retrieve the list of all currently configured preferred packages.  The
         * first package on the list is the most preferred, the last is the
         * least preferred.
         *
         * @param flags Additional option flags. Use any combination of
         * #GET_ACTIVITIES,
         * #GET_GIDS,
         * #GET_CONFIGURATIONS,
         * #GET_INSTRUMENTATION,
         * #GET_PERMISSIONS,
         * #GET_PROVIDERS,
         * #GET_RECEIVERS,
         * #GET_SERVICES,
         * #GET_SIGNATURES, to modify the data returned.
         *
         * @sa #GET_ACTIVITIES
         * @sa #GET_GIDS
         * @sa #GET_CONFIGURATIONS
         * @sa #GET_INSTRUMENTATION
         * @sa #GET_PERMISSIONS
         * @sa #GET_PROVIDERS
         * @sa #GET_RECEIVERS
         * @sa #GET_SERVICES
         * @sa #GET_SIGNATURES
         *
         * @return Returns a list of PackageInfo objects describing each
         * preferred application, in order of preference.
         *
         * @see #GET_ACTIVITIES
         * @see #GET_GIDS
         * @see #GET_CONFIGURATIONS
         * @see #GET_INSTRUMENTATION
         * @see #GET_PERMISSIONS
         * @see #GET_PROVIDERS
         * @see #GET_RECEIVERS
         * @see #GET_SERVICES
         * @see #GET_SIGNATURES
         */
        GetPreferredPackages(
            [in] Int32 flags,
            [out] IList** packages);

        /**
         * @deprecated This is a protected API that should not have been available
         * to third party applications.  It is the platform's responsibility for
         * assigning preferred activities and this can not be directly modified.
         *
         * Add a new preferred activity mapping to the system.  This will be used
         * to automatically select the given activity component when
         * Context#startActivity(Intent) Context.startActivity() finds
         * multiple matching activities and also matches the given filter.
         *
         * @sa Context#startActivity(Intent) Context.startActivity()
         *
         * @param filter The set of intents under which this activity will be
         * made preferred.
         * @param match The IntentFilter match category that this preference
         * applies to.
         * @param set The set of activities that the user was picking from when
         * this preference was made.
         * @param activity The component name of the activity that is to be
         * preferred.
         */
        //@Deprecated
        AddPreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] ArrayOf<IComponentName*>* set,
            [in] IComponentName* activity);

        /**
         * Same as #addPreferredActivity(IntentFilter, int,
         *       ComponentName[], ComponentName), but with a specific userId to apply the preference
         *       to.
         *
         * @sa #addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName)
         * @hide
         */
        AddPreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] ArrayOf<IComponentName*>* set,
            [in] IComponentName* activity,
            [in] Int32 userId);

        /**
         * @deprecated This is a protected API that should not have been available
         * to third party applications.  It is the platform's responsibility for
         * assigning preferred activities and this can not be directly modified.
         *
         * Replaces an existing preferred activity mapping to the system, and if that were not present
         * adds a new preferred activity.  This will be used
         * to automatically select the given activity component when
         * Context#startActivity(Intent) Context.startActivity() finds
         * multiple matching activities and also matches the given filter.
         *
         * @sa Context#startActivity(Intent) Context.startActivity()
         *
         * @param filter The set of intents under which this activity will be
         * made preferred.
         * @param match The IntentFilter match category that this preference
         * applies to.
         * @param set The set of activities that the user was picking from when
         * this preference was made.
         * @param activity The component name of the activity that is to be
         * preferred.
         * @hide
         */
        //@Deprecated
        ReplacePreferredActivity(
            [in] IIntentFilter* filter,
            [in] Int32 match,
            [in] ArrayOf<IComponentName*>* set,
            [in] IComponentName* activity);

        /**
         * Remove all preferred activity mappings, previously added with
         * #addPreferredActivity, from the
         * system whose activities are implemented in the given package name.
         * An application can only clear its own package(s).
         *
         * @sa #addPreferredActivity
         *
         * @param packageName The name of the package whose preferred activity
         * mappings are to be removed.
         */
        ClearPackagePreferredActivities(
            [in] String packageName);

        /**
         * Retrieve all preferred activities, previously added with
         * #addPreferredActivity, that are
         * currently registered with the system.
         *
         * @sa #addPreferredActivity
         *
         * @param outFilters A list in which to place the filters of all of the
         * preferred activities, or null for none.
         * @param outActivities A list in which to place the component names of
         * all of the preferred activities, or null for none.
         * @param packageName An option package in which you would like to limit
         * the list.  If null, all activities will be returned; if non-null, only
         * those activities in the given package are returned.
         *
         * @return Returns the total number of registered preferred activities
         * (the number of distinct IntentFilter records, not the number of unique
         * activity components) that were found.
         */
        GetPreferredActivities(
            [in] IList* outFilters,
            [in] IList* outActivities,
            [in] String packageName,
            [out] Int32* num);

        /**
         * Ask for the set of available 'home' activities and the current explicit
         * default, if any.
         * @hide
         */
        GetHomeActivities(
            [in] IList* outActivities,
            [out] IComponentName** name);

        /**
         * Set the enabled setting for a package component (activity, receiver, service, provider).
         * This setting will override any enabled state which may have been set by the component in its
         * manifest.
         *
         * @param componentName The component to enable
         * @param newState The new enabled state for the component.  The legal values for this state
         *                 are:
         *                    #COMPONENT_ENABLED_STATE_ENABLED,
         *                    #COMPONENT_ENABLED_STATE_DISABLED
         *                    and
         *                    #COMPONENT_ENABLED_STATE_DEFAULT
         *                 The last one removes the setting, thereby restoring the component's state to
         *                 whatever was set in it's manifest (or enabled, by default).
         *
         * @sa #COMPONENT_ENABLED_STATE_ENABLED},
         * @sa #COMPONENT_ENABLED_STATE_DISABLED
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         * @param flags Optional behavior flags: #DONT_KILL_APP or 0.
         *
         * @sa #DONT_KILL_APP
         */
        SetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * Return the the enabled setting for a package component (activity,
         * receiver, service, provider).  This returns the last value set by
         * #setComponentEnabledSetting(ComponentName, int, int); in most
         * cases this value will be #COMPONENT_ENABLED_STATE_DEFAULT since
         * the value originally specified in the manifest has not been modified.
         *
         * @sa #setComponentEnabledSetting(ComponentName, int, int)
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         *
         * @param componentName The component to retrieve.
         * @return Returns the current enabled state for the component.  May
         * be one of #COMPONENT_ENABLED_STATE_ENABLED,
         * #COMPONENT_ENABLED_STATE_DISABLED, or
         * #COMPONENT_ENABLED_STATE_DEFAULT.  The last one means the
         * component's enabled state is based on the original information in
         * the manifest as found in ComponentInfo.
         *
         * @sa #COMPONENT_ENABLED_STATE_ENABLED
         * @sa #COMPONENT_ENABLED_STATE_DISABLED
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         * @sa ComponentInfo
         *
         */
        GetComponentEnabledSetting(
            [in] IComponentName* componentName,
            [out] Int32* value);

        /**
         * Set the enabled setting for an application
         * This setting will override any enabled state which may have been set by the application in
         * its manifest.  It also overrides the enabled state set in the manifest for any of the
         * application's components.  It does not override any enabled state set by
         * #setComponentEnabledSetting for any of the application's components.
         *
         * @sa #setComponentEnabledSetting
         *
         * @param packageName The package name of the application to enable
         * @param newState The new enabled state for the component.  The legal values for this state
         *                 are:
         *                   #COMPONENT_ENABLED_STATE_ENABLED,
         *                   #COMPONENT_ENABLED_STATE_DISABLED
         *                   and
         *                   #COMPONENT_ENABLED_STATE_DEFAULT
         *                 The last one removes the setting, thereby restoring the applications's state to
         *                 whatever was set in its manifest (or enabled, by default).
         *
         * @sa #COMPONENT_ENABLED_STATE_ENABLED
         * @sa #COMPONENT_ENABLED_STATE_DISABLED
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         * @param flags Optional behavior flags: #DONT_KILL_APP or 0.
         *
         * @sa #DONT_KILL_APP
         */
        SetApplicationEnabledSetting(
            [in] String packageName,
            [in] Int32 newState,
            [in] Int32 flags);

        /**
         * Return the the enabled setting for an application.  This returns
         * the last value set by
         * #setApplicationEnabledSetting(String, int, int); in most
         * cases this value will be #COMPONENT_ENABLED_STATE_DEFAULT since
         * the value originally specified in the manifest has not been modified.
         *
         * @sa #setApplicationEnabledSetting(String, int, int)
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         *
         * @param packageName The component to retrieve.
         * @return Returns the current enabled state for the component.  May
         * be one of #COMPONENT_ENABLED_STATE_ENABLED,
         * #COMPONENT_ENABLED_STATE_DISABLED, or
         * #COMPONENT_ENABLED_STATE_DEFAULT.  The last one means the
         * application's enabled state is based on the original information in
         * the manifest as found in ComponentInfo.
         *
         * @sa #COMPONENT_ENABLED_STATE_ENABLED
         * @sa #COMPONENT_ENABLED_STATE_DISABLED
         * @sa #COMPONENT_ENABLED_STATE_DEFAULT
         * @sa ComponentInfo
         * @return ECode = NOERROR(0) if success, else as follows:
         * Value | Meaning |
         * :-|:------------|
         * IllegalArgumentException | if the named package does not exist.
         */
        GetApplicationEnabledSetting(
            [in] String packageName,
            [out] Int32* value);

        /**
         * Return whether the device has been booted into safe mode.
         */
        IsSafeMode(
            [out] Boolean* result);

        /**
         * Attempts to move package resources from internal to external media or vice versa.
         * Since this may take a little while, the result will
         * be posted back to the given observer.   This call may fail if the calling context
         * lacks the android.Manifest.permission#MOVE_PACKAGE permission, if the
         * named package cannot be found, or if the named package is a "system package".
         *
         * @sa android.Manifest.permission#MOVE_PACKAGE
         *
         * @param packageName The name of the package to delete
         * @param observer An observer callback to get notified when the package move is
         * complete. android.content.pm.IPackageMoveObserver#packageMoved(boolean) will be
         * called when that happens.  observer may be null to indicate that no callback is desired.
         *
         * @sa android.content.pm.IPackageMoveObserver#packageMoved(boolean)
         * @param flags To indicate install location #MOVE_INTERNAL or
         * #MOVE_EXTERNAL_MEDIA
         *
         * @sa #MOVE_INTERNAL
         * @sa #MOVE_EXTERNAL_MEDIA
         *
         * @hide
         */
        MovePackage(
            [in] String packageName,
            [in] IIPackageMoveObserver* observer,
            [in] Int32 flags);

        /**
         * Returns the device identity that verifiers can use to associate their scheme to a particular
         * device. This should not be used by anything other than a package verifier.
         *
         * @return identity that uniquely identifies current device
         * @hide
         */
        GetVerifierDeviceIdentity(
            [out] IVerifierDeviceIdentity** identity);

        /**
         * Return interface that offers the ability to install, upgrade, and remove
         * applications on the device.
         */
        GetPackageInstaller(
            [out] IPackageInstaller** installer);

        /**
         * Adds a {@link CrossProfileIntentFilter}. After calling this method all intents sent from the
         * user with id sourceUserId can also be be resolved by activities in the user with id
         * targetUserId if they match the specified intent filter.
         * @param filter The {@link IntentFilter} the intent has to match
         * @param sourceUserId The source user id.
         * @param targetUserId The target user id.
         * @param flags The only possible value is {@link SKIP_CURRENT_PROFILE}
         * @hide
         */
        AddCrossProfileIntentFilter(
            [in] IIntentFilter* filter,
            [in] Int32 sourceUserId,
            [in] Int32 targetUserId,
            [in] Int32 flags);

        /**
         * Clearing {@link CrossProfileIntentFilter}s which have the specified user as their
         * source, and have been set by the app calling this method.
         * @param sourceUserId The source user id.
         * @hide
         */
        ClearCrossProfileIntentFilters(
            [in] Int32 sourceUserId);

        IsPackageAvailable(
            [in] String packageName,
            [out] Boolean* result);
    }

    interface IPackageManagerHelper {
        /**
         * Returns the data directory for a particular user and package, given the uid of the package.
         * @param uid uid of the package, including the userId and appId
         * @param packageName name of the package
         * @return the user-specific data directory for the package
         * @hide
         */
        GetDataDirForUser(
            [in] Int32 userId,
            [in] String packageName,
            [out] String* directory);
        }
    }

    } // namespace Pm
    } // namespace Content
    } // namespace Droid
    } // namespace Elastos
}