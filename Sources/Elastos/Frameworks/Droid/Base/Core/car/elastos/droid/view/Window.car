
module
{
    using interface Elastos.Core.ICharSequence;

    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.Res.ITypedArray;
    interface Elastos.Droid.Content.Res.IConfiguration;
    interface Elastos.Droid.Graphics.Drawable.IDrawable;
    interface Elastos.Droid.Os.IBinder;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Media.Session.IMediaController;
    interface Elastos.Droid.Transition.ITransitionManager;
    interface Elastos.Droid.Transition.ITransition;
    interface Elastos.Droid.Transition.IScene;
    interface Elastos.Droid.View.IView;
    interface Elastos.Droid.View.IKeyEvent;
    interface Elastos.Droid.View.IMotionEvent;
    interface Elastos.Droid.View.Accessibility.IAccessibilityEvent;
    interface Elastos.Droid.View.IWindowManager;
    interface Elastos.Droid.View.IWindowManagerLayoutParams;
    interface Elastos.Droid.View.IViewGroupLayoutParams;
    interface Elastos.Droid.View.ISurfaceHolderCallback2;
    interface Elastos.Droid.View.IInputQueueCallback;
    interface Elastos.Droid.View.ILayoutInflater;

    namespace Elastos {
    namespace Droid {
    namespace View {

    /**
     * API from a Window back to its caller.  This allows the client to
     * intercept key dispatching, panels and menus, etc.
     */
    [local]
    interface IWindowCallback {
        /**
         * Called to process key events.  At the very least your
         * implementation must call
         * {@link android.view.Window#superDispatchKeyEvent} to do the
         * standard key processing.
         *
         * @param event The key event.
         *
         * @return boolean Return true if this event was consumed.
         */
        DispatchKeyEvent(
            [in] IKeyEvent* event,
            [out] Boolean* isConsumed);

        /**
         * Called to process a key shortcut event.
         * At the very least your implementation must call
         * {@link android.view.Window#superDispatchKeyShortcutEvent} to do the
         * standard key shortcut processing.
         *
         * @param event The key shortcut event.
         * @return True if this event was consumed.
         */
        DispatchKeyShortcutEvent(
            [in] IKeyEvent* event,
            [out] Boolean* isConsumed);

        /**
         * Called to process touch screen events.  At the very least your
         * implementation must call
         * {@link android.view.Window#superDispatchTouchEvent} to do the
         * standard touch screen processing.
         *
         * @param event The touch screen event.
         *
         * @return boolean Return true if this event was consumed.
         */
        DispatchTouchEvent(
            [in] IMotionEvent* event,
            [out] Boolean* isConsumed);

        /**
         * Called to process trackball events.  At the very least your
         * implementation must call
         * {@link android.view.Window#superDispatchTrackballEvent} to do the
         * standard trackball processing.
         *
         * @param event The trackball event.
         *
         * @return boolean Return true if this event was consumed.
         */
        DispatchTrackballEvent(
            [in] IMotionEvent* event,
            [out] Boolean* isConsumed);

        /**
         * Called to process generic motion events.  At the very least your
         * implementation must call
         * {@link android.view.Window#superDispatchGenericMotionEvent} to do the
         * standard processing.
         *
         * @param event The generic motion event.
         *
         * @return boolean Return true if this event was consumed.
         */
        DispatchGenericMotionEvent(
            [in] IMotionEvent* event,
            [out] Boolean* isConsumed);

        /**
         * Called to process population of {@link AccessibilityEvent}s.
         *
         * @param event The event.
         *
         * @return boolean Return true if event population was completed.
         */
        DispatchPopulateAccessibilityEvent(
            [in] IAccessibilityEvent* event,
            [out] Boolean* isCompleted);

        /**
         * Instantiate the view to display in the panel for 'featureId'.
         * You can return null, in which case the default content (typically
         * a menu) will be created for you.
         *
         * @param featureId Which panel is being created.
         *
         * @return view The top-level view to place in the panel.
         *
         * @see #onPreparePanel
         */
        // @Nullable
        OnCreatePanelView(
            [in] Int32 featureId,
            [out] IView** view);

        /**
         * Initialize the contents of the menu for panel 'featureId'.  This is
         * called if onCreatePanelView() returns null, giving you a standard
         * menu in which you can place your items.  It is only called once for
         * the panel, the first time it is shown.
         *
         * <p>You can safely hold on to <var>menu</var> (and any items created
         * from it), making modifications to it as desired, until the next
         * time onCreatePanelMenu() is called for this feature.
         *
         * @param featureId The panel being created.
         * @param menu The menu inside the panel.
         *
         * @return boolean You must return true for the panel to be displayed;
         *         if you return false it will not be shown.
         */
        OnCreatePanelMenu(
            [in] Int32 featureId,
            [in] IMenu* menu,
            [out] Boolean* allowToShow);

        /**
         * Prepare a panel to be displayed.  This is called right before the
         * panel window is shown, every time it is shown.
         *
         * @param featureId The panel that is being displayed.
         * @param view The View that was returned by onCreatePanelView().
         * @param menu If onCreatePanelView() returned null, this is the Menu
         *             being displayed in the panel.
         *
         * @return boolean You must return true for the panel to be displayed;
         *         if you return false it will not be shown.
         *
         * @see #onCreatePanelView
         */
        OnPreparePanel(
            [in] Int32 featureId,
            [in] IView* view,
            [in] IMenu* menu,
            [out] Boolean* allowToShow);

        /**
         * Called when a panel's menu is opened by the user. This may also be
         * called when the menu is changing from one type to another (for
         * example, from the icon menu to the expanded menu).
         *
         * @param featureId The panel that the menu is in.
         * @param menu The menu that is opened.
         * @return Return true to allow the menu to open, or false to prevent
         *         the menu from opening.
         */
        OnMenuOpened(
            [in] Int32 featureId,
            [in] IMenu* menu,
            [out] Boolean* allowToOpen);

        /**
         * Called when a panel's menu item has been selected by the user.
         *
         * @param featureId The panel that the menu is in.
         * @param item The menu item that was selected.
         *
         * @return boolean Return true to finish processing of selection, or
         *         false to perform the normal menu handling (calling its
         *         Runnable or sending a Message to its target Handler).
         */
        OnMenuItemSelected(
            [in] Int32 featureId,
            [in] IMenuItem* item,
            [out] Boolean* toFinish);

        /**
         * This is called whenever the current window attributes change.
         *
         */
        OnWindowAttributesChanged(
            [in] IWindowManagerLayoutParams* attrs);

        /**
         * This hook is called whenever the content view of the screen changes
         * (due to a call to
         * {@link Window#setContentView(View, android.view.ViewGroup.LayoutParams)
         * Window.setContentView} or
         * {@link Window#addContentView(View, android.view.ViewGroup.LayoutParams)
         * Window.addContentView}).
         */
        OnContentChanged();

        /**
         * This hook is called whenever the window focus changes.  See
         * {@link View#onWindowFocusChanged(boolean)
         * View.onWindowFocusChanged(boolean)} for more information.
         *
         * @param hasFocus Whether the window now has focus.
         */
        OnWindowFocusChanged(
            [in] Boolean hasFocus);

        /**
         * Called when the window has been attached to the window manager.
         * See {@link View#onAttachedToWindow() View.onAttachedToWindow()}
         * for more information.
         */
        OnAttachedToWindow();

        /**
         * Called when the window has been attached to the window manager.
         * See {@link View#onDetachedFromWindow() View.onDetachedFromWindow()}
         * for more information.
         */
        OnDetachedFromWindow();

        /**
         * Called when a panel is being closed.  If another logical subsequent
         * panel is being opened (and this panel is being closed to make room for the subsequent
         * panel), this method will NOT be called.
         *
         * @param featureId The panel that is being displayed.
         * @param menu If onCreatePanelView() returned null, this is the Menu
         *            being displayed in the panel.
         */
        OnPanelClosed(
            [in] Int32 featureId,
            [in] IMenu* menu);

        /**
         * Called when the user signals the desire to start a search.
         *
         * @return true if search launched, false if activity refuses (blocks)
         *
         * @see android.app.Activity#onSearchRequested()
         */
        OnSearchRequested(
            [out] Boolean* isLaunched);

        /**
         * Called when an action mode is being started for this window. Gives the
         * callback an opportunity to handle the action mode in its own unique and
         * beautiful way. If this method returns null the system can choose a way
         * to present the mode or choose not to start the mode at all.
         *
         * @param callback Callback to control the lifecycle of this action mode
         * @return The ActionMode that was started, or null if the system should present it
         */
        // @Nullable
        OnWindowStartingActionMode(
            [in] IActionModeCallback* cb,
            [out] IActionMode** mode);

        /**
         * Called when an action mode has been started. The appropriate mode callback
         * method will have already been invoked.
         *
         * @param mode The new mode that has just been started.
         */
        OnActionModeStarted(
            [in] IActionMode* mode);

        /**
         * Called when an action mode has been finished. The appropriate mode callback
         * method will have already been invoked.
         *
         * @param mode The mode that was just finished.
         */
        OnActionModeFinished(
            [in] IActionMode* mode);
    }

    /** @hide */
    interface IOnWindowDismissedCallback {
        /**
         * Called when a window is dismissed. This informs the callback that the
         * window is gone, and it should finish itself.
         */
        OnWindowDismissed();
    }

    /**
     * Abstract base class for a top-level window look and behavior policy.  An
     * instance of this class should be used as the top-level view added to the
     * window manager. It provides standard UI policies such as a background, title
     * area, default key processing, etc.
     *
     * <p>The only existing implementation of this abstract class is
     * android.policy.PhoneWindow, which you should instantiate when needing a
     * Window.  Eventually that class will be refactored and a factory method
     * added for creating Window instances without knowing about a particular
     * implementation.
     */
    [local]
    interface IWindow {
        /** Flag for the "options panel" feature.  This is enabled by default. */
        const Int32 FEATURE_OPTIONS_PANEL = 0;

        /** Flag for the "no title" feature, turning off the title at the top
         *  of the screen. */
        const Int32 FEATURE_NO_TITLE = 1;

        /** Flag for the progress indicator feature */
        const Int32 FEATURE_PROGRESS = 2;

        /** Flag for having an icon on the left side of the title bar */
        const Int32 FEATURE_LEFT_ICON = 3;

        /** Flag for having an icon on the right side of the title bar */
        const Int32 FEATURE_RIGHT_ICON = 4;

        /** Flag for indeterminate progress */
        const Int32 FEATURE_INDETERMINATE_PROGRESS = 5;

        /** Flag for the context menu.  This is enabled by default. */
        const Int32 FEATURE_CONTEXT_MENU = 6;

        /** Flag for custom title. You cannot combine this feature with other title features. */
        const Int32 FEATURE_CUSTOM_TITLE = 7;

        /**
         * Flag for enabling the Action Bar.
         * This is enabled by default for some devices. The Action Bar
         * replaces the title bar and provides an alternate location
         * for an on-screen menu button on some devices.
         */
        const Int32 FEATURE_ACTION_BAR = 8;

        /**
         * Flag for requesting an Action Bar that overlays window content.
         * Normally an Action Bar will sit in the space above window content, but if this
         * feature is requested along with {@link #FEATURE_ACTION_BAR} it will be layered over
         * the window content itself. This is useful if you would like your app to have more control
         * over how the Action Bar is displayed, such as letting application content scroll beneath
         * an Action Bar with a transparent background or otherwise displaying a transparent/translucent
         * Action Bar over application content.
         *
         * <p>This mode is especially useful with {@link View#SYSTEM_UI_FLAG_FULLSCREEN
         * View.SYSTEM_UI_FLAG_FULLSCREEN}, which allows you to seamlessly hide the
         * action bar in conjunction with other screen decorations.
         *
         * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, when an
         * ActionBar is in this mode it will adjust the insets provided to
         * {@link View#fitSystemWindows(android.graphics.Rect) View.fitSystemWindows(Rect)}
         * to include the content covered by the action bar, so you can do layout within
         * that space.
         */
        const Int32 FEATURE_ACTION_BAR_OVERLAY = 9;

        /**
         * Flag for specifying the behavior of action modes when an Action Bar is not present.
         * If overlay is enabled, the action mode UI will be allowed to cover existing window content.
         */
        const Int32 FEATURE_ACTION_MODE_OVERLAY = 10;

        /**
         * Flag for requesting a decoration-free window that is dismissed by swiping from the left.
         */
        const Int32 FEATURE_SWIPE_TO_DISMISS = 11;

        /**
         * Flag for requesting that window content changes should be represented
         * with scenes and transitions.
         *
         * TODO Add docs
         *
         * @see #setContentView
         */
        const Int32 FEATURE_CONTENT_TRANSITIONS = 12;

        /**
         * Enables Activities to run Activity Transitions either through sending or receiving
         * ActivityOptions bundle created with
         * {@link android.app.ActivityOptions#makeSceneTransitionAnimation(android.app.Activity,
         * android.util.Pair[])} or {@link android.app.ActivityOptions#makeSceneTransitionAnimation(
         * android.app.Activity, View, String)}.
         */
        const Int32 FEATURE_ACTIVITY_TRANSITIONS = 13;

        /**
         * Max value used as a feature ID
         * @hide
         */
        const Int32 FEATURE_MAX = FEATURE_ACTIVITY_TRANSITIONS;

        /** Flag for setting the progress bar's visibility to VISIBLE */
        const Int32 PROGRESS_VISIBILITY_ON = -1;
        /** Flag for setting the progress bar's visibility to GONE */
        const Int32 PROGRESS_VISIBILITY_OFF = -2;
        /** Flag for setting the progress bar's indeterminate mode on */
        const Int32 PROGRESS_INDETERMINATE_ON = -3;
        /** Flag for setting the progress bar's indeterminate mode off */
        const Int32 PROGRESS_INDETERMINATE_OFF = -4;
        /** Starting value for the (primary) progress */
        const Int32 PROGRESS_START = 0;
        /** Ending value for the (primary) progress */
        const Int32 PROGRESS_END = 10000;
        /** Lowest possible value for the secondary progress */
        const Int32 PROGRESS_SECONDARY_START = 20000;
        /** Highest possible value for the secondary progress */
        const Int32 PROGRESS_SECONDARY_END = 30000;

        /**
         * The transitionName for the status bar background View when a custom background is used.
         * @see android.view.Window#setStatusBarColor(int)
         */
        const String STATUS_BAR_BACKGROUND_TRANSITION_NAME = "android:status:background";

        /**
         * The transitionName for the navigation bar background View when a custom background is used.
         * @see android.view.Window#setNavigationBarColor(int)
         */
        const String NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME =
                "android:navigation:background";

        /**
         * The ID that the main layout in the XML layout file should have.
         */
        const Int32 ID_ANDROID_CONTENT = 0x01020002;//com.android.internal.R.id.content;

        /**
         * Return the Context this window policy is running in, for retrieving
         * resources and other information.
         *
         * @return Context The Context that was supplied to the constructor.
         */
        GetContext(
            [out] IContext** ctx);

        /**
         * Return the {@link android.R.styleable#Window} attributes from this
         * window's theme.
         */
        GetWindowStyle(
            [out] ITypedArray** attrs);

        /**
         * Set the container for this window.  If not set, the DecorWindow
         * operates as a top-level window; otherwise, it negotiates with the
         * container to display itself appropriately.
         *
         * @param container The desired containing Window.
         */
        SetContainer(
            [in] IWindow* container);

        /**
         * Return the container for this Window.
         *
         * @return Window The containing window, or null if this is a
         *         top-level window.
         */
        GetContainer(
            [out] IWindow** container);

        HasChildren(
            [out] Boolean* hasChildren);

        /** @hide */
        Destroy();

        /** @hide */
        IsDestroyed(
            [out] Boolean* isDestroyed);

        /**
         * Set the window manager for use by this Window to, for example,
         * display panels.  This is <em>not</em> used for displaying the
         * Window itself -- that must be done by the client.
         *
         * @param wm The ViewManager for adding new windows.
         */
        SetWindowManager(
            [in] IWindowManager* wm,
            [in] IBinder* appToken,
            [in] String appName);

        /**
         * Set the window manager for use by this Window to, for example,
         * display panels.  This is <em>not</em> used for displaying the
         * Window itself -- that must be done by the client.
         *
         * @param wm The ViewManager for adding new windows.
         */
        SetWindowManager(
            [in] IWindowManager* wm,
            [in] IBinder* appToken,
            [in] String appName,
            [in] Boolean hardwareAccelerated);

        // protected
        AdjustLayoutParamsForSubWindow(
            [in] IWindowManagerLayoutParams* wparams);

        /**
         * Return the window manager allowing this Window to display its own
         * windows.
         *
         * @return WindowManager The ViewManager.
         */
        GetWindowManager(
            [out] IWindowManager** wm);

        /**
         * Set the Callback interface for this window, used to intercept key
         * events and other dynamic operations in the window.
         *
         * @param callback The desired Callback interface.
         */
        SetCallback(
            [in] IWindowCallback* cb);

        /**
         * Return the current Callback interface for this window.
         */
        GetCallback(
            [out] IWindowCallback** cb);

        /** @hide */
        SetOnWindowDismissedCallback(
            [in] IOnWindowDismissedCallback* dcb);

        /** @hide */
        DispatchOnWindowDismissed();

        /**
         * Take ownership of this window's surface.  The window's view hierarchy
         * will no longer draw into the surface, though it will otherwise continue
         * to operate (such as for receiving input events).  The given SurfaceHolder
         * callback will be used to tell you about state changes to the surface.
         */
        TakeSurface(
            [in] ISurfaceHolderCallback2* cb);

        /**
         * Take ownership of this window's InputQueue.  The window will no
         * longer read and dispatch input events from the queue; it is your
         * responsibility to do so.
         */
        TakeInputQueue(
            [in] IInputQueueCallback* cb);

        /**
         * Return whether this window is being displayed with a floating style
         * (based on the {@link android.R.attr#windowIsFloating} attribute in
         * the style/theme).
         *
         * @return Returns true if the window is configured to be displayed floating
         * on top of whatever is behind it.
         */
        IsFloating(
            [out] Boolean* isFloating);

        /**
         * Set the width and height layout parameters of the window.  The default
         * for both of these is MATCH_PARENT; you can change them to WRAP_CONTENT to
         * make a window that is not full-screen.
         *
         * @param width The desired layout width of the window.
         * @param height The desired layout height of the window.
         */
        SetLayout(
            [in] Int32 width,
            [in] Int32 height);

        /**
         * Set the gravity of the window, as per the Gravity constants.  This
         * controls how the window manager is positioned in the overall window; it
         * is only useful when using WRAP_CONTENT for the layout width or height.
         *
         * @param gravity The desired gravity constant.
         *
         * @see Gravity
         * @see #setLayout
         */
        SetGravity(
            [in] Int32 gravity);

        /**
         * Set the type of the window, as per the WindowManager.LayoutParams
         * types.
         *
         * @param type The new window type (see WindowManager.LayoutParams).
         */
        SetType(
            [in] Int32 type);

        /**
         * Set the format of window, as per the PixelFormat types.  This overrides
         * the default format that is selected by the Window based on its
         * window decorations.
         *
         * @param format The new window format (see PixelFormat).  Use
         *               PixelFormat.UNKNOWN to allow the Window to select
         *               the format.
         *
         * @see PixelFormat
         */
        SetFormat(
            [in] Int32 format);

        /**
         * Specify custom animations to use for the window, as per
         * {@link WindowManager.LayoutParams#windowAnimations
         * WindowManager.LayoutParams.windowAnimations}.  Providing anything besides
         * 0 here will override the animations the window would
         * normally retrieve from its theme.
         */
        SetWindowAnimations(
            [in] Int32 resId);

        /**
         * Specify an explicit soft input mode to use for the window, as per
         * {@link WindowManager.LayoutParams#softInputMode
         * WindowManager.LayoutParams.softInputMode}.  Providing anything besides
         * "unspecified" here will override the input mode the window would
         * normally retrieve from its theme.
         */
        SetSoftInputMode(
            [in] Int32 mode);

        /**
         * Convenience function to set the flag bits as specified in flags, as
         * per {@link #setFlags}.
         * @param flags The flag bits to be set.
         * @see #setFlags
         */
        AddFlags(
            [in] Int32 flags);

        /**
         * Convenience function to clear the flag bits as specified in flags, as
         * per {@link #setFlags}.
         * @param flags The flag bits to be cleared.
         * @see #setFlags
         */
        ClearFlags(
            [in] Int32 flags);

        /**
         * Set the flags of the window, as per the
         * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
         * flags.
         *
         * <p>Note that some flags must be set before the window decoration is
         * created (by the first call to
         * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
         * {@link #getDecorView()}:
         * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
         * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
         * will be set for you based on the {@link android.R.attr#windowIsFloating}
         * attribute.
         *
         * @param flags The new window flags (see WindowManager.LayoutParams).
         * @param mask Which of the window flag bits to modify.
         */
        SetFlags(
            [in] Int32 flags,
            [in] Int32 mask);

        /**
         * Set the amount of dim behind the window when using
         * {@link WindowManager.LayoutParams#FLAG_DIM_BEHIND}.  This overrides
         * the default dim amount of that is selected by the Window based on
         * its theme.
         *
         * @param amount The new dim amount, from 0 for no dim to 1 for full dim.
         */
        SetDimAmount(
            [in] Float amount);

        /**
         * Specify custom window attributes.  <strong>PLEASE NOTE:</strong> the
         * layout params you give here should generally be from values previously
         * retrieved with {@link #getAttributes()}; you probably do not want to
         * blindly create and apply your own, since this will blow away any values
         * set by the framework that you are not interested in.
         *
         * @param a The new window attributes, which will completely override any
         *          current values.
         */
        SetAttributes(
            [in] IWindowManagerLayoutParams* a);

        /**
         * Retrieve the current window attributes associated with this panel.
         *
         * @return WindowManager.LayoutParams Either the existing window
         *         attributes object, or a freshly created one if there is none.
         */
        GetAttributes(
            [out] IWindowManagerLayoutParams** params);

        /** @hide */
        SetCloseOnTouchOutside(
            [in] Boolean close);

        /** @hide */
        SetCloseOnTouchOutsideIfNotSet(
            [in] Boolean close);

        /** @hide */
        AlwaysReadCloseOnTouchAttr();

        /** @hide */
        ShouldCloseOnTouch(
            [in] IContext* ctx,
            [in] IMotionEvent* event,
            [out] Boolean* res);

        /**
         * Enable extended screen features.  This must be called before
         * setContentView().  May be called as many times as desired as long as it
         * is before setContentView().  If not called, no extended features
         * will be available.  You can not turn off a feature once it is requested.
         * You canot use other title features with {@link #FEATURE_CUSTOM_TITLE}.
         *
         * @param featureId The desired features, defined as constants by Window.
         * @return The features that are now set.
         */
        RequestFeature(
            [in] Int32 featureId,
            [out] Boolean* result);

        MakeActive();

        IsActive(
            [out] Boolean* isActive);

        /**
         * Finds a view that was identified by the id attribute from the XML that
         * was processed in {@link android.app.Activity#onCreate}.  This will
         * implicitly call {@link #getDecorView} for you, with all of the
         * associated side-effects.
         *
         * @return The view if found or null otherwise.
         */
        FindViewById(
            [in] Int32 id,
            [out] IView** view);

        /**
         * Convenience for
         * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)}
         * to set the screen content from a layout resource.  The resource will be
         * inflated, adding all top-level views to the screen.
         *
         * @param layoutResID Resource ID to be inflated.
         * @see #setContentView(View, android.view.ViewGroup.LayoutParams)
         */
        SetContentView(
            [in] Int32 layoutResID);

        /**
         * Convenience for
         * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)}
         * set the screen content to an explicit view.  This view is placed
         * directly into the screen's view hierarchy.  It can itself be a complex
         * view hierarhcy.
         *
         * @param view The desired content to display.
         * @see #setContentView(View, android.view.ViewGroup.LayoutParams)
         */
        SetContentView(
            [in] IView* view);

        /**
         * Set the screen content to an explicit view.  This view is placed
         * directly into the screen's view hierarchy.  It can itself be a complex
         * view hierarchy.
         *
         * <p>Note that calling this function "locks in" various characteristics
         * of the window that can not, from this point forward, be changed: the
         * features that have been requested with {@link #requestFeature(int)},
         * and certain window flags as described in {@link #setFlags(int, int)}.
         *
         * @param view The desired content to display.
         * @param params Layout parameters for the view.
         */
        SetContentView(
            [in] IView* view,
            [in] IViewGroupLayoutParams* params);

        /**
         * Variation on
         * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)}
         * to add an additional content view to the screen.  Added after any existing
         * ones in the screen -- existing views are NOT removed.
         *
         * @param view The desired content to display.
         * @param params Layout parameters for the view.
         */
        AddContentView(
            [in] IView* view,
            [in] IViewGroupLayoutParams* params);

        /**
         * Return the view in this Window that currently has focus, or null if
         * there are none.  Note that this does not look in any containing
         * Window.
         *
         * @return View The current View with focus or null.
         */
        // @Nullable
        GetCurrentFocus(
            [out] IView** view);

        /**
         * Quick access to the {@link LayoutInflater} instance that this Window
         * retrieved from its Context.
         *
         * @return LayoutInflater The shared LayoutInflater.
         */
        // @NonNull
        GetLayoutInflater(
            [out] ILayoutInflater** inflater);

        SetTitle(
            [in] ICharSequence* title);

        // @Deprecated
        SetTitleColor(
            [in] Int32 textColor);

        OpenPanel(
            [in] Int32 featureId,
            [in] IKeyEvent* event);

        ClosePanel(
            [in] Int32 featureId);

        TogglePanel(
            [in] Int32 featureId,
            [in] IKeyEvent* event);

        InvalidatePanelMenu(
            [in] Int32 featureId);

        PerformPanelShortcut(
            [in] Int32 featureId,
            [in] Int32 keyCode,
            [in] IKeyEvent* event,
            [in] Int32 flags,
            [out] Boolean* succeeded);

        PerformPanelIdentifierAction(
            [in] Int32 featureId,
            [in] Int32 id,
            [in] Int32 flags,
            [out] Boolean* succeeded);

        CloseAllPanels();

        PerformContextMenuIdentifierAction(
            [in] Int32 id,
            [in] Int32 flags,
            [out] Boolean* succeeded);

        /**
         * Should be called when the configuration is changed.
         *
         * @param newConfig The new configuration.
         */
        OnConfigurationChanged(
            [in] IConfiguration* newConfig);

        /**
         * Change the background of this window to a Drawable resource. Setting the
         * background to null will make the window be opaque. To make the window
         * transparent, you can use an empty drawable (for instance a ColorDrawable
         * with the color 0 or the system drawable android:drawable/empty.)
         *
         * @param resid The resource identifier of a drawable resource which will be
         *              installed as the new background.
         */
        SetBackgroundDrawableResource(
            [in] Int32 resid);

        /**
         * Change the background of this window to a custom Drawable. Setting the
         * background to null will make the window be opaque. To make the window
         * transparent, you can use an empty drawable (for instance a ColorDrawable
         * with the color 0 or the system drawable android:drawable/empty.)
         *
         * @param drawable The new Drawable to use for this window's background.
         */
        SetBackgroundDrawable(
            [in] IDrawable* drawable);

        /**
         * Set the value for a drawable feature of this window, from a resource
         * identifier.  You must have called requestFeauture(featureId) before
         * calling this function.
         *
         * @see android.content.res.Resources#getDrawable(int)
         *
         * @param featureId The desired drawable feature to change, defined as a
         * constant by Window.
         * @param resId Resource identifier of the desired image.
         */
        SetFeatureDrawableResource(
            [in] Int32 featureId,
            [in] Int32 resId);

        /**
         * Set the value for a drawable feature of this window, from a URI. You
         * must have called requestFeature(featureId) before calling this
         * function.
         *
         * <p>The only URI currently supported is "content:", specifying an image
         * in a content provider.
         *
         * @see android.widget.ImageView#setImageURI
         *
         * @param featureId The desired drawable feature to change. Features are
         * constants defined by Window.
         * @param uri The desired URI.
         */
        SetFeatureDrawableUri(
            [in] Int32 featureId,
            [in] IUri* uri);

        /**
         * Set an explicit Drawable value for feature of this window. You must
         * have called requestFeature(featureId) before calling this function.
         *
         * @param featureId The desired drawable feature to change.
         * Features are constants defined by Window.
         * @param drawable A Drawable object to display.
         */
        SetFeatureDrawable(
            [in] Int32 featureId,
            [in] IDrawable* drawable);

        /**
         * Set a custom alpha value for the given drawale feature, controlling how
         * much the background is visible through it.
         *
         * @param featureId The desired drawable feature to change.
         * Features are constants defined by Window.
         * @param alpha The alpha amount, 0 is completely transparent and 255 is
         *              completely opaque.
         */
        SetFeatureDrawableAlpha(
            [in] Int32 featureId,
            [in] Int32 alpha);

        /**
         * Set the integer value for a feature.  The range of the value depends on
         * the feature being set.  For FEATURE_PROGRESSS, it should go from 0 to
         * 10000. At 10000 the progress is complete and the indicator hidden.
         *
         * @param featureId The desired feature to change.
         * Features are constants defined by Window.
         * @param value The value for the feature.  The interpretation of this
         *              value is feature-specific.
         */
        SetFeatureInt(
            [in] Int32 featureId,
            [in] Int32 value);

        /**
         * Request that key events come to this activity. Use this if your
         * activity has no views with focus, but the activity still wants
         * a chance to process key events.
         */
        TakeKeyEvents(
            [in] Boolean get);

        /**
         * Used by custom windows, such as Dialog, to pass the key press event
         * further down the view hierarchy. Application developers should
         * not need to implement or call this.
         *
         */
        SuperDispatchKeyEvent(
            [in] IKeyEvent* event,
            [out] Boolean* succeeded);

        /**
         * Used by custom windows, such as Dialog, to pass the key shortcut press event
         * further down the view hierarchy. Application developers should
         * not need to implement or call this.
         *
         */
        SuperDispatchKeyShortcutEvent(
            [in] IKeyEvent* event,
            [out] Boolean* succeeded);

        /**
         * Used by custom windows, such as Dialog, to pass the touch screen event
         * further down the view hierarchy. Application developers should
         * not need to implement or call this.
         *
         */
        SuperDispatchTouchEvent(
            [in] IMotionEvent* event,
            [out] Boolean* succeeded);

        /**
         * Used by custom windows, such as Dialog, to pass the trackball event
         * further down the view hierarchy. Application developers should
         * not need to implement or call this.
         *
         */
        SuperDispatchTrackballEvent(
            [in] IMotionEvent* event,
            [out] Boolean* succeeded);

        /**
         * Used by custom windows, such as Dialog, to pass the generic motion event
         * further down the view hierarchy. Application developers should
         * not need to implement or call this.
         *
         */
        SuperDispatchGenericMotionEvent(
            [in] IMotionEvent* event,
            [out] Boolean* succeeded);

        /**
         * Retrieve the top-level window decor view (containing the standard
         * window frame/decorations and the client's content inside of that), which
         * can be added as a window to the window manager.
         *
         * <p><em>Note that calling this function for the first time "locks in"
         * various window characteristics as described in
         * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)}.</em></p>
         *
         * @return Returns the top-level window decor view.
         */
        GetDecorView(
            [out] IView** view);

        /**
         * Retrieve the current decor view, but only if it has already been created;
         * otherwise returns null.
         *
         * @return Returns the top-level window decor or null.
         * @see #getDecorView
         */
        PeekDecorView(
            [out] IView** view);

        SaveHierarchyState(
            [out] IBundle** instanceState);

        RestoreHierarchyState(
            [in] IBundle* savedInstanceState);

        /**
         * Query for the availability of a certain feature.
         *
         * @param feature The feature ID to check
         * @return true if the feature is enabled, false otherwise.
         */
        HasFeature(
            [in] Int32 feature,
            [out] Boolean* hasFeature);

        SetChildDrawable(
            [in] Int32 featureId,
            [in] IDrawable* drawable);

        SetChildInt(
            [in] Int32 featureId,
            [in] Int32 value);

        /**
         * Is a keypress one of the defined shortcut keys for this window.
         * @param keyCode the key code from {@link android.view.KeyEvent} to check.
         * @param event the {@link android.view.KeyEvent} to use to help check.
         */
        IsShortcutKey(
            [in] Int32 keyCode,
            [in] IKeyEvent* event,
            [out] Boolean* isShortcutKey);

        /**
         * @see android.app.Activity#setVolumeControlStream(int)
         */
        SetVolumeControlStream(
            [in] Int32 streamType);

        /**
         * @see android.app.Activity#getVolumeControlStream()
         */
        GetVolumeControlStream(
            [out] Int32* streamType);

        /**
         * Sets a {@link MediaController} to send media keys and volume changes to.
         * If set, this should be preferred for all media keys and volume requests
         * sent to this window.
         *
         * @param controller The controller for the session which should receive
         *            media keys and volume changes.
         * @see android.app.Activity#setMediaController(android.media.session.MediaController)
         */
        SetMediaController(
            [in] IMediaController* controller);

        /**
         * Gets the {@link MediaController} that was previously set.
         *
         * @return The controller which should receive events.
         * @see #setMediaController(android.media.session.MediaController)
         * @see android.app.Activity#getMediaController()
         */
        GetMediaController(
            [out] IMediaController** controller);

        /**
         * Set extra options that will influence the UI for this window.
         * @param uiOptions Flags specifying extra options for this window.
         */
        SetUiOptions(
            [in] Int32 uiOptions);

        /**
         * Set extra options that will influence the UI for this window.
         * Only the bits filtered by mask will be modified.
         * @param uiOptions Flags specifying extra options for this window.
         * @param mask Flags specifying which options should be modified. Others will remain unchanged.
         */
        SetUiOptions(
            [in] Int32 uiOptions,
            [in] Int32 mask);

        /**
         * Set the primary icon for this window.
         *
         * @param resId resource ID of a drawable to set
         */
        SetIcon(
            [in] Int32 resId);

        /**
         * Set the default icon for this window.
         * This will be overridden by any other icon set operation which could come from the
         * theme or another explicit set.
         *
         * @hide
         */
        SetDefaultIcon(
            [in] Int32 resId);

        /**
         * Set the logo for this window. A logo is often shown in place of an
         * {@link #setIcon(int) icon} but is generally wider and communicates window title information
         * as well.
         *
         * @param resId resource ID of a drawable to set
         */
        SetLogo(
            [in] Int32 resId);

        /**
         * Set the default logo for this window.
         * This will be overridden by any other logo set operation which could come from the
         * theme or another explicit set.
         *
         * @hide
         */
        SetDefaultLogo(
            [in] Int32 resId);

        /**
         * Set focus locally. The window should have the
         * {@link WindowManager.LayoutParams#FLAG_LOCAL_FOCUS_MODE} flag set already.
         * @param hasFocus Whether this window has focus or not.
         * @param inTouchMode Whether this window is in touch mode or not.
         */
        SetLocalFocus(
            [in] Boolean hasFocus,
            [in] Boolean inTouchMode);

        /**
         * Inject an event to window locally.
         * @param event A key or touch event to inject to this window.
         */
        InjectInputEvent(
            [in] IInputEvent* event);

        /**
         * Retrieve the {@link TransitionManager} responsible for  for default transitions
         * in this window. Requires {@link #FEATURE_CONTENT_TRANSITIONS}.
         *
         * <p>This method will return non-null after content has been initialized (e.g. by using
         * {@link #setContentView}) if {@link #FEATURE_CONTENT_TRANSITIONS} has been granted.</p>
         *
         * @return This window's content TransitionManager or null if none is set.
         */
        GetTransitionManager(
            [out] ITransitionManager** manager);

        /**
         * Set the {@link TransitionManager} to use for default transitions in this window.
         * Requires {@link #FEATURE_CONTENT_TRANSITIONS}.
         *
         * @param tm The TransitionManager to use for scene changes.
         */
        SetTransitionManager(
            [in] ITransitionManager* manager);

        /**
         * Retrieve the {@link Scene} representing this window's current content.
         * Requires {@link #FEATURE_CONTENT_TRANSITIONS}.
         *
         * <p>This method will return null if the current content is not represented by a Scene.</p>
         *
         * @return Current Scene being shown or null
         */
        GetContentScene(
            [out] IScene** scene);

        /**
         * Sets the Transition that will be used to move Views into the initial scene. The entering
         * Views will be those that are regular Views or ViewGroups that have
         * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as entering is governed by changing visibility from
         * {@link View#INVISIBLE} to {@link View#VISIBLE}. If <code>transition</code> is null,
         * entering Views will remain unaffected.
         *
         * @param transition The Transition to use to move Views into the initial Scene.
         * @attr ref android.R.styleable#Window_windowEnterTransition
         */
        SetEnterTransition(
            [in] ITransition* transition);

        /**
         * Sets the Transition that will be used to move Views out of the scene when the Window is
         * preparing to close, for example after a call to
         * {@link android.app.Activity#finishAfterTransition()}. The exiting
         * Views will be those that are regular Views or ViewGroups that have
         * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as entering is governed by changing visibility from
         * {@link View#VISIBLE} to {@link View#INVISIBLE}. If <code>transition</code> is null,
         * entering Views will remain unaffected. If nothing is set, the default will be to
         * use the same value as set in {@link #setEnterTransition(android.transition.Transition)}.
         *
         * @param transition The Transition to use to move Views out of the Scene when the Window
         *                   is preparing to close.
         * @attr ref android.R.styleable#Window_windowReturnTransition
         */
        SetReturnTransition(
            [in] ITransition* transition);

        /**
         * Sets the Transition that will be used to move Views out of the scene when starting a
         * new Activity. The exiting Views will be those that are regular Views or ViewGroups that
         * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as exiting is governed by changing visibility
         * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will
         * remain unaffected. Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use to move Views out of the scene when calling a
         *                   new Activity.
         * @attr ref android.R.styleable#Window_windowExitTransition
         */
        SetExitTransition(
            [in] ITransition* transition);

        /**
         * Sets the Transition that will be used to move Views in to the scene when returning from
         * a previously-started Activity. The entering Views will be those that are regular Views
         * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions
         * will extend {@link android.transition.Visibility} as exiting is governed by changing
         * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null,
         * the views will remain unaffected. If nothing is set, the default will be to use the same
         * transition as {@link #setExitTransition(android.transition.Transition)}.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use to move Views into the scene when reentering from a
         *                   previously-started Activity.
         * @attr ref android.R.styleable#Window_windowReenterTransition
         */
        SetReenterTransition(
            [in] ITransition* transition);

        /**
         * Returns the transition used to move Views into the initial scene. The entering
         * Views will be those that are regular Views or ViewGroups that have
         * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as entering is governed by changing visibility from
         * {@link View#INVISIBLE} to {@link View#VISIBLE}. If <code>transition</code> is null,
         * entering Views will remain unaffected.  Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return the Transition to use to move Views into the initial Scene.
         * @attr ref android.R.styleable#Window_windowEnterTransition
         */
        GetEnterTransition(
            [out] ITransition** transition);

        /**
         * Returns he Transition that will be used to move Views out of the scene when the Window is
         * preparing to close, for example after a call to
         * {@link android.app.Activity#finishAfterTransition()}. The exiting
         * Views will be those that are regular Views or ViewGroups that have
         * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as entering is governed by changing visibility from
         * {@link View#VISIBLE} to {@link View#INVISIBLE}.
         *
         * @return The Transition to use to move Views out of the Scene when the Window
         *         is preparing to close.
         * @attr ref android.R.styleable#Window_windowReturnTransition
         */
        GetReturnTransition(
            [out] ITransition** transition);

        /**
         * Returns the Transition that will be used to move Views out of the scene when starting a
         * new Activity. The exiting Views will be those that are regular Views or ViewGroups that
         * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
         * {@link android.transition.Visibility} as exiting is governed by changing visibility
         * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will
         * remain unaffected. Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return the Transition to use to move Views out of the scene when calling a
         * new Activity.
         * @attr ref android.R.styleable#Window_windowExitTransition
         */
        GetExitTransition(
            [out] ITransition** transition);

        /**
         * Returns the Transition that will be used to move Views in to the scene when returning from
         * a previously-started Activity. The entering Views will be those that are regular Views
         * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions
         * will extend {@link android.transition.Visibility} as exiting is governed by changing
         * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return The Transition to use to move Views into the scene when reentering from a
         *         previously-started Activity.
         * @attr ref android.R.styleable#Window_windowReenterTransition
         */
        GetReenterTransition(
            [out] ITransition** transition);

        /**
         * Sets the Transition that will be used for shared elements transferred into the content
         * Scene. Typical Transitions will affect size and location, such as
         * {@link android.transition.ChangeBounds}. A null
         * value will cause transferred shared elements to blink to the final position.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use for shared elements transferred into the content
         *                   Scene.
         * @attr ref android.R.styleable#Window_windowSharedElementEnterTransition
         */
        SetSharedElementEnterTransition(
            [in] ITransition* transition);

        /**
         * Sets the Transition that will be used for shared elements transferred back to a
         * calling Activity. Typical Transitions will affect size and location, such as
         * {@link android.transition.ChangeBounds}. A null
         * value will cause transferred shared elements to blink to the final position.
         * If no value is set, the default will be to use the same value as
         * {@link #setSharedElementEnterTransition(android.transition.Transition)}.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use for shared elements transferred out of the content
         *                   Scene.
         * @attr ref android.R.styleable#Window_windowSharedElementReturnTransition
         */
        SetSharedElementReturnTransition(
            [in] ITransition* transition);

        /**
         * Returns the Transition that will be used for shared elements transferred into the content
         * Scene. Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return Transition to use for sharend elements transferred into the content Scene.
         * @attr ref android.R.styleable#Window_windowSharedElementEnterTransition
         */
        GetSharedElementEnterTransition(
            [out] ITransition** transition);

        /**
         * Returns the Transition that will be used for shared elements transferred back to a
         * calling Activity. Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return Transition to use for sharend elements transferred into the content Scene.
         * @attr ref android.R.styleable#Window_windowSharedElementReturnTransition
         */
        GetSharedElementReturnTransition(
            [out] ITransition** transition);

        /**
         * Sets the Transition that will be used for shared elements after starting a new Activity
         * before the shared elements are transferred to the called Activity. If the shared elements
         * must animate during the exit transition, this Transition should be used. Upon completion,
         * the shared elements may be transferred to the started Activity.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use for shared elements in the launching Window
         *                   prior to transferring to the launched Activity's Window.
         * @attr ref android.R.styleable#Window_windowSharedElementExitTransition
         */
        SetSharedElementExitTransition(
            [in] ITransition* transition);

        /**
         * Sets the Transition that will be used for shared elements reentering from a started
         * Activity after it has returned the shared element to it start location. If no value
         * is set, this will default to
         * {@link #setSharedElementExitTransition(android.transition.Transition)}.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @param transition The Transition to use for shared elements in the launching Window
         *                   after the shared element has returned to the Window.
         * @attr ref android.R.styleable#Window_windowSharedElementReenterTransition
         */
        SetSharedElementReenterTransition(
            [in] ITransition* transition);

        /**
         * Returns the Transition to use for shared elements in the launching Window prior
         * to transferring to the launched Activity's Window.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return the Transition to use for shared elements in the launching Window prior
         * to transferring to the launched Activity's Window.
         * @attr ref android.R.styleable#Window_windowSharedElementExitTransition
         */
        GetSharedElementExitTransition(
            [out] ITransition** transition);

        /**
         * Returns the Transition that will be used for shared elements reentering from a started
         * Activity after it has returned the shared element to it start location.
         * Requires {@link #FEATURE_ACTIVITY_TRANSITIONS}.
         *
         * @return the Transition that will be used for shared elements reentering from a started
         * Activity after it has returned the shared element to it start location.
         * @attr ref android.R.styleable#Window_windowSharedElementReenterTransition
         */
        GetSharedElementReenterTransition(
            [out] ITransition** transition);

        /**
         * Controls how the transition set in
         * {@link #setEnterTransition(android.transition.Transition)} overlaps with the exit
         * transition of the calling Activity. When true, the transition will start as soon as possible.
         * When false, the transition will wait until the remote exiting transition completes before
         * starting.
         *
         * @param allow true to start the enter transition when possible or false to
         *              wait until the exiting transition completes.
         * @attr ref android.R.styleable#Window_windowAllowEnterTransitionOverlap
         */
        SetAllowEnterTransitionOverlap(
            [in] Boolean result);

        /**
         * Returns how the transition set in
         * {@link #setEnterTransition(android.transition.Transition)} overlaps with the exit
         * transition of the calling Activity. When true, the transition will start as soon as possible.
         * When false, the transition will wait until the remote exiting transition completes before
         * starting.
         *
         * @return true when the enter transition should start as soon as possible or false to
         * when it should wait until the exiting transition completes.
         * @attr ref android.R.styleable#Window_windowAllowEnterTransitionOverlap
         */
        GetAllowEnterTransitionOverlap(
            [out] Boolean* result);

        /**
         * Controls how the transition set in
         * {@link #setExitTransition(android.transition.Transition)} overlaps with the exit
         * transition of the called Activity when reentering after if finishes. When true,
         * the transition will start as soon as possible. When false, the transition will wait
         * until the called Activity's exiting transition completes before starting.
         *
         * @param allow true to start the transition when possible or false to wait until the
         *              called Activity's exiting transition completes.
         * @attr ref android.R.styleable#Window_windowAllowReturnTransitionOverlap
         */
        SetAllowReturnTransitionOverlap(
            [in] Boolean allow);

        /**
         * TODO: remove this.
         * @hide
         */
        SetAllowExitTransitionOverlap(
            [in] Boolean allow);

        /**
         * Returns how the transition set in
         * {@link #setExitTransition(android.transition.Transition)} overlaps with the exit
         * transition of the called Activity when reentering after if finishes. When true,
         * the transition will start as soon as possible. When false, the transition will wait
         * until the called Activity's exiting transition completes before starting.
         *
         * @return true when the transition should start when possible or false when it should wait
         * until the called Activity's exiting transition completes.
         * @attr ref android.R.styleable#Window_windowAllowReturnTransitionOverlap
         */
        GetAllowReturnTransitionOverlap(
            [out] Boolean* allow);

        /**
         * TODO: remove this.
         * @hide
         */
        GetAllowExitTransitionOverlap(
            [out] Boolean* allow);

        /**
         * Returns the duration, in milliseconds, of the window background fade
         * when transitioning into or away from an Activity when called with an Activity Transition.
         * <p>When executing the enter transition, the background starts transparent
         * and fades in. This requires {@link #FEATURE_ACTIVITY_TRANSITIONS}. The default is
         * 300 milliseconds.</p>
         *
         * @return The duration of the window background fade to opaque during enter transition.
         * @see #getEnterTransition()
         * @attr ref android.R.styleable#Window_windowTransitionBackgroundFadeDuration
         */
        GetTransitionBackgroundFadeDuration(
            [out] Int64* result);

        /**
         * Sets the duration, in milliseconds, of the window background fade
         * when transitioning into or away from an Activity when called with an Activity Transition.
         * <p>When executing the enter transition, the background starts transparent
         * and fades in. This requires {@link #FEATURE_ACTIVITY_TRANSITIONS}. The default is
         * 300 milliseconds.</p>
         *
         * @param fadeDurationMillis The duration of the window background fade to or from opaque
         *                           during enter transition.
         * @see #setEnterTransition(android.transition.Transition)
         * @attr ref android.R.styleable#Window_windowTransitionBackgroundFadeDuration
         */
        SetTransitionBackgroundFadeDuration(
            [in] Int64 fadeDurationMillis);

        /**
         * Returns <code>true</code> when shared elements should use an Overlay during
         * shared element transitions or <code>false</code> when they should animate as
         * part of the normal View hierarchy. The default value is true.
         *
         * @return <code>true</code> when shared elements should use an Overlay during
         * shared element transitions or <code>false</code> when they should animate as
         * part of the normal View hierarchy.
         * @attr ref android.R.styleable#Window_windowSharedElementsUseOverlay
         */
        GetSharedElementsUseOverlay(
            [out] Boolean* result);

        /**
         * Sets whether or not shared elements should use an Overlay during shared element transitions.
         * The default value is true.
         *
         * @param sharedElementsUseOverlay <code>true</code> indicates that shared elements should
         *                                 be transitioned with an Overlay or <code>false</code>
         *                                 to transition within the normal View hierarchy.
         * @attr ref android.R.styleable#Window_windowSharedElementsUseOverlay
         */
        SetSharedElementsUseOverlay(
            [in] Boolean sharedElementsUseOverlay);

        /**
         * @return the color of the status bar.
         */
        GetStatusBarColor(
            [out] Int32* color);

        /**
         * Sets the color of the status bar to {@param color}.
         *
         * For this to take effect,
         * the window must be drawing the system bar backgrounds with
         * {@link android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS} and
         * {@link android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_STATUS} must not be set.
         *
         * If {@param color} is not opaque, consider setting
         * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and
         * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
         * <p>
         * The transitionName for the view background will be "android:status:background".
         * </p>
         */
        SetStatusBarColor(
            [in] Int32 color);

        /**
         * @return the color of the navigation bar.
         */
        GetNavigationBarColor(
            [out] Int32* result);

        /**
         * Sets the color of the navigation bar to {@param color}.
         *
         * For this to take effect,
         * the window must be drawing the system bar backgrounds with
         * {@link android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS} and
         * {@link android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_NAVIGATION} must not be set.
         *
         * If {@param color} is not opaque, consider setting
         * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and
         * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}.
         * <p>
         * The transitionName for the view background will be "android:navigation:background".
         * </p>
         */
        SetNavigationBarColor(
            [in] Int32 result);
    }

    } // namespace View
    } // namepsace Droid
    } // namespace Elastos
}
