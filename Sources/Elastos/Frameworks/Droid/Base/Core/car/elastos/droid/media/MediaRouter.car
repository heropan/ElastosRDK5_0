
module
{
    interface Elastos.Utility.IList;
    interface Elastos.Core.ICharSequence;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.Res.IResources;
    interface Elastos.Droid.Hardware.Display.IDisplayListener;
    interface Elastos.Droid.Hardware.Display.IWifiDisplay;
    interface Elastos.Droid.Hardware.Display.IWifiDisplayStatus;
    interface Elastos.Droid.Graphics.Drawable.IDrawable;
    interface Elastos.Droid.Media.IMediaRouter;
    interface Elastos.Droid.Media.IMediaRouterClientStateRouteInfo;
    interface Elastos.Droid.Media.IMediaRouterRouteInfo;
    interface Elastos.Droid.Media.IMediaRouterRouteCategory;
    interface Elastos.Droid.View.IDisplay;

    namespace Elastos {
    namespace Droid {
    namespace Media {

    /**
     * @Involve
     * interface IDisplayListener
     */
    [local]
    interface IMediaRouterStatic
    {
        // Called after sStatic is initialized
        StartMonitoringRoutes(
            [in] IContext* appContext);

        UpdateAudioRoutes(
            [in] IAudioRoutesInfo* newRoutes);

        IsBluetoothA2dpOn(
            [out] Boolean* result);

        UpdateDiscoveryRequest();

        GetAllPresentationDisplays(
            [out, callee] ArrayOf<IDisplay*>* result);

        SetSelectedRoute(
            [in] IMediaRouterRouteInfo* info,
            [in] Boolean isExplicit);

        RebindAsUser(
            [in] Int32 userId);

        PublishClientDiscoveryRequest();

        PublishClientSelectedRoute(
            [in] Boolean isExplicit);

        UpdateClientState();

        RequestSetVolume(
            [in] IMediaRouterRouteInfo* route,
            [in] Int32 volume);

        RequestUpdateVolume(
            [in] IMediaRouterRouteInfo* route,
            [in] Int32 direction);

        MakeGlobalRoute(
            [in] IMediaRouterClientStateRouteInfo* globalRoute,
            [out] IMediaRouterRouteInfo** result);

        UpdateGlobalRoute(
            [in] IMediaRouterRouteInfo* route,
            [in] IMediaRouterClientStateRouteInfo* globalRoute);

        FindGlobalRoute(
            [in] String globalRouteId,
            [out] IMediaRouterRouteInfo** result);
    }

    interface IMediaRouterStaticClient
    {
    }

    /**
     * Information about a route that consists of multiple other routes in a group.
     */
    /**
     * @Involve
     * interface Elastos.Droid.Media.IMediaRouterRouteInfo
     */
    interface IMediaRouterRouteGroup {
        /**
         * Add a route to this group. The route must not currently belong to another group.
         *
         * @param route route to add to this group
         */
        AddRoute(
            [in] IMediaRouterRouteInfo * route);

        /**
         * Add a route to this group before the specified index.
         *
         * @param route route to add
         * @param insertAt insert the new route before this index
         */
        AddRoute(
            [in] IMediaRouterRouteInfo * route,
            [in] Int32 insertAt);

        /**
         * Remove a route from this group.
         *
         * @param route route to remove
         */
        RemoveRoute(
            [in] IMediaRouterRouteInfo * route);

        /**
         * Remove the route at the specified index from this group.
         *
         * @param index index of the route to remove
         */
        RemoveRoute(
            [in] Int32 index);

        /**
         * @return The number of routes in this group
         */
        GetRouteCount(
            [out] Int32 * result);

        /**
         * Return the route in this group at the specified index
         *
         * @param index Index to fetch
         * @return The route at index
         */
        GetRouteAt(
            [in] Int32 index,
            [out] IMediaRouterRouteInfo ** result);

        /**
         * Set an icon that will be used to represent this group.
         * The system may use this icon in picker UIs or similar.
         *
         * @param icon icon drawable to use to represent this group
         */
        SetIconDrawable(
            [in] IDrawable * icon);

        /**
         * Set an icon that will be used to represent this group.
         * The system may use this icon in picker UIs or similar.
         *
         * @param resId Resource ID of an icon drawable to use to represent this group
         */
        SetIconResource(
            [in] Int32 resId);
    }

    /**
     * Information about a media route.
     */
    [local]
    interface IMediaRouterRouteInfo {
        /** @hide */ const Int32 STATUS_NONE = 0;
        /** @hide */ const Int32 STATUS_SCANNING = 1;
        /** @hide */ const Int32 STATUS_CONNECTING = 2;
        /** @hide */ const Int32 STATUS_AVAILABLE = 3;
        /** @hide */ const Int32 STATUS_NOT_AVAILABLE = 4;
        /** @hide */ const Int32 STATUS_IN_USE = 5;
        /** @hide */ const Int32 STATUS_CONNECTED = 6;

        /**
         * The default playback type, "local", indicating the presentation of the media is happening
         * on the same device (e.g. a phone, a tablet) as where it is controlled from.
         * @see #getPlaybackType()
         */
        const Int32 PLAYBACK_TYPE_LOCAL = 0;
        /**
         * A playback type indicating the presentation of the media is happening on
         * a different device (i.e. the remote device) than where it is controlled from.
         * @see #getPlaybackType()
         */
        const Int32 PLAYBACK_TYPE_REMOTE = 1;
        /**
         * Playback information indicating the playback volume is fixed, i.e. it cannot be
         * controlled from this object. An example of fixed playback volume is a remote player,
         * playing over HDMI where the user prefers to control the volume on the HDMI sink, rather
         * than attenuate at the source.
         * @see #getVolumeHandling()
         */
        const Int32 PLAYBACK_VOLUME_FIXED = 0;
        /**
         * Playback information indicating the playback volume is variable and can be controlled
         * from this object.
         * @see #getVolumeHandling()
         */
        const Int32 PLAYBACK_VOLUME_VARIABLE = 1;

        /**
         * Gets the user-visible name of the route.
         * <p>
         * The route name identifies the destination represented by the route.
         * It may be a user-supplied name, an alias, or device serial number.
         * </p>
         *
         * @return The user-visible name of a media route.  This is the string presented
         * to users who may select this as the active route.
         */
        GetName(
            [out] ICharSequence ** result);

        SetName(
            [in] ICharSequence* name);

        /**
         * Return the properly localized/resource user-visible name of this route.
         * <p>
         * The route name identifies the destination represented by the route.
         * It may be a user-supplied name, an alias, or device serial number.
         * </p>
         *
         * @param context Context used to resolve the correct configuration to load
         * @return The user-visible name of a media route.  This is the string presented
         * to users who may select this as the active route.
         */
        GetName(
            [in] IContext * context,
            [out] ICharSequence ** result);

        /**
         * Gets the user-visible description of the route.
         * <p>
         * The route description describes the kind of destination represented by the route.
         * It may be a user-supplied string, a model number or brand of device.
         * </p>
         *
         * @return The description of the route, or null if none.
         */
        GetDescription(
            [out] ICharSequence ** result);

        /**
         * @return The user-visible status for a media route. This may include a description
         * of the currently playing media, if available.
         */
        GetStatus(
            [out] ICharSequence ** result);

        /**
         * Set this route's status by predetermined status code. If the caller
         * should dispatch a route changed event this call will return true;
         */
        SetRealStatusCode(
            [in] Int32 statusCode,
            [out] Boolean* result);

        /**
         * Resolves the status code whenever the real status code or selection state
         * changes.
         */
        ResolveStatusCode(
            [out] Boolean* result);

        /**
         * @hide
         */
        GetStatusCode(
            [out] Int32 * result);

        /**
         * @return A media type flag set describing which types this route supports.
         */
        GetSupportedTypes(
            [out] Int32 * result);

        SetSupportedTypes(
            [in] Int32 type);

        /** @hide */
        MatchesTypes(
            [in] Int32 types,
            [out] Boolean * result);

        /**
         * @return The group that this route belongs to.
         */
        GetGroup(
            [out] IMediaRouterRouteGroup ** result);

        /**
         * @return the category this route belongs to.
         */
        GetCategory(
            [out] IMediaRouterRouteCategory ** result);

        /**
         * Get the icon representing this route.
         * This icon will be used in picker UIs if available.
         *
         * @return the icon representing this route or null if no icon is available
         */
        GetIconDrawable(
            [out] IDrawable ** result);

        /**
         * Set an application-specific tag object for this route.
         * The application may use this to store arbitrary data associated with the
         * route for internal tracking.
         *
         * <p>Note that the lifespan of a route may be well past the lifespan of
         * an Activity or other Context; take care that objects you store here
         * will not keep more data in memory alive than you intend.</p>
         *
         * @param tag Arbitrary, app-specific data for this route to hold for later use
         */
        SetTag(
            [in] IInterface * tag);

        /**
         * @return The tag object previously set by the application
         * @see #setTag(Object)
         */
        GetTag(
            [out] IInterface ** result);

        /**
         * @return the type of playback associated with this route
         * @see UserRouteInfo#setPlaybackType(int)
         */
        GetPlaybackType(
            [out] Int32 * result);

        /**
         * @return the stream over which the playback associated with this route is performed
         * @see UserRouteInfo#setPlaybackStream(int)
         */
        GetPlaybackStream(
            [out] Int32 * result);

        /**
         * Return the current volume for this route. Depending on the route, this may only
         * be valid if the route is currently selected.
         *
         * @return the volume at which the playback associated with this route is performed
         * @see UserRouteInfo#setVolume(int)
         */
        GetVolume(
            [out] Int32 * result);

        /**
         * Request a volume change for this route.
         * @param volume value between 0 and getVolumeMax
         */
        RequestSetVolume(
            [in] Int32 volume);

        /**
         * Request an incremental volume update for this route.
         * @param direction Delta to apply to the current volume
         */
        RequestUpdateVolume(
            [in] Int32 direction);

        /**
         * @return the maximum volume at which the playback associated with this route is performed
         * @see UserRouteInfo#setVolumeMax(int)
         */
        GetVolumeMax(
            [out] Int32 * result);

        /**
         * @return how volume is handling on the route
         * @see UserRouteInfo#setVolumeHandling(int)
         */
        GetVolumeHandling(
            [out] Int32 * result);

        /**
         * Gets the {@link Display} that should be used by the application to show
         * a {@link android.app.Presentation} on an external display when this route is selected.
         * Depending on the route, this may only be valid if the route is currently
         * selected.
         * <p>
         * The preferred presentation display may change independently of the route
         * being selected or unselected.  For example, the presentation display
         * of the default system route may change when an external HDMI display is connected
         * or disconnected even though the route itself has not changed.
         * </p><p>
         * This method may return null if there is no external display associated with
         * the route or if the display is not ready to show UI yet.
         * </p><p>
         * The application should listen for changes to the presentation display
         * using the {@link Callback#onRoutePresentationDisplayChanged} callback and
         * show or dismiss its {@link android.app.Presentation} accordingly when the display
         * becomes available or is removed.
         * </p><p>
         * This method only makes sense for {@link #ROUTE_TYPE_LIVE_VIDEO live video} routes.
         * </p>
         *
         * @return The preferred presentation display to use when this route is
         * selected or null if none.
         *
         * @see #ROUTE_TYPE_LIVE_VIDEO
         * @see android.app.Presentation
         */
        GetPresentationDisplay(
            [out] IDisplay ** result);

        UpdatePresentationDisplay(
            [out] Boolean* result);

        /** @hide */
        GetDeviceAddress(
            [out] String * result);

        /**
         * Returns true if this route is enabled and may be selected.
         *
         * @return True if this route is enabled.
         */
        IsEnabled(
            [out] Boolean * result);

        /**
         * Returns true if the route is in the process of connecting and is not
         * yet ready for use.
         *
         * @return True if this route is in the process of connecting.
         */
        IsConnecting(
            [out] Boolean * result);

        /** @hide */
        IsSelected(
            [out] Boolean * result);

        /** @hide */
        IsDefault(
            [out] Boolean * result);

        /** @hide */
        Select();

        SetStatusInt(
            [in] ICharSequence* status);

        RouteUpdated();
    }

    /**
     * Definition of a category of routes. All routes belong to a category.
     */
    [local]
    interface IMediaRouterRouteCategory {
        /**
         * @return the name of this route category
         */
        GetName(
            [out] ICharSequence ** result);

        /**
         * Return the properly localized/configuration dependent name of this RouteCategory.
         *
         * @param context Context to resolve name resources
         * @return the name of this route category
         */
        GetName(
            [in] IContext * context,
            [out] ICharSequence ** result);

        GetName(
            [in] IResources* res,
            [out] ICharSequence** result);

        /**
         * Return the current list of routes in this category that have been added
         * to the MediaRouter.
         *
         * <p>This list will not include routes that are nested within RouteGroups.
         * A RouteGroup is treated as a single route within its category.</p>
         *
         * @param out a List to fill with the routes in this category. If this parameter is
         *            non-null, it will be cleared, filled with the current routes with this
         *            category, and returned. If this parameter is null, a new List will be
         *            allocated to report the category's current routes.
         * @return A list with the routes in this category that have been added to the MediaRouter.
         */
        GetRoutes(
            [in] IList * outList,
            [out] IList ** result);

        /**
         * @return Flag set describing the route types supported by this category
         */
        GetSupportedTypes(
            [out] Int32 * result);

        /**
         * Return whether or not this category supports grouping.
         *
         * <p>If this method returns true, all routes obtained from this category
         * via calls to {@link #getRouteAt(int)} will be {@link MediaRouter.RouteGroup}s.</p>
         *
         * @return true if this category supports
         */
        IsGroupable(
            [out] Boolean * result);

        /**
         * @return true if this is the category reserved for system routes.
         * @hide
         */
        IsSystem(
            [out] Boolean * result);
    }

    [local]
    interface IMediaRouterRouteCallbackInfo
    {
        FilterRouteEvent(
            [in] IMediaRouterRouteInfo* route,
            [out] Boolean* result);

        FilterRouteEvent(
            [in] Int32 supportedTypes,
            [out] Boolean* result);
    }

    /**
     * Interface for receiving events about media routing changes.
     * All methods of this interface will be called from the application's main thread.
     * <p>
     * A Callback will only receive events relevant to routes that the callback
     * was registered for unless the {@link MediaRouter#CALLBACK_FLAG_UNFILTERED_EVENTS}
     * flag was specified in {@link MediaRouter#addCallback(int, Callback, int)}.
     * </p>
     *
     * @see MediaRouter#addCallback(int, Callback, int)
     * @see MediaRouter#removeCallback(Callback)
     */
    [local]
    interface IMediaRouterCallback {
        /**
         * Called when the supplied route becomes selected as the active route
         * for the given route type.
         *
         * @param router the MediaRouter reporting the event
         * @param type Type flag set indicating the routes that have been selected
         * @param info Route that has been selected for the given route types
         */
        OnRouteSelected(
            [in] IMediaRouter * router,
            [in] Int32 type,
            [in] IMediaRouterRouteInfo* info);

        /**
         * Called when the supplied route becomes unselected as the active route
         * for the given route type.
         *
         * @param router the MediaRouter reporting the event
         * @param type Type flag set indicating the routes that have been unselected
         * @param info Route that has been unselected for the given route types
         */
        OnRouteUnselected(
            [in] IMediaRouter * router,
            [in] Int32 type,
            [in] IMediaRouterRouteInfo * info);

        /**
         * Called when a route for the specified type was added.
         *
         * @param router the MediaRouter reporting the event
         * @param info Route that has become available for use
         */
        OnRouteAdded(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info);

        /**
         * Called when a route for the specified type was removed.
         *
         * @param router the MediaRouter reporting the event
         * @param info Route that has been removed from availability
         */
        OnRouteRemoved(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info);

        /**
         * Called when an aspect of the indicated route has changed.
         *
         * <p>This will not indicate that the types supported by this route have
         * changed, only that cosmetic info such as name or status have been updated.</p>
         *
         * @param router the MediaRouter reporting the event
         * @param info The route that was changed
         */
        OnRouteChanged(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info);

        /**
         * Called when a route is added to a group.
         *
         * @param router the MediaRouter reporting the event
         * @param info The route that was added
         * @param group The group the route was added to
         * @param index The route index within group that info was added at
         */
        OnRouteGrouped(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info,
            [in] IMediaRouterRouteGroup * group,
            [in] Int32 index);

        /**
         * Called when a route is removed from a group.
         *
         * @param router the MediaRouter reporting the event
         * @param info The route that was removed
         * @param group The group the route was removed from
         */
        OnRouteUngrouped(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info,
            [in] IMediaRouterRouteGroup * group);

        /**
         * Called when a route's volume changes.
         *
         * @param router the MediaRouter reporting the event
         * @param info The route with altered volume
         */
        OnRouteVolumeChanged(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info);

        /**
         * Called when a route's presentation display changes.
         * <p>
         * This method is called whenever the route's presentation display becomes
         * available, is removes or has changes to some of its properties (such as its size).
         * </p>
         *
         * @param router the MediaRouter reporting the event
         * @param info The route whose presentation display changed
         *
         * @see RouteInfo#getPresentationDisplay()
         */
        OnRoutePresentationDisplayChanged(
            [in] IMediaRouter * router,
            [in] IMediaRouterRouteInfo * info);
    }

    /**
     * Stub implementation of {@link MediaRouter.Callback}.
     * Each abstract method is defined as a no-op. Override just the ones
     * you need.
     */
    /**
     * @Involve
     * interface Elastos.Droid.Media.IMediaRouterCallback
     */
    interface IMediaRouterSimpleCallback {
    }

    /**
     * Interface for receiving events about volume changes.
     * All methods of this interface will be called from the application's main thread.
     *
     * <p>A VolumeCallback will only receive events relevant to routes that the callback
     * was registered for.</p>
     *
     * @see UserRouteInfo#setVolumeCallback(VolumeCallback)
     */
    [local]
    interface IMediaRouterVolumeCallback {
        /**
         * Called when the volume for the route should be increased or decreased.
         * @param info the route affected by this event
         * @param direction an integer indicating whether the volume is to be increased
         *     (positive value) or decreased (negative value).
         *     For bundled changes, the absolute value indicates the number of changes
         *     in the same direction, e.g. +3 corresponds to three "volume up" changes.
         */
        OnVolumeUpdateRequest(
            [in] IMediaRouterRouteInfo * info,
            [in] Int32 direction);
        /**
         * Called when the volume for the route should be set to the given value
         * @param info the route affected by this event
         * @param volume an integer indicating the new volume value that should be used, always
         *     between 0 and the value set by {@link UserRouteInfo#setVolumeMax(int)}.
         */
        OnVolumeSetRequest(
            [in] IMediaRouterRouteInfo * info,
            [in] Int32 volume);

    }

    [local]
    interface IMediaRouterVolumeCallbackInfo
    {
        SetVolumeCallback(
            [in] IMediaRouterVolumeCallback* vcb);

        GetVolumeCallback(
            [out] IMediaRouterVolumeCallback** vcb);

        SetRouteInfo(
            [in] IMediaRouterRouteInfo* route);

        GetRouteInfo(
            [out] IMediaRouterRouteInfo** route);
    }

    /**
     * Information about a route that the application may define and modify.
     * A user route defaults to {@link RouteInfo#PLAYBACK_TYPE_REMOTE} and
     * {@link RouteInfo#PLAYBACK_VOLUME_FIXED}.
     *
     * @see MediaRouter.RouteInfo
     */
    /**
     * @Involve
     * interface Elastos.Droid.Media.IMediaRouterRouteInfo
     */
    [local]
    interface IMediaRouterUserRouteInfo {
        /**
         * Set the user-visible name of this route.
         * @param name Name to display to the user to describe this route
         */
        SetName(
            [in] ICharSequence * name);

        /**
         * Set the user-visible name of this route.
         * <p>
         * The route name identifies the destination represented by the route.
         * It may be a user-supplied name, an alias, or device serial number.
         * </p>
         *
         * @param resId Resource ID of the name to display to the user to describe this route
         */
        SetName(
            [in] Int32 resId);

        /**
         * Set the user-visible description of this route.
         * <p>
         * The route description describes the kind of destination represented by the route.
         * It may be a user-supplied string, a model number or brand of device.
         * </p>
         *
         * @param description The description of the route, or null if none.
         */
        SetDescription(
            [in] ICharSequence * description);

        /**
         * Set the current user-visible status for this route.
         * @param status Status to display to the user to describe what the endpoint
         * of this route is currently doing
         */
        SetStatus(
            [in] ICharSequence * status) ;

        /**
         * Set the RemoteControlClient responsible for reporting playback info for this
         * user route.
         *
         * <p>If this route manages remote playback, the data exposed by this
         * RemoteControlClient will be used to reflect and update information
         * such as route volume info in related UIs.</p>
         *
         * <p>The RemoteControlClient must have been previously registered with
         * {@link AudioManager#registerRemoteControlClient(RemoteControlClient)}.</p>
         *
         * @param rcc RemoteControlClient associated with this route
         */
        SetRemoteControlClient(
            [in] IRemoteControlClient * rcc);

        /**
         * Retrieve the RemoteControlClient associated with this route, if one has been set.
         *
         * @return the RemoteControlClient associated with this route
         * @see #setRemoteControlClient(RemoteControlClient)
         */
        GetRemoteControlClient(
            [out] IRemoteControlClient ** result);

        /**
         * Set an icon that will be used to represent this route.
         * The system may use this icon in picker UIs or similar.
         *
         * @param icon icon drawable to use to represent this route
         */
        SetIconDrawable(
            [in] IDrawable * icon);

        /**
         * Set an icon that will be used to represent this route.
         * The system may use this icon in picker UIs or similar.
         *
         * @param resId Resource ID of an icon drawable to use to represent this route
         */
        SetIconResource(
            [in] Int32 resId);

        /**
         * Set a callback to be notified of volume update requests
         * @param vcb
         */
        SetVolumeCallback(
            [in] IMediaRouterVolumeCallback * vcb);

        /**
         * Defines whether playback associated with this route is "local"
         *    ({@link RouteInfo#PLAYBACK_TYPE_LOCAL}) or "remote"
         *    ({@link RouteInfo#PLAYBACK_TYPE_REMOTE}).
         * @param type
         */
        SetPlaybackType(
            [in] Int32 type);

        /**
         * Defines whether volume for the playback associated with this route is fixed
         * ({@link RouteInfo#PLAYBACK_VOLUME_FIXED}) or can modified
         * ({@link RouteInfo#PLAYBACK_VOLUME_VARIABLE}).
         * @param volumeHandling
         */
        SetVolumeHandling(
            [in] Int32 volumeHandling);

        /**
         * Defines at what volume the playback associated with this route is performed (for user
         * feedback purposes). This information is only used when the playback is not local.
         * @param volume
         */
        SetVolume(
            [in] Int32 volume);

        /**
         * Defines the maximum volume at which the playback associated with this route is performed
         * (for user feedback purposes). This information is only used when the playback is not
         * local.
         * @param volumeMax
         */
        SetVolumeMax(
            [in] Int32 volumeMax);

        /**
         * Defines over what stream type the media is presented.
         * @param stream
         */
        SetPlaybackStream(
            [in] Int32 stream);
    }

    /**
     * MediaRouter allows applications to control the routing of media channels
     * and streams from the current device to external speakers and destination devices.
     *
     * <p>A MediaRouter is retrieved through {@link Context#getSystemService(String)
     * Context.getSystemService()} of a {@link Context#MEDIA_ROUTER_SERVICE
     * Context.MEDIA_ROUTER_SERVICE}.
     *
     * <p>The media router API is not thread-safe; all interactions with it must be
     * done from the main thread of the process.</p>
     */
    [local]
    interface IMediaRouter {
        /**
         * Route type flag for live audio.
         *
         * <p>A device that supports live audio routing will allow the media audio stream
         * to be routed to supported destinations. This can include internal speakers or
         * audio jacks on the device itself, A2DP devices, and more.</p>
         *
         * <p>Once initiated this routing is transparent to the application. All audio
         * played on the media stream will be routed to the selected destination.</p>
         */
        const Int32 ROUTE_TYPE_LIVE_AUDIO = 1 << 0;

        /**
         * Route type flag for live video.
         *
         * <p>A device that supports live video routing will allow a mirrored version
         * of the device's primary display or a customized
         * {@link android.app.Presentation Presentation} to be routed to supported destinations.</p>
         *
         * <p>Once initiated, display mirroring is transparent to the application.
         * While remote routing is active the application may use a
         * {@link android.app.Presentation Presentation} to replace the mirrored view
         * on the external display with different content.</p>
         *
         * @see RouteInfo#getPresentationDisplay()
         * @see android.app.Presentation
         */
        const Int32 ROUTE_TYPE_LIVE_VIDEO = 1 << 1;

        /**
         * Temporary interop constant to identify remote displays.
         * @hide To be removed when media router API is updated.
         */
        const Int32 ROUTE_TYPE_REMOTE_DISPLAY = 1 << 2;

        /**
         * Route type flag for application-specific usage.
         *
         * <p>Unlike other media route types, user routes are managed by the application.
         * The MediaRouter will manage and dispatch events for user routes, but the application
         * is expected to interpret the meaning of these events and perform the requested
         * routing tasks.</p>
         */
        const Int32 ROUTE_TYPE_USER = 1 << 23;

        /**
         * Flag for {@link #addCallback}: Actively scan for routes while this callback
         * is registered.
         * <p>
         * When this flag is specified, the media router will actively scan for new
         * routes.  Certain routes, such as wifi display routes, may not be discoverable
         * except when actively scanning.  This flag is typically used when the route picker
         * dialog has been opened by the user to ensure that the route information is
         * up to date.
         * </p><p>
         * Active scanning may consume a significant amount of power and may have intrusive
         * effects on wireless connectivity.  Therefore it is important that active scanning
         * only be requested when it is actually needed to satisfy a user request to
         * discover and select a new route.
         * </p>
         */
        const Int32 CALLBACK_FLAG_PERFORM_ACTIVE_SCAN = 1 << 0;

        /**
         * Flag for {@link #addCallback}: Do not filter route events.
         * <p>
         * When this flag is specified, the callback will be invoked for event that affect any
         * route even if they do not match the callback's filter.
         * </p>
         */
        const Int32 CALLBACK_FLAG_UNFILTERED_EVENTS = 1 << 1;

        /**
         * Explicitly requests discovery.
         *
         * @hide Future API ported from support library.  Revisit this later.
         */
        const Int32 CALLBACK_FLAG_REQUEST_DISCOVERY = 1 << 2;

        /**
         * Requests that discovery be performed but only if there is some other active
         * callback already registered.
         *
         * @hide Compatibility workaround for the fact that applications do not currently
         * request discovery explicitly (except when using the support library API).
         */
        const Int32 CALLBACK_FLAG_PASSIVE_DISCOVERY = 1 << 3;

        /**
         * Flag for {@link #isRouteAvailable}: Ignore the default route.
         * <p>
         * This flag is used to determine whether a matching non-default route is available.
         * This constraint may be used to decide whether to offer the route chooser dialog
         * to the user.  There is no point offering the chooser if there are no
         * non-default choices.
         * </p>
         *
         * @hide Future API ported from support library.  Revisit this later.
         */
        const Int32 AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE = 1 << 0;

        /**
         * Gets the default route for playing media content on the system.
         * <p>
         * The system always provides a default route.
         * </p>
         *
         * @return The default route, which is guaranteed to never be null.
         */
        GetDefaultRoute(
            [out] IMediaRouterRouteInfo ** result);

        /**
         * @hide for use by framework routing UI
         */
        GetSystemCategory(
            [out] IMediaRouterRouteCategory ** result);

        /** @hide */
        GetSelectedRoute(
            [out] IMediaRouterRouteInfo ** result);

        /**
         * Return the currently selected route for any of the given types
         *
         * @param type route types
         * @return the selected route
         */
        GetSelectedRoute(
            [in] Int32 type,
            [out] IMediaRouterRouteInfo ** result);

        /**
         * Returns true if there is a route that matches the specified types.
         * <p>
         * This method returns true if there are any available routes that match the types
         * regardless of whether they are enabled or disabled.  If the
         * {@link #AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE} flag is specified, then
         * the method will only consider non-default routes.
         * </p>
         *
         * @param types The types to match.
         * @param flags Flags to control the determination of whether a route may be available.
         * May be zero or {@link #AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE}.
         * @return True if a matching route may be available.
         *
         * @hide Future API ported from support library.  Revisit this later.
         */
        IsRouteAvailable(
            [in] Int32 types,
            [in] Int32 flags,
            [out] Boolean * result);

        /**
         * Add a callback to listen to events about specific kinds of media routes.
         * If the specified callback is already registered, its registration will be updated for any
         * additional route types specified.
         * <p>
         * This is a convenience method that has the same effect as calling
         * {@link #addCallback(int, Callback, int)} without flags.
         * </p>
         *
         * @param types Types of routes this callback is interested in
         * @param cb Callback to add
         */
        AddCallback(
            [in] Int32 types,
            [in] IMediaRouterCallback * cb);

        /**
         * Add a callback to listen to events about specific kinds of media routes.
         * If the specified callback is already registered, its registration will be updated for any
         * additional route types specified.
         * <p>
         * By default, the callback will only be invoked for events that affect routes
         * that match the specified selector.  The filtering may be disabled by specifying
         * the {@link #CALLBACK_FLAG_UNFILTERED_EVENTS} flag.
         * </p>
         *
         * @param types Types of routes this callback is interested in
         * @param cb Callback to add
         * @param flags Flags to control the behavior of the callback.
         * May be zero or a combination of {@link #CALLBACK_FLAG_PERFORM_ACTIVE_SCAN} and
         * {@link #CALLBACK_FLAG_UNFILTERED_EVENTS}.
         */
        AddCallback(
            [in] Int32 types,
            [in] IMediaRouterCallback * cb,
            [in] Int32 flags);

        /**
         * Remove the specified callback. It will no longer receive events about media routing.
         *
         * @param cb Callback to remove
         */
        RemoveCallback(
            [in] IMediaRouterCallback * cb);

        /**
         * Select the specified route to use for output of the given media types.
         * <p class="note">
         * As API version 18, this function may be used to select any route.
         * In prior versions, this function could only be used to select user
         * routes and would ignore any attempt to select a system route.
         * </p>
         *
         * @param types type flags indicating which types this route should be used for.
         *              The route must support at least a subset.
         * @param route Route to select
         */
        SelectRoute(
            [in] Int32 types,
            [in] IMediaRouterRouteInfo * route);

        /**
         * @hide internal use
         */
        SelectRouteInt(
            [in] Int32 types,
            [in] IMediaRouterRouteInfo * route,
            [in] Boolean isExplicit);

        /**
         * Add an app-specified route for media to the MediaRouter.
         * App-specified route definitions are created using {@link #createUserRoute(RouteCategory)}
         *
         * @param info Definition of the route to add
         * @see #createUserRoute(RouteCategory)
         * @see #removeUserRoute(UserRouteInfo)
         */
        AddUserRoute(
            [in] IMediaRouterUserRouteInfo * info);

        /**
         * @hide Framework use only
         */
        AddRouteInt(
            [in] IMediaRouterRouteInfo * info);

        /**
         * Remove an app-specified route for media from the MediaRouter.
         *
         * @param info Definition of the route to remove
         * @see #addUserRoute(UserRouteInfo)
         */
        RemoveUserRoute(
            [in] IMediaRouterUserRouteInfo * info);

        /**
         * Remove all app-specified routes from the MediaRouter.
         *
         * @see #removeUserRoute(UserRouteInfo)
         */
        ClearUserRoutes();

        /**
         * @hide internal use only
         */
        RemoveRouteInt32(
            [in] IMediaRouterRouteInfo * info);

        /**
         * Return the number of {@link MediaRouter.RouteCategory categories} currently
         * represented by routes known to this MediaRouter.
         *
         * @return the number of unique categories represented by this MediaRouter's known routes
         */
        GetCategoryCount(
            [out] Int32 * result);

        /**
         * Return the {@link MediaRouter.RouteCategory category} at the given index.
         * Valid indices are in the range [0-getCategoryCount).
         *
         * @param index which category to return
         * @return the category at index
         */
        GetCategoryAt(
            [in] Int32 index,
            [out] IMediaRouterRouteCategory ** result);

        /**
         * Return the number of {@link MediaRouter.RouteInfo routes} currently known
         * to this MediaRouter.
         *
         * @return the number of routes tracked by this router
         */
        GetRouteCount(
            [out] Int32 * result);

        /**
         * Return the route at the specified index.
         *
         * @param index index of the route to return
         * @return the route at index
         */
        GetRouteAt(
            [in] Int32 index,
            [out] IMediaRouterRouteInfo ** result);

        /**
         * Create a new user route that may be modified and registered for use by the application.
         *
         * @param category The category the new route will belong to
         * @return A new UserRouteInfo for use by the application
         *
         * @see #addUserRoute(UserRouteInfo)
         * @see #removeUserRoute(UserRouteInfo)
         * @see #createRouteCategory(CharSequence, Boolean)
         */
        CreateUserRoute(
            [in] IMediaRouterRouteCategory * category,
            [out] IMediaRouterUserRouteInfo ** result);

        /**
         * Create a new route category. Each route must belong to a category.
         *
         * @param name Name of the new category
         * @param isGroupable true if routes in this category may be grouped with one another
         * @return the new RouteCategory
         */
        CreateRouteCategory(
            [in] ICharSequence * name,
            [in] Boolean isGroupable,
            [out] IMediaRouterRouteCategory ** result);

        /**
         * Create a new route category. Each route must belong to a category.
         *
         * @param nameResId Resource ID of the name of the new category
         * @param isGroupable true if routes in this category may be grouped with one another
         * @return the new RouteCategory
         */
        CreateRouteCategory(
            [in] Int32 nameResId,
            [in] Boolean isGroupable,
            [out] IMediaRouterRouteCategory ** result);

        /**
         * Rebinds the media router to handle routes that belong to the specified user.
         * Requires the interact across users permission to access the routes of another user.
         * <p>
         * This method is a complete hack to work around the singleton nature of the
         * media router when running inside of singleton processes like QuickSettings.
         * This mechanism should be burned to the ground when MediaRouter is redesigned.
         * Ideally the current user would be pulled from the Context but we need to break
         * down MediaRouter.Static before we can get there.
         * </p>
         *
         * @hide
         */
        RebindAsUser(
            [in] Int32 userId);
    }

    [local]
    interface IMediaRouterHelper
    {
        SelectRouteStatic(
            [in] Int32 types,
            [in] IMediaRouterRouteInfo* route,
            [in] Boolean isexplicit);

        SelectDefaultRouteStatic();

        /**
         * Compare the device address of a display and a route.
         * Nulls/no device address will match another null/no address.
         */
        MatchesDeviceAddress(
            [in] IWifiDisplay* display,
            [in] IMediaRouterRouteInfo* info,
            [out] Boolean* result);

        AddRouteStatic(
            [in] IMediaRouterRouteInfo* info);

        RemoveRouteStatic(
            [in] IMediaRouterRouteInfo* info);

        GetRouteCountStatic(
            [out] Int32* result);

        GetRouteAtStatic(
            [in] Int32 index,
            [out] IMediaRouterRouteInfo** result);

        UpdateRoute(
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteSelected(
            [in] Int32 type,
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteUnselected(
            [in] Int32 type,
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteChanged(
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteChanged(
            [in] IMediaRouterRouteInfo* info,
            [in] Int32 oldSupportedTypes);

        DispatchRouteAdded(
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteRemoved(
            [in] IMediaRouterRouteInfo* info);

        DispatchRouteGrouped(
            [in] IMediaRouterRouteInfo* info,
            [in] IMediaRouterRouteGroup* group,
            [in] Int32 index);

        DispatchRouteUngrouped(
            [in] IMediaRouterRouteInfo* info,
            [in] IMediaRouterRouteGroup* group);

        DispatchRouteVolumeChanged(
            [in] IMediaRouterRouteInfo* info);

        DispatchRoutePresentationDisplayChanged(
            [in] IMediaRouterRouteInfo* info);

        SystemVolumeChanged(
            [in] Int32 newValue);

        UpdateWifiDisplayStatus(
            [in] IWifiDisplayStatus* status);

        GetWifiDisplayStatusCode(
            [in] IWifiDisplay* d,
            [in] IWifiDisplayStatus* wfdStatus,
            [out] Int32* result);

        IsWifiDisplayEnabled(
            [in] IWifiDisplay* d,
            [in] IWifiDisplayStatus* wfdStatus,
            [out] Boolean* result);

        MakeWifiDisplayRoute(
            [in] IWifiDisplay* display,
            [in] IWifiDisplayStatus* wfdStatus,
            [out] IMediaRouterRouteInfo** result);
    }

    } // namespace Media
    } // namepsace Droid
    } // namespace Elastos
}
