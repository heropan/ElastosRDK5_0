module
{
    using interface Elastos.Core.IStringBuilder;
    using interface Elastos.IO.IPrintWriter;
    using interface Elastos.Utility.IList;
    using interface Elastos.Utility.IMap;
    using interface Elastos.Utility.IHashMap;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Utility.IPrinter;
    interface Elastos.Droid.Utility.ISparseArray;

    namespace Elastos {
    namespace Droid {
    namespace Os {

    /**
     * State for keeping track of counting information.
     */
    [local]
    interface IBatteryStatsCounter {
        /**
         * Returns the count associated with this Counter for the
         * selected type of statistics.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT
         */
        GetCountLocked(
            [in] Int32 which,
            [out] Int32* count);

        /**
         * Temporary for debugging.
         */
        LogState(
            [in] IPrinter* pw,
            [in] String prefix);
    }

    /**
     * State for keeping track of Int64 counting information.
     */
    [local]
    interface IBatteryStatsLongCounter {
        /**
         * Returns the count associated with this Counter for the
         * selected type of statistics.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT
         */
        GetCountLocked(
            [in] Int32 which,
            [out] Int64* count);

        /**
         * Temporary for debugging.
         */
        LogState(
            [in] IPrinter* pw,
            [in] String prefix);
    }

    /**
     * State for keeping track of timing information.
     */
    [local]
    interface IBatteryStatsTimer {
        /**
         * Returns the count associated with this Timer for the
         * selected type of statistics.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT
         */
        GetCountLocked(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the total time in microseconds associated with this Timer for the
         * selected type of statistics.
         *
         * @param elapsedRealtimeUs current elapsed realtime of system in microseconds
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT
         * @return a time in microseconds
         */
        GetTotalTimeLocked(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Temporary for debugging.
         */
        LogState(
            [in] IPrinter* pw,
            [in] String prefix);
    }

    /**
     * The statistics associated with a particular wake lock.
     */
    [local]
    interface IBatteryStatsUidWakelock {
        GetWakeTime(
            [in] Int32 type,
            [out] IBatteryStatsTimer** timer);
    }

    [local]
    interface IBatteryStatsUidSensor {
        /*
         * FIXME: it's not correct to use this magic value because it
         * could clash with a sensor handle (which are defined by
         * the sensor HAL, and therefore out of our control
         */
        // Magic sensor number for the GPS.
        const Int32 GPS = -10000;

        GetSensorTime(
            [out] IBatteryStatsTimer** time);
    }

    [local]
    interface IBatteryStatsUidPid {
        GetWakeNesting(
            [out] Int32* wakeNesting);

        SetWakeNesting(
            [in] Int32 wakeNesting);

        GetWakeSumMs(
            [out] Int64* wakeSumMs);

        SetWakeSumMs(
            [in] Int64 wakeSumMs);

        GetWakeStartMs(
            [out] Int64* wakeStartMs);

        SetWakeStartMs(
            [in] Int64 wakeStartMs);
    }

    [local]
    interface IBatteryStatsUidProcExcessivePower {
        const Int32 TYPE_WAKE = 1;
        const Int32 TYPE_CPU = 2;

        GetType(
            [out] Int32* type);

        SetType(
            [in] Int32 type);

        GetOverTime(
            [out] Int64* overTime);

        SetOverTime(
            [in] Int64 overTime);

        GetUsedTime(
            [out] Int64* usedTime);

        SetUsedTime(
            [in] Int64 usedTime);
    }

    /**
     * The statistics associated with a particular process.
     */
    [local]
    interface IBatteryStatsUidProc {
        /**
         * Returns true if this process is still active in the battery stats.
         */
        IsActive(
            [out] Boolean* result);

        /**
         * Returns the total time (in 1/100 sec) spent executing in user code.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetUserTime(
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total time (in 1/100 sec) spent executing in system code.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetSystemTime(
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times the process has been started.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetStarts(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the cpu time spent in microseconds while the process was in the foreground.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         * @return foreground cpu time in microseconds
         */
        GetForegroundTime(
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the approximate cpu time spent in microseconds, at a certain CPU speed.
         * @param speedStep the index of the CPU speed. This is not the actual speed of the
         * CPU.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         * @see BatteryStats#getCpuSpeedSteps()
         */
        GetTimeAtCpuSpeedStep(
            [in] Int32 speedStep,
            [in] Int32 which,
            [out] Int64* result);

        CountExcessivePowers(
            [out] Int32* result);

        GetExcessivePower(
            [in] Int32 i,
            [out] IBatteryStatsUidProcExcessivePower** excessivePower);
    }

    /**
     * The statistics associated with a particular service.
     */
    [local]
    interface IBatteryStatsUidPkgServ {
        /**
         * Returns the amount of time spent started.
         *
         * @param batteryUptime elapsed uptime on battery in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         * @return
         */
        GetStartTime(
            [in] Int64 batteryUptime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total number of times startService() has been called.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetStarts(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the total number times the service has been launched.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetLaunches(
            [in] Int32 which,
            [out] Int32* result);
    }

    /**
     * The statistics associated with a particular package.
     */
    [local]
    interface IBatteryStatsUidPkg {
        /**
         * Returns the number of times this package has done something that could wake up the
         * device from sleep.
         *
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        GetWakeups(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns a mapping containing service statistics.
         */
        GetServiceStats(
            [out] IMap** stats);
    }

    /**
     * The statistics associated with a particular uid.
     */
    [local]
    interface IBatteryStatsUid {
        // Time this uid has any processes in foreground state.
        const Int32 PROCESS_STATE_FOREGROUND = 0;
        // Time this uid has any process in active state (not cached).
        const Int32 PROCESS_STATE_ACTIVE = 1;
        // Time this uid has any processes running at all.
        const Int32 PROCESS_STATE_RUNNING = 2;
        // Total number of process states we track.
        const Int32 NUM_PROCESS_STATE = 3;

        const Int32 NUM_WIFI_BATCHED_SCAN_BINS = 5;

        const Int32 NUM_USER_ACTIVITY_TYPES = 3;

        /**
         * Returns a mapping containing wakelock statistics.
         *
         * @return a Map from Strings to Uid.Wakelock objects.
         */
        GetWakelockStats(
            [out] IMap** stats);

        /**
         * Returns a mapping containing sync statistics.
         *
         * @return a Map from Strings to Timer objects.
         */
        GetSyncStats(
            [out] IMap** stats);

        /**
         * Returns a mapping containing scheduled job statistics.
         *
         * @return a Map from Strings to Timer objects.
         */
        GetJobStats(
            [out] IMap** stats);

        /**
         * Returns a mapping containing sensor statistics.
         *
         * @return a Map from Integer sensor ids to Uid.Sensor objects.
         */
        GetSensorStats(
            [out] ISparseArray** stats);

        /**
         * Returns a mapping containing active process data.
         */
        GetPidStats(
            [out] ISparseArray** stats);

        /**
         * Returns a mapping containing process statistics.
         *
         * @return a Map from Strings to Uid.Proc objects.
         */
        GetProcessStats(
            [out] IMap** stats);

        /**
         * Returns a mapping containing package statistics.
         *
         * @return a Map from Strings to Uid.Pkg objects.
         */
        GetPackageStats(
            [out] IMap** stats);

        /**
         * {@hide}
         */
        GetUid(
            [out] Int32* result);

        NoteWifiRunningLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiStoppedLocked(
            [in] Int64 elapsedRealtime);

        NoteFullWifiLockAcquiredLocked(
            [in] Int64 elapsedRealtime);

        NoteFullWifiLockReleasedLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiScanStartedLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiScanStoppedLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiBatchedScanStartedLocked(
            [in] Int32 csph,
            [in] Int64 elapsedRealtime);

        NoteWifiBatchedScanStoppedLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiMulticastEnabledLocked(
            [in] Int64 elapsedRealtime);

        NoteWifiMulticastDisabledLocked(
            [in] Int64 elapsedRealtime);

        NoteActivityResumedLocked(
            [in] Int64 elapsedRealtime);

        NoteActivityPausedLocked(
            [in] Int64 elapsedRealtime);

        GetWifiRunningTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetFullWifiLockTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetWifiScanTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetWifiBatchedScanTime(
            [in] Int32 csphBin,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetWifiMulticastTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetAudioTurnedOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetVideoTurnedOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetForegroundActivityTimer(
            [out] IBatteryStatsTimer** timer);

        GetProcessStateTime(
            [in] Int32 state,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetVibratorOnTimer(
            [out] IBatteryStatsTimer** timer);

        NoteUserActivityLocked(
            [in] Int32 type);

        HasUserActivity(
            [out] Boolean* result);

        GetUserActivityCount(
            [in] Int32 type,
            [in] Int32 which,
            [out] Int32* result);

        HasNetworkActivity(
            [out] Boolean* result);

        GetNetworkActivityBytes(
            [in] Int32 type,
            [in] Int32 which,
            [out] Int64* result);

        GetNetworkActivityPackets(
            [in] Int32 type,
            [in] Int32 which,
            [out] Int64* result);

        GetMobileRadioActiveTime(
            [in] Int32 which,
            [out] Int64* result);

        GetMobileRadioActiveCount(
            [in] Int32 which,
            [out] Int32* result);
    }

    [local]
    interface IBatteryStatsHistoryTag {
        SetTo(
            [in] IBatteryStatsHistoryTag* o);

        SetTo(
            [in] String _string,
            [in] Int32 _uid);

        WriteToParcel(
            [in] IParcel* dest,
            [in] Int32 flags);

        ReadFromParcel(
            [in] IParcel* src);

        GetString(
            [out] String* string);

        SetString(
            [in] String string);

        GetUid(
            [out] Int32* uid);

        SetUid(
            [in] Int32 uid);

        GetPoolIdx(
            [out] Int32* poolIdx);

        SetPoolIdx(
            [in] Int32 poolIdx);
    }

    /**
     * @Involve
     * interface IParcelable
     */
    interface IBatteryStatsHistoryItem {
        const Byte CMD_UPDATE = 0;        // These can be written as deltas
        const Byte CMD_NULL = -1;
        const Byte CMD_START = 4;
        const Byte CMD_CURRENT_TIME = 5;
        const Byte CMD_OVERFLOW = 6;
        const Byte CMD_RESET = 7;

        // Constants from SCREEN_BRIGHTNESS_*
        const Int32 STATE_BRIGHTNESS_SHIFT = 0;
        const Int32 STATE_BRIGHTNESS_MASK = 0x7;
        // Constants from SIGNAL_STRENGTH_*
        const Int32 STATE_PHONE_SIGNAL_STRENGTH_SHIFT = 3;
        const Int32 STATE_PHONE_SIGNAL_STRENGTH_MASK = 0x7 << STATE_PHONE_SIGNAL_STRENGTH_SHIFT;
        // Constants from ServiceState.STATE_*
        const Int32 STATE_PHONE_STATE_SHIFT = 6;
        const Int32 STATE_PHONE_STATE_MASK = 0x7 << STATE_PHONE_STATE_SHIFT;
        // Constants from DATA_CONNECTION_*
        const Int32 STATE_DATA_CONNECTION_SHIFT = 9;
        const Int32 STATE_DATA_CONNECTION_MASK = 0x1f << STATE_DATA_CONNECTION_SHIFT;

        // These states always appear directly in the first Int32 token
        // of a delta change; they should be ones that change relatively
        // frequently.
        const Int32 STATE_CPU_RUNNING_FLAG = 0x80000000; // 1<<31
        const Int32 STATE_WAKE_LOCK_FLAG = 1<<30;
        const Int32 STATE_GPS_ON_FLAG = 1<<29;
        const Int32 STATE_WIFI_FULL_LOCK_FLAG = 1<<28;
        const Int32 STATE_WIFI_SCAN_FLAG = 1<<27;
        const Int32 STATE_WIFI_MULTICAST_ON_FLAG = 1<<26;
        const Int32 STATE_MOBILE_RADIO_ACTIVE_FLAG = 1<<25;
        // These are on the lower bits used for the command; if they change
        // we need to write another Int32 of data.
        const Int32 STATE_SENSOR_ON_FLAG = 1<<23;
        const Int32 STATE_AUDIO_ON_FLAG = 1<<22;
        const Int32 STATE_PHONE_SCANNING_FLAG = 1<<21;
        const Int32 STATE_SCREEN_ON_FLAG = 1<<20;
        const Int32 STATE_BATTERY_PLUGGED_FLAG = 1<<19;
        const Int32 STATE_PHONE_IN_CALL_FLAG = 1<<18;
        const Int32 STATE_BLUETOOTH_ON_FLAG = 1<<16;

        const Int32 MOST_INTERESTING_STATES =
            STATE_BATTERY_PLUGGED_FLAG | STATE_SCREEN_ON_FLAG
            | STATE_PHONE_IN_CALL_FLAG | STATE_BLUETOOTH_ON_FLAG;

        // Constants from WIFI_SUPPL_STATE_*
        const Int32 STATE2_WIFI_SUPPL_STATE_SHIFT = 0;
        const Int32 STATE2_WIFI_SUPPL_STATE_MASK = 0xf;
        // Values for NUM_WIFI_SIGNAL_STRENGTH_BINS
        const Int32 STATE2_WIFI_SIGNAL_STRENGTH_SHIFT = 4;
        const Int32 STATE2_WIFI_SIGNAL_STRENGTH_MASK =
                0x7 << STATE2_WIFI_SIGNAL_STRENGTH_SHIFT;

        const Int32 STATE2_LOW_POWER_FLAG = 0x80000000; // 1<<31
        const Int32 STATE2_VIDEO_ON_FLAG = 1<<30;
        const Int32 STATE2_WIFI_RUNNING_FLAG = 1<<29;
        const Int32 STATE2_WIFI_ON_FLAG = 1<<28;
        const Int32 STATE2_FLASHLIGHT_FLAG = 1<<27;

        const Int32 MOST_INTERESTING_STATES2 =
            STATE2_LOW_POWER_FLAG | STATE2_WIFI_ON_FLAG;

        const Int32 EVENT_FLAG_START = 0x8000;
        const Int32 EVENT_FLAG_FINISH = 0x4000;

        // No event in this item.
        const Int32 EVENT_NONE = 0x0000;
        // Event is about a process that is running.
        const Int32 EVENT_PROC = 0x0001;
        // Event is about an application package that is in the foreground.
        const Int32 EVENT_FOREGROUND = 0x0002;
        // Event is about an application package that is at the top of the screen.
        const Int32 EVENT_TOP = 0x0003;
        // Event is about active sync operations.
        const Int32 EVENT_SYNC = 0x0004;
        // Events for all additional wake locks aquired/release within a wake block.
        // These are not generated by default.
        const Int32 EVENT_WAKE_LOCK = 0x0005;
        // Event is about an application executing a scheduled job.
        const Int32 EVENT_JOB = 0x0006;
        // Events for users running.
        const Int32 EVENT_USER_RUNNING = 0x0007;
        // Events for foreground user.
        const Int32 EVENT_USER_FOREGROUND = 0x0008;
        // Number of event types.
        const Int32 EVENT_COUNT = 0x0009;
        // Mask to extract out only the type part of the event.
        const Int32 EVENT_TYPE_MASK = 0xffff3fff;//~(EVENT_FLAG_START|EVENT_FLAG_FINISH);

        const Int32 EVENT_PROC_START = EVENT_PROC | EVENT_FLAG_START;
        const Int32 EVENT_PROC_FINISH = EVENT_PROC | EVENT_FLAG_FINISH;
        const Int32 EVENT_FOREGROUND_START = EVENT_FOREGROUND | EVENT_FLAG_START;
        const Int32 EVENT_FOREGROUND_FINISH = EVENT_FOREGROUND | EVENT_FLAG_FINISH;
        const Int32 EVENT_TOP_START = EVENT_TOP | EVENT_FLAG_START;
        const Int32 EVENT_TOP_FINISH = EVENT_TOP | EVENT_FLAG_FINISH;
        const Int32 EVENT_SYNC_START = EVENT_SYNC | EVENT_FLAG_START;
        const Int32 EVENT_SYNC_FINISH = EVENT_SYNC | EVENT_FLAG_FINISH;
        const Int32 EVENT_WAKE_LOCK_START = EVENT_WAKE_LOCK | EVENT_FLAG_START;
        const Int32 EVENT_WAKE_LOCK_FINISH = EVENT_WAKE_LOCK | EVENT_FLAG_FINISH;
        const Int32 EVENT_JOB_START = EVENT_JOB | EVENT_FLAG_START;
        const Int32 EVENT_JOB_FINISH = EVENT_JOB | EVENT_FLAG_FINISH;
        const Int32 EVENT_USER_RUNNING_START = EVENT_USER_RUNNING | EVENT_FLAG_START;
        const Int32 EVENT_USER_RUNNING_FINISH = EVENT_USER_RUNNING | EVENT_FLAG_FINISH;
        const Int32 EVENT_USER_FOREGROUND_START =
                EVENT_USER_FOREGROUND | EVENT_FLAG_START;
        const Int32 EVENT_USER_FOREGROUND_FINISH =
                EVENT_USER_FOREGROUND | EVENT_FLAG_FINISH;

        /**
         * Return whether the command code is a delta data update.
         */
        IsDeltaData(
            [out] Boolean* result);

        Clear();

        SetTo(
            [in] IBatteryStatsHistoryItem* o);

        SetTo(
            [in] Int64 time,
            [in] Byte cmd,
            [in] IBatteryStatsHistoryItem* o);

        SameNonEvent(
            [in] IBatteryStatsHistoryItem* o,
            [out] Boolean* result);

        Same(
            [in] IBatteryStatsHistoryItem* o,
            [out] Boolean* result);
    }

    [local]
    interface IBatteryStatsHistoryEventTracker {
        UpdateState(
            [in] Int32 code,
            [in] String name,
            [in] Int32 uid,
            [in] Int32 poolIdx,
            [out] Boolean* result);

        RemoveEvents(
            [in] Int32 code);

        GetStateForEvent(
            [in] Int32 code,
            [out] IHashMap** hashMap);
    }

    [local]
    interface IBatteryStatsBitDescription {
    }

    [local]
    interface IBatteryStatsHistoryPrinter {
        PrintNextItem(
            [in] IPrintWriter* pw,
            [in] IBatteryStatsHistoryItem* rec,
            [in] Int64 baseTime,
            [in] Boolean checkin,
            [in] Boolean verbose);
    }

    /**
     * @Involve
     * interface IParcelable
     */
    interface IBatteryStats {

        /** @hide */
        const String  SERVICE_NAME = "batterystats";

        /**
         * A constant indicating a partial wake lock timer.
         */
        const Int32 WAKE_TYPE_PARTIAL = 0;

        /**
         * A constant indicating a full wake lock timer.
         */
        const Int32 WAKE_TYPE_FULL = 1;

        /**
         * A constant indicating a window wake lock timer.
         */
        const Int32 WAKE_TYPE_WINDOW = 2;

        /**
         * A constant indicating a sensor timer.
         */
        const Int32 SENSOR = 3;

        /**
         * A constant indicating a a wifi running timer
         */
        const Int32 WIFI_RUNNING = 4;

        /**
         * A constant indicating a full wifi lock timer
         */
        const Int32 FULL_WIFI_LOCK = 5;

        /**
         * A constant indicating a wifi scan
         */
        const Int32 WIFI_SCAN = 6;

         /**
          * A constant indicating a wifi multicast timer
          */
         const Int32 WIFI_MULTICAST_ENABLED = 7;

        /**
         * A constant indicating an audio turn on timer
         */
        const Int32 AUDIO_TURNED_ON = 7;

        /**
         * A constant indicating a video turn on timer
         */
        const Int32 VIDEO_TURNED_ON = 8;

        /**
         * A constant indicating a vibrator on timer
         */
        const Int32 VIBRATOR_ON = 9;

        /**
         * A constant indicating a foreground activity timer
         */
        const Int32 FOREGROUND_ACTIVITY = 10;

        /**
         * A constant indicating a wifi batched scan is active
         */
        const Int32 WIFI_BATCHED_SCAN = 11;

        /**
         * A constant indicating a process state timer
         */
        const Int32 PROCESS_STATE = 12;

        /**
         * A constant indicating a sync timer
         */
        const Int32 SYNC = 13;

        /**
         * A constant indicating a job timer
         */
        const Int32 JOB = 14;

        /**
         * Include all of the data in the stats, including previously saved data.
         */
        const Int32 STATS_SINCE_CHARGED = 0;

        /**
         * Include only the current run in the stats.
         */
        const Int32 STATS_CURRENT = 1;

        /**
         * Include only the run since the last time the device was unplugged in the stats.
         */
        const Int32 STATS_SINCE_UNPLUGGED = 2;

        const Int32 DUMP_UNPLUGGED_ONLY = 1<<0;
        const Int32 DUMP_CHARGED_ONLY = 1<<1;
        const Int32 DUMP_HISTORY_ONLY = 1<<2;
        const Int32 DUMP_INCLUDE_HISTORY = 1<<3;
        const Int32 DUMP_VERBOSE = 1<<4;
        const Int32 DUMP_DEVICE_WIFI_ONLY = 1<<5;

        const Int32 SCREEN_BRIGHTNESS_DARK = 0;
        const Int32 SCREEN_BRIGHTNESS_DIM = 1;
        const Int32 SCREEN_BRIGHTNESS_MEDIUM = 2;
        const Int32 SCREEN_BRIGHTNESS_LIGHT = 3;
        const Int32 SCREEN_BRIGHTNESS_BRIGHT = 4;


        const Int32 NUM_SCREEN_BRIGHTNESS_BINS = 5;

        const Int32 DATA_CONNECTION_NONE = 0;
        const Int32 DATA_CONNECTION_GPRS = 1;
        const Int32 DATA_CONNECTION_EDGE = 2;
        const Int32 DATA_CONNECTION_UMTS = 3;
        const Int32 DATA_CONNECTION_CDMA = 4;
        const Int32 DATA_CONNECTION_EVDO_0 = 5;
        const Int32 DATA_CONNECTION_EVDO_A = 6;
        const Int32 DATA_CONNECTION_1xRTT = 7;
        const Int32 DATA_CONNECTION_HSDPA = 8;
        const Int32 DATA_CONNECTION_HSUPA = 9;
        const Int32 DATA_CONNECTION_HSPA = 10;
        const Int32 DATA_CONNECTION_IDEN = 11;
        const Int32 DATA_CONNECTION_EVDO_B = 12;
        const Int32 DATA_CONNECTION_LTE = 13;
        const Int32 DATA_CONNECTION_EHRPD = 14;
        const Int32 DATA_CONNECTION_HSPAP = 15;
        const Int32 DATA_CONNECTION_OTHER = 16;

        const Int32 NUM_DATA_CONNECTION_TYPES = DATA_CONNECTION_OTHER+1;

        const Int32 WIFI_SUPPL_STATE_INVALID = 0;
        const Int32 WIFI_SUPPL_STATE_DISCONNECTED = 1;
        const Int32 WIFI_SUPPL_STATE_INTERFACE_DISABLED = 2;
        const Int32 WIFI_SUPPL_STATE_INACTIVE = 3;
        const Int32 WIFI_SUPPL_STATE_SCANNING = 4;
        const Int32 WIFI_SUPPL_STATE_AUTHENTICATING = 5;
        const Int32 WIFI_SUPPL_STATE_ASSOCIATING = 6;
        const Int32 WIFI_SUPPL_STATE_ASSOCIATED = 7;
        const Int32 WIFI_SUPPL_STATE_FOUR_WAY_HANDSHAKE = 8;
        const Int32 WIFI_SUPPL_STATE_GROUP_HANDSHAKE = 9;
        const Int32 WIFI_SUPPL_STATE_COMPLETED = 10;
        const Int32 WIFI_SUPPL_STATE_DORMANT = 11;
        const Int32 WIFI_SUPPL_STATE_UNINITIALIZED = 12;

        const Int32 NUM_WIFI_SUPPL_STATES = WIFI_SUPPL_STATE_UNINITIALIZED+1;

        const Int32 WIFI_STATE_OFF = 0;
        const Int32 WIFI_STATE_OFF_SCANNING = 1;
        const Int32 WIFI_STATE_ON_NO_NETWORKS = 2;
        const Int32 WIFI_STATE_ON_DISCONNECTED = 3;
        const Int32 WIFI_STATE_ON_CONNECTED_STA = 4;
        const Int32 WIFI_STATE_ON_CONNECTED_P2P = 5;
        const Int32 WIFI_STATE_ON_CONNECTED_STA_P2P = 6;
        const Int32 WIFI_STATE_SOFT_AP = 7;

        const Int32 NUM_WIFI_STATES = WIFI_STATE_SOFT_AP+1;

        const Int32 NUM_WIFI_SIGNAL_STRENGTH_BINS = 5;

        const Int32 BLUETOOTH_STATE_INACTIVE = 0;
        const Int32 BLUETOOTH_STATE_LOW = 1;
        const Int32 BLUETOOTH_STATE_MEDIUM = 2;
        const Int32 BLUETOOTH_STATE_HIGH = 3;

        const Int32 NUM_BLUETOOTH_STATES = BLUETOOTH_STATE_HIGH +1;

        const Int32 NETWORK_MOBILE_RX_DATA = 0;
        const Int32 NETWORK_MOBILE_TX_DATA = 1;
        const Int32 NETWORK_WIFI_RX_DATA = 2;
        const Int32 NETWORK_WIFI_TX_DATA = 3;

        const Int32 NUM_NETWORK_ACTIVITY_TYPES = NETWORK_WIFI_TX_DATA + 1;

        // The part of a step duration that is the actual time.
        const Int64 STEP_LEVEL_TIME_MASK = 0x000000ffffffffff;

        // Bits in a step duration that are the new battery level we are at.
        const Int64 STEP_LEVEL_LEVEL_MASK = 0x0000ff0000000000;
        const Int64 STEP_LEVEL_LEVEL_SHIFT = 40;

        // Bits in a step duration that are the initial mode we were in at that step.
        const Int64 STEP_LEVEL_INITIAL_MODE_MASK = 0x00ff000000000000;
        const Int64 STEP_LEVEL_INITIAL_MODE_SHIFT = 48;

        // Bits in a step duration that indicate which modes changed during that step.
        const Int64 STEP_LEVEL_MODIFIED_MODE_MASK = 0xff00000000000000;
        const Int64 STEP_LEVEL_MODIFIED_MODE_SHIFT = 56;

        // Step duration mode: the screen is on, off, dozed, etc; value is Display.STATE_* - 1.
        const Int32 STEP_LEVEL_MODE_SCREEN_STATE = 0x03;

        // Step duration mode: power save is on.
        const Int32 STEP_LEVEL_MODE_POWER_SAVE = 0x04;

        /**
         * Don't allow any more batching in to the current history event.  This
         * is called when printing partial histories, so to ensure that the next
         * history event will go in to a new batch after what was printed in the
         * last partial history.
         */
        CommitCurrentHistoryBatchLocked();

        GetHistoryTotalSize(
            [out] Int32* result);

        GetHistoryUsedSize(
            [out] Int32* result);

        StartIteratingHistoryLocked(
            [out] Boolean* result);

        GetHistoryStringPoolSize(
            [out] Int32* result);

        GetHistoryStringPoolBytes(
            [out] Int32* result);

        GetHistoryTagPoolString(
            [in] Int32 index,
            [out] String* str);

        GetHistoryTagPoolUid(
            [in] Int32 index,
            [out] Int32* result);

        GetNextHistoryLocked(
            [in] IBatteryStatsHistoryItem* outItem,
            [out] Boolean* result);

        FinishIteratingHistoryLocked();

        StartIteratingOldHistoryLocked(
            [out] Boolean* result);

        GetNextOldHistoryLocked(
            [in] IBatteryStatsHistoryItem* outItem,
            [out] Boolean* result);

        FinishIteratingOldHistoryLocked();

        /**
         * Return the base time offset for the battery history.
         */
        GetHistoryBaseTime(
            [out] Int64* result);

        /**
         * Returns the number of times the device has been started.
         */
        GetStartCount(
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the screen has been on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetScreenOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times the screen was turned on.
         *
         * {@hide}
         */
        GetScreenOnCount(
            [in] Int32 which,
            [out] Int32* result);

        GetInteractiveTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that the screen has been on with
         * the given brightness
         *
         * {@hide}
         */
        GetScreenBrightnessTime(
            [in] Int32 brightnessBin,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that low power mode has been enabled while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetLowPowerModeEnabledTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that low power mode was enabled.
         *
         * {@hide}
         */
        GetLowPowerModeEnabledCount(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the phone has been on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetPhoneOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times a phone call was activated.
         *
         * {@hide}
         */
        GetPhoneOnCount(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the phone has been running with
         * the given signal strength.
         *
         * {@hide}
         */
        GetPhoneSignalStrengthTime(
            [in] Int32 strengthBin,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that the phone has been trying to
         * acquire a signal.
         *
         * {@hide}
         */
        GetPhoneSignalScanningTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times the phone has entered the given signal strength.
         *
         * {@hide}
         */
        GetPhoneSignalStrengthCount(
            [in] Int32 strengthBin,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the mobile network has been active
         * (in a high power state).
         *
         * {@hide}
         */
        GetMobileRadioActiveTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that the mobile network has transitioned to the
         * active state.
         *
         * {@hide}
         */
        GetMobileRadioActiveCount(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that is the difference between the mobile radio
         * time we saw based on the elapsed timestamp when going down vs. the given time stamp
         * from the radio.
         *
         * {@hide}
         */
        GetMobileRadioActiveAdjustedTime(
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that the mobile network has been active
         * (in a high power state) but not being able to blame on an app.
         *
         * {@hide}
         */
        GetMobileRadioActiveUnknownTime(
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Return count of number of times radio was up that could not be blamed on apps.
         *
         * {@hide}
         */
        GetMobileRadioActiveUnknownCount(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the phone has been running with
         * the given data connection.
         *
         * {@hide}
         */
        GetPhoneDataConnectionTime(
            [in] Int32 dataType,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times the phone has entered the given data
         * connection type.
         *
         * {@hide}
         */
        GetPhoneDataConnectionCount(
            [in] Int32 dataType,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that wifi has been on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetWifiOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that wifi has been on and the driver has
         * been in the running state while the device was running on battery.
         *
         * {@hide}
         */
        GetGlobalWifiRunningTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the time in microseconds that WiFi has been running in the given state.
         *
         * {@hide}
         */
        GetWifiStateTime(
            [in] Int32 wifiState,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that WiFi has entered the given state.
         *
         * {@hide}
         */
        GetWifiStateCount(
            [in] Int32 wifiState,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the wifi supplicant has been
         * in a given state.
         *
         * {@hide}
         */
        GetWifiSupplStateTime(
            [in] Int32 state,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that the wifi supplicant has transitioned
         * to a given state.
         *
         * {@hide}
         */
        GetWifiSupplStateCount(
            [in] Int32 state,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that WIFI has been running with
         * the given signal strength.
         *
         * {@hide}
         */
        GetWifiSignalStrengthTime(
            [in] Int32 strengthBin,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times WIFI has entered the given signal strength.
         *
         * {@hide}
         */
        GetWifiSignalStrengthCount(
            [in] Int32 strengthBin,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that bluetooth has been on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetBluetoothOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        GetBluetoothPingCount(
            [out] Int32* result);

        /**
         * Returns the time in microseconds that Bluetooth has been running in the
         * given active state.
         *
         * {@hide}
         */
        GetBluetoothStateTime(
            [in] Int32 bluetoothState,
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that Bluetooth has entered the given active state.
         *
         * {@hide}
         */
        GetBluetoothStateCount(
            [in] Int32 bluetoothState,
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Returns the time in microseconds that the flashlight has been on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetFlashlightOnTime(
            [in] Int64 elapsedRealtimeUs,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the number of times that the flashlight has been turned on while the device was
         * running on battery.
         *
         * {@hide}
         */
        GetFlashlightOnCount(
            [in] Int32 which,
            [out] Int64* result);

        GetNetworkActivityBytes(
            [in] Int32 type,
            [in] Int32 which,
            [out] Int64* result);

        GetNetworkActivityPackets(
            [in] Int32 type,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Return the wall clock time when battery stats data collection started.
         */
        GetStartClockTime(
            [out] Int64* result);

        /**
         * Return platform version tag that we were running in when the battery stats started.
         */
        GetStartPlatformVersion(
            [out] String* str);

        /**
         * Return platform version tag that we were running in when the battery stats ended.
         */
        GetEndPlatformVersion(
            [out] String* str);

        /**
         * Return the internal version code of the parcelled format.
         */
        GetParcelVersion(
            [out] Int32* result);

        /**
         * Return whether we are currently running on battery.
         */
        GetIsOnBattery(
            [out] Boolean* result);

        /**
         * Returns a SparseArray containing the statistics for each uid.
         */
        GetUidStats(
            [out] ISparseArray** stats);

        /**
         * Returns the current battery uptime in microseconds.
         *
         * @param curTime the amount of elapsed realtime in microseconds.
         */
        GetBatteryUptime(
            [in] Int64 curTime,
            [out] Int64* result);

        /**
         * Returns the current battery realtime in microseconds.
         *
         * @param curTime the amount of elapsed realtime in microseconds.
         */
        GetBatteryRealtime(
            [in] Int64 curTime,
            [out] Int64* result);

        /**
         * Returns the battery percentage level at the last time the device was unplugged from power, or
         * the last time it booted on battery power.
         */
        GetDischargeStartLevel(
            [out] Int32* result);

        /**
         * Returns the current battery percentage level if we are in a discharge cycle, otherwise
         * returns the level at the last plug event.
         */
        GetDischargeCurrentLevel(
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged since the stats were
         * last reset after charging, as a lower-end approximation.
         */
        GetLowDischargeAmountSinceCharge(
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged since the stats were
         * last reset after charging, as an upper-end approximation.
         */
        GetHighDischargeAmountSinceCharge(
            [out] Int32* result);

        /**
         * Retrieve the discharge amount over the selected discharge period <var>which</var>.
         */
        GetDischargeAmount(
            [in] Int32 which,
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged while the screen was on,
         * since the last time power was unplugged.
         */
        GetDischargeAmountScreenOn(
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged while the screen was on,
         * since the last time the device was charged.
         */
        GetDischargeAmountScreenOnSinceCharge(
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged while the screen was off,
         * since the last time power was unplugged.
         */
        GetDischargeAmountScreenOff(
            [out] Int32* result);

        /**
         * Get the amount the battery has discharged while the screen was off,
         * since the last time the device was charged.
         */
        GetDischargeAmountScreenOffSinceCharge(
            [out] Int32* result);

        /**
         * Returns the total, last, or current battery uptime in microseconds.
         *
         * @param curTime the elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeBatteryUptime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total, last, or current battery realtime in microseconds.
         *
         * @param curTime the current elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeBatteryRealtime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total, last, or current battery screen off uptime in microseconds.
         *
         * @param curTime the elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeBatteryScreenOffUptime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total, last, or current battery screen off realtime in microseconds.
         *
         * @param curTime the current elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeBatteryScreenOffRealtime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total, last, or current uptime in microseconds.
         *
         * @param curTime the current elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeUptime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Returns the total, last, or current realtime in microseconds.
         *
         * @param curTime the current elapsed realtime in microseconds.
         * @param which one of STATS_SINCE_CHARGED, STATS_SINCE_UNPLUGGED, or STATS_CURRENT.
         */
        ComputeRealtime(
            [in] Int64 curTime,
            [in] Int32 which,
            [out] Int64* result);

        /**
         * Compute an approximation for how much run time (in microseconds) is remaining on
         * the battery.  Returns -1 if no time can be computed: either there is not
         * enough current data to make a decision, or the battery is currently
         * charging.
         *
         * @param curTime The current elepsed realtime in microseconds.
         */
        ComputeBatteryTimeRemaining(
            [in] Int64 curTime,
            [out] Int64* result);

        /**
         * Return the historical number of discharge steps we currently have.
         */
        GetNumDischargeStepDurations(
            [out] Int32* result);

        /**
         * Return the array of discharge step durations; the number of valid
         * items in it is returned by {@link #getNumDischargeStepDurations()}.
         * These values are in milliseconds.
         */
        GetDischargeStepDurationsArray(
            [out, callee] ArrayOf<Int64>* array);

        /**
         * Compute an approximation for how much time (in microseconds) remains until the battery
         * is fully charged.  Returns -1 if no time can be computed: either there is not
         * enough current data to make a decision, or the battery is currently
         * discharging.
         *
         * @param curTime The current elepsed realtime in microseconds.
         */
        ComputeChargeTimeRemaining(
            [in] Int64 curTime,
            [out] Int64* result);

        /**
         * Return the historical number of charge steps we currently have.
         */
        GetNumChargeStepDurations(
            [out] Int32* result);

        /**
         * Return the array of charge step durations; the number of valid
         * items in it is returned by {@link #getNumChargeStepDurations()}.
         * These values are in milliseconds.
         */
        GetChargeStepDurationsArray(
            [out, callee] ArrayOf<Int64>* array);

        GetWakeupReasonStats(
            [out] IMap** stats);

        GetKernelWakelockStats(
            [out] IMap** stats);

        /** Returns the number of different speeds that the CPU can run at */
        GetCpuSpeedSteps(
            [out] Int32* result);

        WriteToParcelWithoutUids(
            [in] IParcel* outParcel,
            [in] Int32 flags);

        FormatRatioLocked(
            [in] Int64 num,
            [in] Int64 den,
            [out] String* result);

        /**
         * Temporary for settings.
         */
        DumpCheckinLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] Int32 which,
            [in] Int32 reqUid);

        /**
         * Checkin server version of dump to produce more compact, computer-readable log.
         *
         * NOTE: all times are expressed in 'ms'.
         */
        DumpCheckinLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] Int32 which,
            [in] Int32 reqUid,
            [in] Boolean wifiOnly);

        /**
         * Temporary for settings.
         */
        DumpLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] String prefix,
            [in] Int32 which,
            [in] Int32 reqUid);

        DumpLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] String prefix,
            [in] Int32 which,
            [in] Int32 reqUid,
            [in] Boolean wifiOnly);

        PrepareForDumpLocked();

        /**
         * Dumps a human-readable summary of the battery statistics to the given PrintWriter.
         *
         * @param pw a Printer to receive the dump output.
         */
        DumpLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] Int32 flags,
            [in] Int32 reqUid,
            [in] Int64 histStart);

        DumpCheckinLocked(
            [in] IContext* context,
            [in] IPrintWriter* pw,
            [in] IList* apps,
            [in] Int32 flags,
            [in] Int64 histStart);
    }

    interface IBatteryStatsHelper {
        FormatTime(
            [in] IStringBuilder* sb,
            [in] Int64 time);

        FormatTimeMs(
            [in] IStringBuilder* sb,
            [in] Int64 time);

        FormatTimeMsNoSpace(
            [in] IStringBuilder* sb,
            [in] Int64 time);
    }

    } // namespace Os
    } // namespace Droid
    } // namespace Elastos
}
