# 注意事项

1. C++类可以实现接口，实现的接口中的方法要用out参数返回，而不是用返回值返回。

2. 对于全部是静态方法的类，可以拆成C++类和CAR类，C++类做成静态类（方法都是静态方法），CAR类做成singleton类。

3. 对于非singleton的CAR类，若该类没有显式的声明constructor，则需要显式的声明无参的constructor。

4. 了解local与parcelable的配合使用。

5. 需消除内嵌类与外部类之间可能存在的循环引用。

6. 声明顺序是内嵌类（public、protected、private）、方法（public、protected、private）、属性（public、protected、private）。

7. 引入头文件和using顺序的顺序是先framework后corelibrary，每个内部按照字母序排列。

8. 用接口类型的输入参数去接收out参数是错的，正确的做法是定义新的局部变量接收输入参数。 
``` cpp
ECode CXXX::RegisterCallback( 
    /* [in] */ IXXXCallback* callback,
    /* [in] */ IHandler* _handler)
{   
    AutoPtr<IHandler> hander = _handler;_ 
    if (callback == NULL) {
        // throw new IllegalArgumentException("callback must not be NULL");
        return E_ILLEGAL_ARGUMENT_EXCEPTION;    
    }   
    if (handler == NULL) { 
        CHandler::New((IHandler**)&handler);   
    }   
    synchronized (mLock) {  
        AddCallbackLocked(callback, handler);   
    }   

    {
    AutoPtr<IHandler> hander;

    CHandler::New((IHandler**)&handler); 
    }

    {
    AutoPtr<IHandler> hander;

    CHandler::New((IHandler**)&handler); 
    }

    if (handler == NULL) { 
        CHandler::New((IHandler**)&handler);   
    }


    return NOERROR; 
}
```

9. 若out参数返回的是this，则取消out参数。
``` cpp
ECode CXXX::SetActiveQueueItemId(
    /* [in] */ Int64 id,
    /* [out] */ IPlaybackStateBuilder ** result)
{  
    VALIDATE_NOT_NULL(result)  
    mActiveItemId = id; 
    *result = this; 
    REFCOUNT_ADD(*result)   
    return NOERROR; 
}
```

10. 遇到Release方法需注意不要与接口的Release方法混淆。
``` cpp
ECode CXXX::SessionHolder::Update()   
{   
    if (mMediaButtonListener == NULL && mRccListener == NULL) { 
        mSession->SetCallback(NULL);    
        mSession->Release();    
        mCb = NULL; 
        IMap::Probe(mHost->mSessions)->Remove(mPi); 
    } 
    else if (mCb == NULL) {  
        mCb = new SessionCallback(this);    
        AutoPtr<IHandler> handler;  
        AutoPtr<ILooper> looper = Looper::GetMainLooper();  
        CHandler::New(looper, (IHandler**)&handler);   
        mSession->SetCallback(IMediaSessionCallback::Probe(mCb), handler); 
    }   
    return NOERROR; 
}
```

11. 把throw里的消息打开，用Logger或Slogger输出，输出的消息不用包装成String，用法类似printf。
``` cpp
ECode CXXX::constructor( 
    /* [in] */ IContext * context,
    /* [in] */ IISessionController * sessionBinder)
{   
    if (sessionBinder == NULL) {    
        // throw new IllegalArgumentException("Session token cannot be NULL" + i);
        Logger::E("", "Session %d", i);
        return E_ILLEGAL_ARGUMENT_EXCEPTION; 
    }  
    if (context == NULL) {
        // throw new IllegalArgumentException("Context cannot be NULL"); 
        return E_ILLEGAL_ARGUMENT_EXCEPTION;
    }  
    ...
}
```

12. 继承Stub的类要封装成CAR类。
``` java
public final class AccessibilityInteractionClient
        extends IAccessibilityInteractionConnectionCallback.Stub
{
    ...
}

public class A {
    public class B extends xxx.Stub {}
}

class A 
{
public:
    class B : pubic IXXX, public IBinder
    {}
}

CarClass(CB) , public A::B
{}
```

13. 要用AutoPtr<xxx>类型变量去接收方法返回值。
``` cpp
ECode CXXX::Create(
    /* [out] */ AutoPtr<IXXXRequest>& lr)
{   
    VALIDATE_NOT_NULL(lr) 
    *lr = XXXRequest::Create().Get(); 
    ---
    AutoPtr<IXXXRequest> _ret = XXXRequest::Create();
    *lr = _ret;
    ---
    *lr = mRequest;

    REFCOUNT_ADD(*lr) 
    return NOERROR;
}

```

14. 在类的实现里，可以将接口指针向类指针转型。
``` cpp
ECode Location::Set(  
    /* [in] */ ILocation* l)  
{   
    AutoPtr<Location> location = (Location*)l; 
    mProvider = location->mProvider;  
    mTime = location->mTime;  
    mElapsedRealtimeNanos = location->mElapsedRealtimeNanos;
    ...
    mIsFromMockProvider = location->mIsFromMockProvider;
    return NOERROR;
}  

CLocation : public Location : public ILocation
```

15. 对于纯虚函数，可以直接用接口里的，不用再次声明。
``` cpp
class T 
    : public Object
    , public ICloneable
{
public:
    virtual CARAPI Clone(
        /* [out] */ IInterface** object) = 0;
}
```

16. Java构造函数的处理方法。
``` java
class A
{
public:
    A(int i, long l) {...}
}

class B extends A
{
public:
    B(int i, long l) { super(i, l); ... }
}

class C extends B
{
public:
    C(int i, long l) { super(i, l); ... }
}
```
``` cpp
class A : public Object
{
public:
    A() {}
    CARAPI constructor(Int32 i, Int64 l) { ... }
}

class B : public A
{
public:
    B() {}
    CARAPI constructor(Int32 i, Int64 l) 
    { FAIL_RETURN(A::constructor(i, l)); ... }
}

class C : public B
{
public:
    C() {}
    CARAPI constructor(Int32 i, Int64 l) 
    { FAIL_RETURN(B::constructor(i, l)); ... }
}
```

17. Java中弱引用的处理。
**获取obj的弱引用**
``` cpp
AutoPtr<IWeakReference> wr;
IWeakReferenceSource::Probe(obj)->GetWeakReference((IWeakReference**)&wr);
```
**从弱引用wr中获取实际接口**
``` cpp
AutoPtr<IXXX> obj;
wr->Resolve(EIID_IXXX, (IInterface**)&obj);
```
或
``` cpp
AutoPtr<IInterface> obj;
wr->Resolve((IInterface**)&obj);
IXXX* xxxObj = IXXX::Probe(obj);
```

18. 在正确的前提下，尽量把C++程序写得高效，比如String的使用。
``` cpp
String str = String("xxx");
```
可以简化为
``` cpp
String str("xxx");
```
``` cpp
String str;
...
str = String("xxx");
```
可以简化为
``` cpp
String str;
...
str = "xxx";
```
``` cpp
*str = String("xxx");
```
可以简化为
``` cpp
*str = "xxx";
```

19. 需注意在C++类的方法里创建C++对象，还是CAR对象？
``` cpp
ECode XXX::Create(
    /* [out] */ IXXX** obj)
{
    AutoPtr<XXX> _obj = new XXX();
or
    CXXX::New(obj);
}
```

20. 保留一个Equals方法。
``` cpp    
ECode XXX::Equals(
    /* [in] */ IInterface* obj,
    /* [out] */ Boolean* result);

ECode XXX::Equals(
    /* [in] */ IXXX* obj,
    /* [out] */ Boolean* result);
```
IObject接口里已有Equals方法，因此，一般情况下，第二个Equals方法是多余的。

21. 需正确使用ELASTOS_LIBS与LIBRARIES。
``` cpp
ld { --whole-archive ELASTOS_LIBS --no-whole-archive LIBRARIES }
```

22. 尽量少用Handle32类型。

23. Clone的实现涉及到Clone、CloneImpl，具体可参考Animation下的代码。

24. CAR类实现了多个接口，创建CAR类时可选择合适接口，减少Probe。
``` cpp
AutoPtr<IArrayList> temp;
CArrayList::New((IArrayList**)&temp);
AutoPtr<IList> l = IList::Probe(temp);
```
可简化为
``` cpp
AutoPtr<IList> l;
CArrayList::New((IList**)&l);
```

25. 放入容器的元素（key或者value），不一定要Probe出IInterface接口。 
``` cpp
AutoPtr<IInteger32> key;
...
AutoPtr<ICharSequence> value;
...
AutoPtr<IMap> map;
...
map->Put(IInterface::Probe(key), IInterface::Probe(value));
可简化为
map->Put(key, value);
```

26. 接口的marshal方法。
``` cpp
if (mIntent != NULL) {
    dest->WriteInt32(1); 
    AutoPtr<IParcelable> parcelable = IParcelable::Probe(mIntent);  
    parcelable->WriteToParcel(dest); 
}  
else {  
    dest->WriteInt32(0);   
}
```
可简化为
``` cpp
dest->WriteInterfacePtr(mIntent);
```

27. 从容器中取出元素后需要Probe出正确的接口再使用。
``` cpp
AutoPtr<IPreferenceActivityHeader> element;
mHeaders->Get(curHeader, (IInterface**)&element);
```
应当写成
``` cpp
AutoPtr<IInterface> element;
mHeaders->Get(curHeader, (IInterface**)&element);
IPreferenceActivityHeader::Probe(element);
```

28. 一种导致循环引用的情况及处理方法。 
在Java源代码中存在如下的实现结构，若在Elastos代码里保留原结构则会存在循环引用。如下例，A和mView会产生循环引用。
``` cpp
class A : IOnClickListener
{
public:
    CARAPI Func()
    {
        mView->SetListener(this);
    }

private:
    AutoPtr<IView> mView;
}
```
针对这种情况，可以采用如下做法避免循环引用。
``` cpp
class A : IOnClickListener
{
public:
    class Wrapper : IOnClickListener
    {
    };

public: 
    CARAPI Func()
    {
        mView->SetListener(this);
    }

private:
    AutoPtr<IView> mView;
}
```

29. Elastos::Core::Math中定义了一些常用的数学常量，请使用它们而不是自己在程序中重新定义。

30. 头文件中尽量不要引入cpp里才用到的资源（包括头文件和using），请把它们放到cpp文件里。

31. 删除不必要的临时注释，保持代码整洁。

32. 在C++类的无参构造函数里不应该再调用无参的constructor()方法。

33. 如果通过IInterface接口来进行对象判等，请注意判等的两个对象都需要Probe出IInterface接口，特别是在Equals方法中。

34. 请注意下面的代码存在引用计数泄漏的问题，需避免。
``` cpp
AutoPtr<IInterface> obj;
for (...) {
    target->Get(i, (IInterface**)&obj);
}
```

35. AutoPtr<...>变量不必显式的赋NULL值。

36. car文件里namespace下不要缩进。

37. 同一模块内可以不用singleton类。

38. ECO_PUBLIC和ECO_LOCAL不用修饰非静态成员变量，这涉及到针对非静态成员变量与静态成员变量的不同符号处理方式。

39. New已经优化过，同一模块内的New内部调用NewByFriend，因此在静态变量初始化时不一定非要调用NewByFriend，也可调用New。

40. Java里的静态成员变量初始化与static{...}执行的顺序是按照它们声明的顺序。例如，下例中，sObj1、sObj2以及static块的执行顺序是sObj1、static块、sObj2。转译成Elastos程序需注意它们的执行顺序。
``` java
class A
{
public:
    static Object sObj1 = new Object();
    static {
        ...
    }
    static Object sObj2 = new Object();
};
```
